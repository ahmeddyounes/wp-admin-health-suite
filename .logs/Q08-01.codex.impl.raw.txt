Status: DONE

Summary of changes
- Auto-register WP-Cron/Action Scheduler hooks per task on registry registration (so any registered task can be executed via `wpha_{task_id}`) in `includes/Scheduler/SchedulerRegistry.php:263`.
- Added schedule management + discovery helpers to the registry (`get_task_hook`, `schedule_task`, `unschedule_task`, `get_next_run`) in `includes/Scheduler/SchedulerRegistry.php:115`.
- Added an option-based lock fallback when MySQL `GET_LOCK()` is unavailable, and switched lock keys to a stable `md5(task_id)` form in `includes/Scheduler/SchedulerRegistry.php:315`.
- Simplified Scheduler cron hook wiring: removed hardcoded per-task `add_action` calls and made the generic executor hook safer, plus inject `ConnectionInterface` into the registry for lock queries in `includes/Providers/SchedulerServiceProvider.php:195`.

How to verify
- `npm run lint`
- `npm test`

Risks / follow-ups
- `npm run lint` reports warnings (no errors); `npm test` passes but prints React `act(...)` warnings to console.
- New registry methods (`schedule_task`, `unschedule_task`, etc.) aren’t declared on `SchedulerRegistryInterface` yet; consider adding them when doing Q08-03 if you want to call them via the interface type.

OpenAI Codex v0.86.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite
model: gpt-5.2
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: xhigh
reasoning summaries: auto
session id: 019bcb1f-b87b-74c0-a7ea-d089717177d1
--------
user
You are implementing task Q08-01 in this git repository.

1) Read the spec: .plans/Q08-01.md
2) Read handoff/context: .t2/handoff/Q08-01.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: npm run lint
- test: npm test

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
Plan update
  → Read spec and handoff
  • Inspect current implementation
  • Implement required changes
  • Run lint and tests
  • Summarize and hand off
exec
/bin/zsh -lc 'ls -la' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 59ms:
total 2208
drwxr-xr-x   55 ahmedyounis  staff    1760 Jan 16 09:09 .
drwxr-xr-x   43 ahmedyounis  staff    1376 Jan 11 22:56 ..
-rw-------@   1 ahmedyounis  staff     189 Jan  7 14:37 .babelrc
-rw-r--r--@   1 ahmedyounis  staff    1286 Jan  8 22:57 .eslintrc.json
drwxr-xr-x   14 ahmedyounis  staff     448 Jan 17 00:43 .git
drwxr-xr-x@   3 ahmedyounis  staff      96 Jan 14 06:48 .github
-rw-------@   1 ahmedyounis  staff     346 Jan  8 22:53 .gitignore
drwxr-xr-x@   4 ahmedyounis  staff     128 Jan  7 17:43 .husky
drwxr-xr-x@  10 ahmedyounis  staff     320 Jan 16 23:08 .idea
drwxr-xr-x@ 386 ahmedyounis  staff   12352 Jan 17 00:43 .logs
-rw-r--r--@   1 ahmedyounis  staff   28892 Jan 16 22:58 .phpunit.result.cache
drwxr-xr-x@ 129 ahmedyounis  staff    4128 Jan 17 00:43 .plans
-rw-r--r--@   1 ahmedyounis  staff     119 Jan  7 17:43 .prettierignore
-rw-r--r--@   1 ahmedyounis  staff     409 Jan  8 22:57 .prettierrc.json
drwx------@   3 ahmedyounis  staff      96 Jan  7 14:59 .scripts
drwxr-xr-x@   6 ahmedyounis  staff     192 Jan 16 06:56 .t2
-rw-r--r--@   1 ahmedyounis  staff    9207 Jan  8 22:57 ACCESSIBILITY.md
drwxr-xr-x@   4 ahmedyounis  staff     128 Jan  9 00:36 admin
drwxr-xr-x@   6 ahmedyounis  staff     192 Jan  7 10:29 assets
exec
/bin/zsh -lc "sed -n '1,200p' .plans/Q08-01.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 44ms:
# Q08-01 — Scheduler Registry Review

Review includes/Scheduler/SchedulerRegistry.php for WP-Cron task registration, schedule management, and task discovery. Check for proper hook registration.
exec
/bin/zsh -lc "sed -n '1,200p' .t2/handoff/Q08-01.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 61ms:
# Handoff: Q08-01

Created: 2026-01-17T08:43:32.313523Z

Spec: .plans/Q08-01.md

thinking
**Reviewing code specifications**

The specification is straightforward: I'll review the file `includes/Scheduler/SchedulerRegistry.php`, focusing on WP-Cron task registration, schedule management, and task discovery. I need to ensure that the hooks are properly registered, and it seems like making modifications might be necessary to address any existing issues. So, inspection of the specified file is my next step. Let's open it up and see what we find!
exec
/bin/zsh -lc "sed -n '1,200p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 44ms:
<?php
/**
 * Scheduler Registry
 *
 * Manages registration and execution of schedulable tasks.
 *
 * @package WPAdminHealth\Scheduler
 */

namespace WPAdminHealth\Scheduler;

use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

exec
/bin/zsh -lc "sed -n '200,400p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 48ms:
		 * @since 1.2.0
		 *
		 * @hook wpha_scheduler_after_execute
		 *
		 * @param SchedulableInterface $task    The task that executed.
		 * @param array                $result  Execution result.
		 * @param array                $options Task options.
		 */
		do_action( 'wpha_scheduler_after_execute', $task, $result, $options );

		return $result;
	}

	/**
	 * Acquire a lock for task execution.
	 *
	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
	 * Falls back to transients if GET_LOCK is unavailable.
	 *
	 * @since 1.2.0

thinking
**Exploring SchedulerRegistry usage**

I'm looking into SchedulerRegistry, which registers and executes tasks, and manages locks. The spec instructs me to review SchedulerRegistry.php for WP-Cron task registration and management. However, it doesn't seem to handle the schedule or hook registration itself. Maybe that responsibility lies elsewhere. The spec emphasizes ensuring tasks are correctly registered with WP-Cron, suggesting there could be another class interfacing with WordPress. I think searching the repository for SchedulerRegistry usage could clarify things.
exec
/bin/zsh -lc 'rg -n "class SchedulerRegistry|new SchedulerRegistry|SchedulerRegistry" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 50ms:
./review_tasks.csv:47:Q08-01,"Scheduler Registry Review","Review includes/Scheduler/SchedulerRegistry.php for WP-Cron task registration, schedule management, and task discovery. Check for proper hook registration."
./review_tasks.csv:49:Q08-03,"Scheduler Contracts Review","Review includes/Scheduler/Contracts/ for SchedulableInterface and SchedulerRegistryInterface definitions. Verify proper abstraction and extensibility."
./includes/Scheduler/SchedulerRegistry.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
./includes/Scheduler/SchedulerRegistry.php:22: * Class SchedulerRegistry
./includes/Scheduler/SchedulerRegistry.php:28:class SchedulerRegistry implements SchedulerRegistryInterface {
./includes/Scheduler/Traits/HasScheduledTasks.php:13:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
./includes/Scheduler/Traits/HasScheduledTasks.php:48:		if ( ! $this->container->has( SchedulerRegistryInterface::class ) ) {
./includes/Scheduler/Traits/HasScheduledTasks.php:52:		$registry = $this->container->get( SchedulerRegistryInterface::class );
./includes/Scheduler/Contracts/SchedulerRegistryInterface.php:18: * Interface SchedulerRegistryInterface
./includes/Scheduler/Contracts/SchedulerRegistryInterface.php:24:interface SchedulerRegistryInterface {
./includes/Providers/SchedulerServiceProvider.php:13:use WPAdminHealth\Scheduler\SchedulerRegistry;
./includes/Providers/SchedulerServiceProvider.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
./includes/Providers/SchedulerServiceProvider.php:52:		SchedulerRegistryInterface::class,
./includes/Providers/SchedulerServiceProvider.php:63:		// Register the SchedulerRegistry.
./includes/Providers/SchedulerServiceProvider.php:65:			SchedulerRegistryInterface::class,
./includes/Providers/SchedulerServiceProvider.php:67:				return new SchedulerRegistry();
./includes/Providers/SchedulerServiceProvider.php:70:		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
./includes/Providers/SchedulerServiceProvider.php:141:		$registry = $this->container->get( SchedulerRegistryInterface::class );
./includes/Providers/SchedulerServiceProvider.php:166:		 * @param SchedulerRegistryInterface $registry The scheduler registry.
./includes/Providers/SchedulerServiceProvider.php:194:		$registry = $this->container->get( SchedulerRegistryInterface::class );
exec
/bin/zsh -lc "sed -n '1,220p' includes/Scheduler/Traits/HasScheduledTasks.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 52ms:
<?php
/**
 * Has Scheduled Tasks Trait
 *
 * Provides functionality for service providers to register scheduled tasks.
 *
 * @package WPAdminHealth\Scheduler\Traits
 */

namespace WPAdminHealth\Scheduler\Traits;

use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
exec
/bin/zsh -lc "sed -n '1,260p' includes/Providers/SchedulerServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 41ms:
<?php
/**
 * Scheduler Service Provider
 *
 * Registers the Scheduler service and task registry.
 *
 * @package WPAdminHealth\Providers
 */

namespace WPAdminHealth\Providers;

use WPAdminHealth\Container\ServiceProvider;
use WPAdminHealth\Scheduler\SchedulerRegistry;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
use WPAdminHealth\Database\Tasks\DatabaseCleanupTask;
use WPAdminHealth\Media\Tasks\MediaScanTask;
use WPAdminHealth\Performance\Tasks\PerformanceCheckTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
exec
/bin/zsh -lc "sed -n '1,260p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 64ms:
<?php
/**
 * Database Cleanup Task
 *
 * Scheduled task for database maintenance operations.
 *
 * @package WPAdminHealth\Database\Tasks
 */

namespace WPAdminHealth\Database\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
use WPAdminHealth\Contracts\OrphanedCleanerInterface;
use WPAdminHealth\Contracts\TrashCleanerInterface;
use WPAdminHealth\Contracts\OptimizerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '1,260p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 49ms:
<?php
/**
 * Media Scan Task
 *
 * Scheduled task for media library scanning and maintenance.
 *
 * @package WPAdminHealth\Media\Tasks
 */

namespace WPAdminHealth\Media\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\Contracts\DuplicateDetectorInterface;
use WPAdminHealth\Contracts\LargeFilesInterface;
use WPAdminHealth\Contracts\AltTextCheckerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '1,260p' includes/Performance/Tasks/PerformanceCheckTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 51ms:
<?php
/**
 * Performance Check Task
 *
 * Scheduled task for performance monitoring and analysis.
 *
 * @package WPAdminHealth\Performance\Tasks
 */

namespace WPAdminHealth\Performance\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\AutoloadAnalyzerInterface;
use WPAdminHealth\Contracts\QueryMonitorInterface;
use WPAdminHealth\Contracts\PluginProfilerInterface;
use WPAdminHealth\Contracts\ConnectionInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
exec
/bin/zsh -lc "sed -n '1,260p' includes/Scheduler/AbstractScheduledTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
<?php
/**
 * Abstract Scheduled Task
 *
 * Base class for scheduled task implementations.
 *
 * @package WPAdminHealth\Scheduler
 */

namespace WPAdminHealth\Scheduler;

use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class AbstractScheduledTask

thinking
**Investigating WP-Cron scheduling**

I need to look into how the AbstractScheduledTask doesn't handle scheduling specifically. There might be a scheduler management class associated with WP-Cron schedules that I could explore. I'll search for functions like wp_schedule_event or look into the cron_schedules filter to understand how scheduling is managed within WordPress. This could help clarify the appropriate way to implement scheduling effectively.
exec
/bin/zsh -lc 'rg -n "wp_schedule_event|wp_clear_scheduled_hook|wp_next_scheduled|cron_schedules|wp_unschedule" includes admin -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 52ms:
includes/Installer.php:270:			'cron_schedules',
includes/Installer.php:355:			wp_schedule_event( $next_run, $frequency, $hook );
includes/Installer.php:591:			$timestamp = wp_next_scheduled( $hook );
includes/Installer.php:593:				wp_unschedule_event( $timestamp, $hook );
includes/Installer.php:597:			wp_clear_scheduled_hook( $hook );
includes/Performance/AjaxMonitor.php:110:		if ( ! wp_next_scheduled( 'wpha_ajax_log_cleanup' ) ) {
includes/Performance/AjaxMonitor.php:111:			wp_schedule_event( time(), 'daily', 'wpha_ajax_log_cleanup' );
includes/Settings/SettingsServiceProvider.php:136:		add_filter( 'cron_schedules', array( $this, 'register_cron_schedules' ) );
includes/Settings/SettingsServiceProvider.php:298:	public function register_cron_schedules( array $schedules ): array {
includes/Settings/SettingsServiceProvider.php:985:			wp_clear_scheduled_hook( $hook );
includes/Settings/SettingsServiceProvider.php:986:			wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
includes/Settings/SettingsServiceProvider.php:1002:		wp_clear_scheduled_hook( $hook );

thinking
**Inspecting installer settings**

I see that the installer and settings service provider are important components here, especially around scheduling. I should take a closer look at how the scheduler registry might integrate into this process. It sounds like I need to focus on the relevant sections in includes/Installer.php to understand better how everything fits together. I wonder what additional insights I can gather from that part of the code!
exec
/bin/zsh -lc "sed -n '200,420p' includes/Installer.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 42ms:
			id bigint(20) unsigned NOT NULL AUTO_INCREMENT,
			action varchar(255) NOT NULL,
			execution_time decimal(10,2) NOT NULL,
			memory_used bigint(20) unsigned NOT NULL DEFAULT 0,
			user_role varchar(50) NOT NULL,
			created_at datetime NOT NULL,
			PRIMARY KEY  (id),
			KEY action (action),
			KEY user_role (user_role),
			KEY created_at (created_at),
			KEY execution_time (execution_time)
		) {$charset_collate};";

		dbDelta( $sql_ajax_log );
	}

	/**
	 * Set default settings on installation.
	 *
	 * @since 1.0.0

thinking
**Examining WP-Cron Scheduling**

I'm looking into how the installer schedules tasks on a fresh WordPress install. It uses WP-Cron and has daily, weekly, and monthly schedule names, but it needs a custom filter to ensure weekly and monthly schedules are created since they’re not built-in defaults. I see that the basic WP-Cron options include hourly, twice daily, and daily. Custom schedules like `weekly` and `monthly` should be registered in the SettingsServiceProvider, so I’ll need to check that.
exec
/bin/zsh -lc "sed -n '250,360p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
				'title' => __( 'Database Health', 'wp-admin-health-suite' ),
				'href'  => admin_url( 'admin.php?page=admin-health-database' ),
			),
			'media'      => array(
				'title' => __( 'Media Audit', 'wp-admin-health-suite' ),
				'href'  => admin_url( 'admin.php?page=admin-health-media' ),
			),
			'performance' => array(
				'title' => __( 'Performance', 'wp-admin-health-suite' ),
				'href'  => admin_url( 'admin.php?page=admin-health-performance' ),
			),
			'settings'   => array(
				'title' => __( 'Settings', 'wp-admin-health-suite' ),
				'href'  => admin_url( 'admin.php?page=admin-health-settings' ),
			),
		);

		foreach ( $items as $id => $item ) {
			$wp_admin_bar->add_node(
				array(

thinking
**Exploring schedule management**

I'm checking the settings service provider's registration of cron schedules, specifically for 'weekly' and 'monthly' schedules. It seems like there's a filtering mechanism in the boot process that might be relevant. I plan to look around lines 120 to 170 to see how schedule management is implemented when there are updates to the settings. It’s fascinating to see how these systems organize their tasks!
exec
/bin/zsh -lc "sed -n '100,220p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
		);

		$this->container->bind(
			'settings.media',
			function () {
				return new MediaSettings();
			}
		);

		$this->container->bind(
			'settings.performance',
			function () {
				return new PerformanceSettings();
			}
		);

		$this->container->bind(
			'settings.scheduling',
			function () {
				return new SchedulingSettings();
exec
/bin/zsh -lc "rg -n \"function handle_scheduling_update\" -n includes/Settings/SettingsServiceProvider.php && sed -n '900,1040p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 52ms:
815:	public function handle_scheduling_update( $old_value, $new_value ): void {

		if ( ! empty( $custom_css ) ) {
			// Defense-in-depth: Apply strict sanitization even though input was sanitized on save.
			// This protects against database compromise or import of malicious settings.
			$custom_css = $this->sanitize_css_output( $custom_css );

			if ( ! empty( $custom_css ) ) {
				// Use WordPress's recommended approach for inline styles.
				// Register a dummy handle and attach inline CSS to it.
				wp_register_style( 'wpha-custom-css', false );
				wp_enqueue_style( 'wpha-custom-css' );
				wp_add_inline_style( 'wpha-custom-css', $custom_css );
			}
		}
	}

	/**
	 * Sanitize CSS for output to prevent XSS attacks.
	 *
exec
/bin/zsh -lc "sed -n '760,920p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 56ms:
	public function reset_section(): void {
		// Security: Verify nonce first to confirm request legitimacy.
		check_admin_referer( 'wpha_reset_section' );

		if ( ! current_user_can( 'manage_options' ) ) {
			wp_die( esc_html__( 'You do not have sufficient permissions.', 'wp-admin-health-suite' ) );
		}

		$section = isset( $_POST['section'] ) ? sanitize_key( $_POST['section'] ) : '';

		/** @var SettingsRegistry $registry */
		$registry = $this->container->get( SettingsRegistryInterface::class );
		$sections = $registry->get_sections();

		if ( empty( $section ) || ! isset( $sections[ $section ] ) ) {
			wp_die( esc_html__( 'Invalid section.', 'wp-admin-health-suite' ) );
		}

		$current_settings = $registry->get_settings();
		$default_settings = $registry->get_default_settings();

thinking
**Reviewing scheduling functions**

I'm exploring the settings service provider to understand how it manages scheduling. It seems to use various hooks, specifically through a function called `schedule_task` that relies on `get_interval_seconds` and `get_cron_schedule_name`. That has me wondering if there are custom schedule names too. I think I need to inspect those two functions a bit closer to see what they entail and how they operate.
exec
/bin/zsh -lc "rg -n \"function get_interval_seconds|function get_cron_schedule_name\" includes/Settings/SettingsServiceProvider.php && sed -n '1040,1120p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 52ms:
1043:	private function get_interval_seconds( string $frequency ) {
1059:	private function get_cron_schedule_name( string $frequency ): string {
	 * @param string $frequency Frequency.
	 * @return int|false Interval or false.
	 */
	private function get_interval_seconds( string $frequency ) {
		$intervals = array(
			'daily'   => DAY_IN_SECONDS,
			'weekly'  => WEEK_IN_SECONDS,
			'monthly' => 30 * DAY_IN_SECONDS,
		);

		return $intervals[ $frequency ] ?? false;
	}

	/**
	 * Get WP-Cron schedule name.
	 *
	 * @param string $frequency Frequency.
	 * @return string Schedule name.

thinking
**Evaluating improvements**

I need to focus on implementing the improvements that we've identified during the review. This includes ensuring proper hook registration and possibly using dynamic task hooking. Another point to consider is unifying schedule management for better efficiency. I’ll take a closer look at the includes/Scheduler/Contracts interfaces to see what adjustments are necessary for these changes. There’s a lot to examine, but I'm ready to tackle this step-by-step!
exec
/bin/zsh -lc "sed -n '1,200p' includes/Scheduler/Contracts/SchedulerRegistryInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 49ms:
<?php
/**
 * Scheduler Registry Interface
 *
 * Contract for the scheduler registry that manages schedulable tasks.
 *
 * @package WPAdminHealth\Scheduler\Contracts
 */

namespace WPAdminHealth\Scheduler\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface SchedulerRegistryInterface
 *
 * Defines the contract for task registration and management.

thinking
**Evaluating Cron scheduling**

In Cron schedules, arguments need to be serializable, but tasks often require various options. The schedule management system uses different hooks for each task, meaning custom tasks must manage their own hooks too. Built-in tasks are automatically scheduled, while custom tasks simply appear in the registry unless they're set up with their own scheduling. There's a hook for registering custom tasks but not for automatic scheduling. I’ll need to check the SchedulingSettings file for possible frequency definitions and dynamic mapping.
exec
/bin/zsh -lc "sed -n '1,260p' includes/Settings/SchedulingSettings.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 41ms:
sed: includes/Settings/SchedulingSettings.php: No such file or directory
exec
/bin/zsh -lc 'rg -n "class SchedulingSettings" -S includes | head' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:
includes/Settings/Domain/SchedulingSettings.php:24:class SchedulingSettings extends AbstractDomainSettings {
exec
/bin/zsh -lc "sed -n '1,260p' includes/Settings/Domain/SchedulingSettings.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
<?php
/**
 * Scheduling Settings
 *
 * Task scheduling settings.
 *
 * @package WPAdminHealth\Settings\Domain
 */

namespace WPAdminHealth\Settings\Domain;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class SchedulingSettings
 *
 * Manages task scheduling settings.
exec
/bin/zsh -lc 'rg -n "wpha_execute_registered_task" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:
./includes/Providers/SchedulerServiceProvider.php:178:		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
exec
/bin/zsh -lc 'ls -la includes/Scheduler && rg -n "schedule" includes/Scheduler -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 63ms:
total 24
drwxr-xr-x@  6 ahmedyounis  staff   192 Jan 16 04:39 .
drwxr-xr-x@ 28 ahmedyounis  staff   896 Jan 16 22:08 ..
-rw-r--r--@  1 ahmedyounis  staff  3093 Jan  8 23:36 AbstractScheduledTask.php
drwxr-xr-x@  4 ahmedyounis  staff   128 Jan  8 23:36 Contracts
-rw-r--r--@  1 ahmedyounis  staff  7750 Jan 16 04:39 SchedulerRegistry.php
drwxr-xr-x@  3 ahmedyounis  staff    96 Jan  8 23:45 Traits
includes/Scheduler/AbstractScheduledTask.php:3: * Abstract Scheduled Task
includes/Scheduler/AbstractScheduledTask.php:5: * Base class for scheduled task implementations.
includes/Scheduler/AbstractScheduledTask.php:7: * @package WPAdminHealth\Scheduler
includes/Scheduler/AbstractScheduledTask.php:10:namespace WPAdminHealth\Scheduler;
includes/Scheduler/AbstractScheduledTask.php:12:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
includes/Scheduler/AbstractScheduledTask.php:20: * Class AbstractScheduledTask
includes/Scheduler/AbstractScheduledTask.php:22: * Provides common functionality for scheduled tasks.
includes/Scheduler/AbstractScheduledTask.php:26:abstract class AbstractScheduledTask implements SchedulableInterface {
includes/Scheduler/SchedulerRegistry.php:3: * Scheduler Registry
includes/Scheduler/SchedulerRegistry.php:7: * @package WPAdminHealth\Scheduler
includes/Scheduler/SchedulerRegistry.php:10:namespace WPAdminHealth\Scheduler;
includes/Scheduler/SchedulerRegistry.php:13:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
includes/Scheduler/SchedulerRegistry.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

thinking
**Considering scheduler components**

The scheduler components have some limitations that I need to navigate. The spec seems to suggest implementing a WP-Cron hook registration directly in SchedulerRegistry. With that, tasks could be automatically registered with a naming convention like `wpha_task_{task_id}`. This approach might help unify the service provider. I'll take a closer look at the SchedulableInterface to see if it has a method for managing the hook names and any other relevant details.
exec
/bin/zsh -lc "sed -n '1,140p' includes/Scheduler/Contracts/SchedulableInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 48ms:
<?php
/**
 * Schedulable Interface
 *
 * Contract for scheduled task implementations.
 *
 * @package WPAdminHealth\Scheduler\Contracts
 */

namespace WPAdminHealth\Scheduler\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface SchedulableInterface
 *
 * Defines the contract for tasks that can be scheduled.

thinking
**Investigating task scheduling**

I'm searching for "database_cleanup_frequency" in the Settings domain to see how the UI uses these options. Tasks are currently scheduled based on these settings, and it looks like the scheduler registry needs to register tasks with the WordPress Cron system. There's already a hook, `wpha_execute_registered_task`, intended for generic task handling. I’m considering how to allow custom tasks within that framework. I need to determine what Q08-01 specifically expects and check the ConnectionInterface regarding task locks.
exec
/bin/zsh -lc "sed -n '1,200p' includes/Contracts/ConnectionInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 52ms:
<?php
/**
 * Connection Interface
 *
 * Contract for database connection operations.
 *
 * @package WPAdminHealth\Contracts
 */

namespace WPAdminHealth\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface ConnectionInterface
 *
 * Defines the contract for database operations. Abstracts WPDB to enable



thinking
**Implementing improvements**

I need to make the necessary improvements to meet specifications. This might involve adding a WP-Cron hook registration in the scheduler registry to ensure tasks have their action hooks registered, along with proper schedule management or discovery. I’m realizing we may need to integrate with existing settings and the installer. It looks like there are tasks in review as well, such as Q08-01, which might involve minimal code modifications. I’m considering whether there's an expectation for an API to handle task management. But I need to ensure proper hook registration.
thinking
**Examining task scheduling**

I’m thinking that there’s a potential issue with how tasks are hooked, particularly with `wpha_execute_registered_task`. It seems like WP Cron might call it with missing arguments if tasks aren’t scheduled correctly. Maybe the scheduler in SettingsServiceProvider is responsible for this, passing hooks like `wpha_database_cleanup`. 

It's crucial to ensure that when tasks are registered, their corresponding cron hooks are properly registered. Right now, SchedulerServiceProvider is hardcoding these tasks. If the task list changes, the hooks won’t be registered. Additionally, tasks need to schedule themselves if they're enabled and not scheduled during installation.
thinking
**Investigating task scheduling on activation**

I’m noticing that initial tasks are currently scheduled only during a fresh install rather than during a plugin update. There is a function, `handle_scheduling_update`, for settings updates, but I wonder what happens if the plugin is activated on an existing site with pre-existing settings. If `schedule_initial_tasks` only runs on fresh installs, it might not trigger on reactivation, leaving tasks unscheduled. I'm thinking I should check the activation hook in the `wp-admin-health-suite.php` file to clarify this.
exec
/bin/zsh -lc "sed -n '1,220p' wp-admin-health-suite.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
<?php
/**
 * Plugin Name: WP Admin Health Suite
 * Plugin URI: https://github.com/yourusername/wp-admin-health-suite
 * Description: A comprehensive suite for monitoring and maintaining WordPress admin health and performance.
 * Version: 1.0.0
 * Author: Your Name
 * Author URI: https://yourwebsite.com
 * License: GPL v2 or later
 * License URI: https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain: wp-admin-health-suite
 * Domain Path: /languages
 * Requires at least: 6.0
 * Requires PHP: 7.4
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth;

exec
/bin/zsh -lc "rg -n \"function activate\\(\" -S includes/Plugin.php includes/Installer.php && sed -n '1,220p' includes/Plugin.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 37ms:
includes/Plugin.php:262:	public function activate( $network_wide = false ) {
<?php
/**
 * Main Plugin Class
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth;

use WPAdminHealth\Container\Container;
use WPAdminHealth\Container\ContainerInterface;
use WPAdminHealth\Container\ServiceProvider;
use WPAdminHealth\Integrations\IntegrationManager;
use WPAdminHealth\Providers\BootstrapServiceProvider;
use WPAdminHealth\Providers\CoreServiceProvider;
use WPAdminHealth\Providers\DatabaseServiceProvider;
use WPAdminHealth\Providers\InstallerServiceProvider;
use WPAdminHealth\Providers\IntegrationServiceProvider;
use WPAdminHealth\Providers\MediaServiceProvider;
exec
/bin/zsh -lc "sed -n '220,360p' includes/Plugin.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 55ms:
		 */
		$providers = apply_filters( 'wpha_service_providers', $providers );

		foreach ( $providers as $provider_class ) {
			// Security: Validate each provider class to prevent arbitrary class instantiation.
			// This prevents malicious code from being injected via the filter.
			if ( ! is_string( $provider_class ) ) {
				continue;
			}

			if ( ! class_exists( $provider_class ) ) {
				continue;
			}

			// Ensure the class extends ServiceProvider to prevent arbitrary class instantiation.
			if ( ! is_subclass_of( $provider_class, ServiceProvider::class ) ) {
				continue;
			}

			$this->container->register( new $provider_class( $this->container ) );

thinking
I’m considering how the installation process works. When the `Installer::install` function is called upon activation, I wonder if it schedules initial tasks every time or just for fresh installs. It feels important to clarify this behavior to ensure everything runs smoothly. I'll need to check the specifics of the `install` function to understand its logic better. There’s definitely something to unravel here that could affect overall functionality!
exec
/bin/zsh -lc "rg -n \"function install\\(\" -S includes/Installer.php && sed -n '1,120p' includes/Installer.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 55ms:
84:	public static function install() {
<?php
/**
 * Installer Class
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth;

use WPAdminHealth\Settings\SettingsRegistry;
use WPAdminHealth\Settings\Domain\CoreSettings;
use WPAdminHealth\Settings\Domain\DatabaseSettings;
use WPAdminHealth\Settings\Domain\MediaSettings;
use WPAdminHealth\Settings\Domain\PerformanceSettings;
use WPAdminHealth\Settings\Domain\SchedulingSettings;
use WPAdminHealth\Settings\Domain\AdvancedSettings;
use WPAdminHealth\Contracts\ConnectionInterface;

// Exit if accessed directly.


thinking
**Analyzing plugin task scheduling**

I'm reviewing how the installer schedules tasks only on a fresh install, not when a plugin is reactivated with existing settings. It seems that when a plugin is deactivated and then reactivated, the cron events usually stay intact unless the plugin explicitly clears them. Okay, so tasks remain scheduled even if the plugin is inactive. If the plugin's callbacks aren't registered, then action hooks will trigger but do nothing. So, the need for schedule_initial_tasks might be unnecessary since unscheduled events would require rescheduling, which doesn’t happen here.
thinking
**Exploring task scheduling**

I'm thinking about how activation happens in the admin context with the `schedule_initial_tasks` being called. After activation, a filter is set and removed automatically, which is interesting. The spec wants me to review the scheduler registry for WP-Cron task registration and possibly centralize its functionalities in `SchedulerRegistry`. I see that there's a function called `get_task_definitions`, which might need adjustments for better task discovery and management. I have to keep an eye out for any bugs related to task IDs and see how I can improve the schedule management features.
exec
/bin/zsh -lc "rg -n \"get_task_definitions\\(\" -S includes admin" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 57ms:
includes/Scheduler/SchedulerRegistry.php:310:	public function get_task_definitions(): array {

thinking
**Exploring task integration**

I see that tasks for REST or settings UI aren't integrated anywhere. It makes me wonder if the spec anticipates implementing task discovery for the UI and schedule management, but currently, there's no code utilizing it. Maybe there's an admin page or a scheduler UI out there. So, I think I should search for tasks in the REST or settings area. Searching for "scheduler" in the admin could help clarify this!
exec
/bin/zsh -lc 'rg -n "scheduler" includes admin templates -S | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 64ms:
includes/Scheduler/AbstractScheduledTask.php:7: * @package WPAdminHealth\Scheduler
includes/Scheduler/AbstractScheduledTask.php:10:namespace WPAdminHealth\Scheduler;
includes/Scheduler/AbstractScheduledTask.php:12:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
templates/admin/settings.php:204:				$scheduler_enabled = ! empty( $settings['scheduler_enabled'] );
templates/admin/settings.php:230:							$is_disabled = ! $scheduler_enabled || 'disabled' === $frequency;
templates/admin/settings.php:262:				<?php if ( ! $scheduler_enabled ) : ?>
templates/admin/settings.php:265:							<?php esc_html_e( 'Scheduler is currently disabled. Enable it above to start scheduling tasks.', 'wp-admin-health-suite' ); ?>
includes/Scheduler/SchedulerRegistry.php:3: * Scheduler Registry
includes/Scheduler/SchedulerRegistry.php:7: * @package WPAdminHealth\Scheduler
includes/Scheduler/SchedulerRegistry.php:10:namespace WPAdminHealth\Scheduler;
includes/Scheduler/SchedulerRegistry.php:13:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
includes/Scheduler/SchedulerRegistry.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
includes/Scheduler/SchedulerRegistry.php:22: * Class SchedulerRegistry
includes/Scheduler/SchedulerRegistry.php:28:class SchedulerRegistry implements SchedulerRegistryInterface {
includes/Scheduler/SchedulerRegistry.php:66:		 * Fires when a task is registered with the scheduler.
includes/Scheduler/SchedulerRegistry.php:70:		 * @hook wpha_scheduler_task_registered
includes/Scheduler/SchedulerRegistry.php:75:		do_action( 'wpha_scheduler_task_registered', $task, $task->get_task_id() );
includes/Scheduler/SchedulerRegistry.php:148:		 * @hook wpha_scheduler_before_execute
includes/Scheduler/SchedulerRegistry.php:153:		do_action( 'wpha_scheduler_before_execute', $task, $options );
includes/Scheduler/SchedulerRegistry.php:179:			 * @hook wpha_scheduler_task_failed

thinking
**Inspecting scheduling UI**

I see that the template admin/settings.php has a scheduling UI. I need to take a closer look at that section. It'll be important to analyze how it functions and what features it offers. I want to ensure it meets the user’s needs for scheduling. There might be options or settings that need to be adjusted for optimal use. Let’s dig deeper into this component to understand it better!
exec
/bin/zsh -lc "sed -n '160,320p' templates/admin/settings.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 51ms:
						if ( $field['section'] === 'scheduling' ) {
							?>
							<tr>
								<th scope="row">
									<label for="wpha_<?php echo esc_attr( $field_id ); ?>">
										<?php echo esc_html( $field['title'] ); ?>
									</label>
								</th>
								<td>
									<?php
									$settings_obj->render_field(
										array(
											'id'    => $field_id,
											'field' => $field,
										)
									);
									?>
								</td>
							</tr>
							<?php

thinking
**Considering task implementation**

I'm noticing that the scheduled tasks preview is hardcoded to just three tasks, which limits its dynamism. It seems like the scheduler registry's get_task_definitions isn't being utilized, yet it could make the UI dynamic. 

I think Q08-01 might focus on task discovery and managing schedules, which could let us show all tasks and update or reschedule them automatically. That sounds like a larger implementation, but Q08-01 could be a smaller fix. I'll check the review_tasks.csv for any other related tasks.
exec
/bin/zsh -lc 'rg -n "Q08-0" review_tasks.csv' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 48ms:
47:Q08-01,"Scheduler Registry Review","Review includes/Scheduler/SchedulerRegistry.php for WP-Cron task registration, schedule management, and task discovery. Check for proper hook registration."
48:Q08-02,"Abstract Scheduled Task Review","Review includes/Scheduler/AbstractScheduledTask.php for base task implementation, progress tracking, error handling, and timeout management in long-running tasks."
49:Q08-03,"Scheduler Contracts Review","Review includes/Scheduler/Contracts/ for SchedulableInterface and SchedulerRegistryInterface definitions. Verify proper abstraction and extensibility."
50:Q08-04,"Scheduler Traits Review","Review includes/Scheduler/Traits/HasScheduledTasks.php for reusable scheduling functionality, proper trait composition, and method conflicts handling."






thinking
**Analyzing scheduling components**

I'm looking into Q08 tasks, which involve reviewing scheduling components to find and fix issues. For Q08-01, the focus is on the SchedulerRegistry and improving aspects like WP-Cron registration. Other tasks will address abstract scheduled tasks and traits, but I’m only addressing Q08-01 for now. There’s uncertainty about whether we need to modify the interface, but it might be necessary. I need to analyze the SchedulerRegistry file, which handles task registration and execution methods, including its scheduling management and task discovery features.
thinking
**Considering SchedulerRegistry features**

I’m exploring potential improvements for SchedulerRegistry, like automatically registering WP-Cron hooks for tasks, and providing methods to schedule, unschedule, or reschedule tasks based on their default frequency. It might be useful to check if tasks are scheduled and find their next run times, or to integrate with Action Scheduler if available. However, the spec for Q08-01 doesn’t mention UI or settings, only focusing on WP-Cron task registration, schedule management, and task discovery. Currently, SchedulerRegistry simply stores tasks and runs them, lacking integration with WP Cron, which seems to have been overlooked.
thinking
**Reevaluating scheduling management**

I'm considering whether the schedule management, currently in SettingsServiceProvider, should be moved to the SchedulerRegistry. Implementing scheduling in the registry might require some interaction with settings, but we could create generic scheduling methods that accept hooks, frequency, and options, functioning with either WP Cron or Action Scheduler. These methods may not be in use yet, but the spec states they should be implemented. Proper hook registration might involve calling add_action for each task ID, which suggests that the registry should handle this task, improving design by linking tasks to their cron hooks during registration.
thinking
**Expanding scheduling methods**

I'm thinking about enhancing schedule management by adding methods for scheduling, unscheduling, and rescheduling tasks. It seems important to ensure that WP-Cron tasks can pass options to those tasks. The method `execute(string $task_id, array $options = array())` would allow executing tasks through the cron hook. To pass options, we could schedule events with an `$options` argument and modify the callback to accept it. For each task ID, the action callback signature would need to accommodate the options array, ensuring seamless integration with `wp_schedule_event`, which already accepts an `array $args`.
thinking
**Improving SchedulerRegistry functionality**

I’m considering adding methods for scheduling tasks and passing options to them via callbacks. Currently, the installation and settings providers schedule events without arguments, but I could define a callback that accepts an options parameter with a default empty array. 

For Action Scheduler, the function `as_schedule_recurring_action` can handle arguments, while we’ll ensure no duplicates when adding action hooks by checking with `has_action`. 

I should keep the per-task hooks for compatibility and implement dynamic schedule registration for custom frequencies. Additionally, there seems to be a bug with the GET_LOCK fallback not being implemented correctly, which could interfere with locking tasks. Lastly, I’ll improve transient key handling, possibly using md5 string hashing to avoid length issues.
thinking
**Examining WP-Cron task registration**

The specification clearly emphasizes "WP-Cron task registration" and "proper hook registration," which ties directly to `add_action` and possibly `register_activation_hook`. I think it's important to confirm whether these elements are correctly implemented within the SchedulerRegistry.

Next, I need to explore the tests for the scheduler to better understand the current implementation and ensure everything aligns with what's expected in the spec. I'll go search for those tests now!
exec
/bin/zsh -lc 'ls -la tests && rg -n "Scheduler" tests -S | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 43ms:
total 144
drwxr-xr-x@ 13 ahmedyounis  staff    416 Jan 16 08:17 .
drwxr-xr-x  55 ahmedyounis  staff   1760 Jan 16 09:09 ..
-rw-------@  1 ahmedyounis  staff  28309 Jan 16 22:57 bootstrap-standalone.php
-rw-------@  1 ahmedyounis  staff   2288 Jan  9 00:54 bootstrap.php
drwxr-xr-x@  5 ahmedyounis  staff    160 Jan  9 03:10 factories
drwxr-xr-x@  3 ahmedyounis  staff     96 Jan  9 03:10 integration
-rw-r--r--@  1 ahmedyounis  staff  19542 Jan  9 03:10 IntegrationTest.php
drwxr-xr-x@  4 ahmedyounis  staff    128 Jan 16 09:09 Mocks
-rw-------@  1 ahmedyounis  staff   4981 Jan 14 06:27 README.md
-rw-------@  1 ahmedyounis  staff   1087 Jan  9 00:54 StandaloneTestCase.php
-rw-------@  1 ahmedyounis  staff   4577 Jan  9 00:54 TestCase.php
drwxr-xr-x@  9 ahmedyounis  staff    288 Jan 16 08:00 unit
drwxr-xr-x@  8 ahmedyounis  staff    256 Jan 16 22:57 unit-standalone
tests/IntegrationTest.php:13:use WPAdminHealth\Scheduler;
tests/IntegrationTest.php:37:	 * Scheduler instance.
tests/IntegrationTest.php:39:	 * @var Scheduler
tests/IntegrationTest.php:315:		// Step 2: Verify WP-Cron events are scheduled (fallback when Action Scheduler not available).
tests/IntegrationTest.php:320:		// These should be scheduled or handled by Action Scheduler.
tests/IntegrationTest.php:321:		// In test environment without Action Scheduler, they should use WP-Cron.
exec
/bin/zsh -lc "sed -n '280,380p' tests/IntegrationTest.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
		update_option( 'wpha_settings', $settings );

		// Verify settings are updated.
		$updated_settings = $this->settings->get_settings();
		$this->assertFalse( $updated_settings['cleanup_revisions'], 'Cleanup revisions should be disabled' );

		// Step 5: Test safe mode setting.
		$settings['safe_mode'] = true;
		update_option( 'wpha_settings', $settings );

		$this->assertTrue( $this->settings->is_safe_mode_enabled(), 'Safe mode should be enabled' );

		// Disable safe mode.
		$settings['safe_mode'] = false;
		update_option( 'wpha_settings', $settings );

		$this->assertFalse( $this->settings->is_safe_mode_enabled(), 'Safe mode should be disabled' );
	}

	/**

thinking
**Investigating integration tests**

I’m looking into integration tests and noticing that they rely on the settings provider for scheduling tasks, rather than the registry. I should double-check our unit tests related to the scheduler registry. I think I’ll search in the tests/unit directory to find anything relevant. It’s important to make sure everything aligns properly! Let’s see what I can discover there.
exec
/bin/zsh -lc 'rg -n "SchedulerRegistry" tests/unit tests/unit-standalone -S | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:


thinking
**Considering schedule management in WordPress**

I think WordPress is a safe choice, but the specification mentions "schedule management." I wonder if I need to ensure that WP-Cron schedule intervals are set up properly, which is part of the settings provider. However, it might be worth registering those intervals too. The spec suggests that I review the scheduler registry for task management, which includes scheduling, unscheduling, and checking next runs. I'll have to check if there’s a "scheduler" service for running tasks in the background as well.
exec
/bin/zsh -lc "sed -n '1,180p' includes/REST/Media/MediaScanController.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 35ms:
<?php
/**
 * Media Scan REST Controller
 *
 * Handles media scanning operations.
 *
 * @package WPAdminHealth\REST\Media
 */

namespace WPAdminHealth\REST\Media;

use WP_REST_Request;
use WP_REST_Response;
use WP_Error;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\SettingsInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\REST\RestController;

// Exit if accessed directly.
exec
/bin/zsh -lc 'rg -n "scheduled tasks|wpha_database_cleanup|wpha_media_scan|wpha_performance_check" includes/REST -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 36ms:
includes/REST/Media/MediaScanController.php:100:			as_enqueue_async_action( 'wpha_media_scan', array(), 'wpha_media' );
includes/REST/MediaController.php:675:			as_enqueue_async_action( 'wpha_media_scan', array(), 'wpha_media' );



thinking
**Evaluating scheduler connection issues**

I think there might be a bug in the `register()` method regarding the `wpha_scheduler_task_registered` action. It seems like it should be used for auto-hooking tasks, but it doesn’t appear to be. I'm inspecting the `InstallerServiceProvider` to see if it sets the scheduler's connection. The `SchedulerRegistry` has a `set_connection` method that's not being called, which means it's relying on the global `$wpdb`. That could be a design oversight. Connecting via `ConnectionInterface` might be a crucial improvement.
thinking
**Inspecting connection setup in the scheduler**

I'm noticing the scheduler registry's constructor doesn't currently accept a connection, but it has a `set_connection` method. It seems like I could call that in the provider register by using the container to get the `ConnectionInterface`. The provider is loaded after the `ServicesServiceProvider`, which should have the connection available. But the closure in `SchedulerServiceProvider::register` doesn't directly receive the container. Although, because it uses `$this`, I can access `$this->container` within the closure — PHP automatically includes `$this` in closures. Now I just need to check how the container handles closures.
thinking
**Examining closure behavior in the container**

I'm considering whether the container passes itself when using closures. The existing bindings for tasks use `function($container)`, while the `SchedulerRegistry` closure uses `function() { return new SchedulerRegistry(); }`, which doesn't accept the container as a parameter. If the closure is set up to expect a parameter, the container might be passed automatically, but that’s not mandatory. It might be better to update the closure to accept `$container` and set the connection. I'll need to inspect the container's implementation in `includes/Container/Container.php` for clarity.
exec
/bin/zsh -lc "sed -n '1,220p' includes/Container/Container.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 44ms:
<?php
/**
 * Service Container
 *
 * PSR-11 compatible dependency injection container.
 *
 * @package WPAdminHealth\Container
 */

namespace WPAdminHealth\Container;

use ReflectionClass;
use ReflectionParameter;
use ReflectionNamedType;
use ReflectionException;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}
exec
/bin/zsh -lc "rg -n \"function resolve\\(\" -n includes/Container/Container.php && sed -n '220,340p' includes/Container/Container.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
302:	private function resolve( string $id ) {
		$this->providers[] = $provider;

		// Handle deferred providers.
		if ( $provider->is_deferred() ) {
			foreach ( $provider->provides() as $service ) {
				$this->deferred_providers[ $service ] = $provider;
			}
			return;
		}

		// Register the provider immediately with error handling.
		try {
			$provider->register();
		} catch ( \Throwable $e ) {
			$this->log_error(
				get_class( $provider ),
				sprintf( 'Registration failed: %s', $e->getMessage() )
			);
			throw ContainerException::provider_registration_failed( get_class( $provider ), $e );


thinking
**Evaluating PHP compatibility issues**

There are many sites running PHP 8.0 and above, indicating a potential bug. It's possible they set the minimum to 7.4 and haven’t updated for PHP 8, but newer WordPress versions should support PHP 8. The issue with SchedulerServiceProvider’s register method could break compatibility in PHP 8. The specification instructs a focus on the SchedulerRegistry for WP-Cron registration, but I found a bug in the binding closure. We really need to run tests to confirm everything works correctly.
thinking
**Checking testing framework**

Okay, the plugin uses both JavaScript and PHP, and I think npm test might be involved with Jest. I need to confirm that by looking at the package.json file. It should give me insight into the testing setup for the plugin. I want to make sure everything is correctly configured for both languages, so this step is necessary to understand how the testing works and what frameworks are being used. Let's check it out!
exec
/bin/zsh -lc 'cat package.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 43ms:
{
  "name": "wp-admin-health-suite",
  "version": "1.0.0",
  "description": "A comprehensive suite for monitoring and maintaining WordPress admin health and performance",
  "scripts": {
    "build": "webpack --mode production",
    "build:dev": "webpack --mode development",
    "watch": "webpack --mode development --watch",
    "dev": "webpack serve --mode development --open",
    "lint": "eslint assets/js --ext .js,.jsx",
    "lint:fix": "eslint assets/js --ext .js,.jsx --fix",
    "format": "prettier --write \"**/*.{js,jsx,json,css,scss,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,json,css,scss,md}\"",
    "test": "jest --passWithNoTests",
    "prepare": "husky"
  },
  "keywords": [
    "wordpress",
    "plugin",
    "health",

thinking
**Evaluating PHP testing process**

I noticed that running `npm test` executes Jest for JavaScript, not PHP, so any changes to PHP won’t be tested. There are PHP unit tests available, but they aren't included in the commands we're running. The specifications mention running lint and test commands, so we can proceed with those. We should ensure PHP code passes checks, even if it's not required. I also think the bug with closure is relevant and should be fixed, and we should consider checking other providers for binding closures as well.
exec
/bin/zsh -lc "rg -n \"singleton\\(\\s*["'^,]+,'"\\s*function\\s*\\(\\s*\\)\" includes -S" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 58ms:

exec
/bin/zsh -lc "rg -n \"->singleton\\(\\s*["'^,]+,'"\\s*function\\s*\\(\\s*\\)\" -S includes || true; rg -n \"->bind\\(\\s*["'^,]+,'"\\s*function\\s*\\(\\s*\\)\" -S includes || true" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 51ms:
rg: unrecognized flag ->
rg: unrecognized flag ->
exec
/bin/zsh -lc "rg -n -- \"->singleton\\(\" includes -S | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 49ms:
rg: -S: No such file or directory (os error 2)
includes/Container/ServiceProvider.php:136:		$this->container->singleton( $id, $resolver );
includes/Settings/SettingsServiceProvider.php:66:		$this->container->singleton(
includes/Providers/ServicesServiceProvider.php:55:		$this->container->singleton(
includes/Providers/ServicesServiceProvider.php:64:		$this->container->singleton(
includes/Providers/ServicesServiceProvider.php:74:		$this->container->singleton(
includes/Providers/MultisiteServiceProvider.php:44:		$this->container->singleton(
includes/Providers/BootstrapServiceProvider.php:57:		$this->container->singleton(
includes/Providers/BootstrapServiceProvider.php:69:		$this->container->singleton(
includes/Providers/BootstrapServiceProvider.php:81:		$this->container->singleton(
includes/Providers/BootstrapServiceProvider.php:92:		$this->container->singleton(
includes/Providers/DatabaseServiceProvider.php:73:		$this->container->singleton(
includes/Providers/DatabaseServiceProvider.php:105:		$this->container->singleton(
includes/Providers/DatabaseServiceProvider.php:116:		$this->container->singleton(
includes/Providers/DatabaseServiceProvider.php:127:		$this->container->singleton(
includes/Providers/DatabaseServiceProvider.php:138:		$this->container->singleton(
includes/Providers/DatabaseServiceProvider.php:149:		$this->container->singleton(
includes/Providers/IntegrationServiceProvider.php:53:		$this->container->singleton(
includes/Providers/MediaServiceProvider.php:72:		$this->container->singleton(
includes/Providers/MediaServiceProvider.php:83:		$this->container->singleton(

thinking
**Correcting file command**

I made an error by including -S as a file in my command. The correct way is `rg -n -S -- "pattern"`. I had mistakenly written `rg -n -- ... includes -S`, which treated -S as a file at the end. Moving on, I want to inspect some providers now to check if they use function closures. I'll search for "function ()" in the includes/Providers directory using `rg -n -- \"function \\(\\s*\\)\"`.
exec
/bin/zsh -lc "rg -n -- \"function \\(\\s*\\)\" includes/Providers includes/Settings/SettingsServiceProvider.php -S | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 55ms:
rg: -S: No such file or directory (os error 2)
includes/Settings/SettingsServiceProvider.php:68:			function () {
includes/Settings/SettingsServiceProvider.php:90:			function () {
includes/Settings/SettingsServiceProvider.php:97:			function () {
includes/Settings/SettingsServiceProvider.php:104:			function () {
includes/Settings/SettingsServiceProvider.php:111:			function () {
includes/Settings/SettingsServiceProvider.php:118:			function () {
includes/Settings/SettingsServiceProvider.php:125:			function () {
includes/Settings/SettingsServiceProvider.php:344:				function () use ( $section ) {
includes/Providers/ServicesServiceProvider.php:57:			function () {
includes/Providers/DatabaseServiceProvider.php:75:			function () {
includes/Providers/MultisiteServiceProvider.php:46:			function () {
includes/Providers/IntegrationServiceProvider.php:55:			function () {
includes/Providers/CoreServiceProvider.php:54:			function () {
includes/Providers/SchedulerServiceProvider.php:66:			function () {







thinking
**Exploring cron schedule registration**

I'm considering how to register cron schedules, possibly using the filter 'cron_schedules.' I think providing a method like `register_cron_schedules` to return a schedules array could work. The SchedulerServiceProvider or SettingsServiceProvider might hook into this, but I should double-check proper hook registration. Instead of hard-coding tasks, maybe a loop over the registry to dynamically register hooks would be a better solution. I'll also look into how Action Scheduler manages this, as it applies specific hooks and callbacks.
thinking
**Considering scheduler registry issues**

It seems like the user wants the scheduler registry to support custom WP Cron schedule names like 'weekly' and 'monthly,' which currently isn't included. I'm thinking about potential issues with the SchedulerRegistry's locking mechanism. 

Acquire_lock uses GET_LOCK combined with a name based on the task ID, which is good. However, if there's a connection failure when releasing the lock, the transient might be deleted but the lock could still exist in MySQL. 

I’m also concerned that not all databases support MySQL locks, which could cause tasks to skip if not handled correctly.
thinking
**Planning fallback mechanisms**

I'm thinking it could be smart to implement a fallback if GET_LOCK returns null. My first thought is to try using transients with atomic `add_option`, though transients aren't atomic. I might consider using `wp_cache_add` instead, which can be atomic in an object cache like Memcached.

Another option is to use `add_option` with a unique key that isn’t autoloaded. However, the specs don’t really mention locking, but I realize that schedule management often involves preventing concurrent execution. I should confirm proper hook registration for `wpha_scheduler_tasks_registered` as part of this process.
thinking
**Addressing WordPress hooks and scheduling**

I’m noticing possible gaps in WordPress hooks for running tasks, especially for schedule management and task discovery. I think we should improve the scheduler registry by ensuring a clear mapping between task IDs and cron hooks, and registering cron hook callbacks for all tasks to allow WP-Cron and Action Scheduler to trigger them effectively.

Additionally, we need methods for scheduling, unscheduling, and rescheduling, along with discovery methods like `get_task_definitions`. We can update the SchedulerServiceProvider to delegate to the registry instead of hard-coded registrations, and introduce a new method for task hook names for consistency across built-in tasks.
thinking
**Optimizing schedule management in WordPress**

I'm identifying potential improvements for schedule management and task discovery in the WordPress system. It seems important to support dynamic schedule management within the registry using task definitions, although there aren't settings for custom tasks yet. 

I could add methods for syncing schedules and improve the SettingsServiceProvider by looping over tasks to manage scheduling effectively based on existing frequency keys. However, given some methods exist in the SettingsServiceProvider, we might want to centralize schedule management in the SchedulerRegistry. 

By standardizing how we name hooks and utilize task IDs, we can help eliminate duplication in logic, aiming for a more streamlined system overall.
thinking
**Improving schedule management in WordPress**

I’m looking into how the Installer’s schedule_single_task function uses `as_schedule_recurring_action`, but it doesn’t unschedule tasks properly. The SettingsProvider is better at scheduling and unscheduling, so updating the Installer to use the SchedulerRegistry’s methods could help. 

Creating a new `Scheduler` or `TaskScheduler` class for managing schedules and hook registration might be beneficial while keeping the registry focused on tasks. I need to ensure proper task registration, scheduling, and discovery. Additionally, I’ll extend the SchedulerRegistry to provide mappings, register WP action hooks, and implement schedule management functions. This will keep things organized and avoid redundancy while adhering to the spec's requirements.
thinking
**Implementing schedule management updates**

I realize that WP Cron's `wp_get_schedule` function can help. For Action Scheduler, while `as_get_scheduled_actions` might feel heavy, focusing on the next scheduled task could be simpler. I’m considering a method like `get_scheduled_task_details()` to return the next run for tasks, though it might not be necessary. I want to ensure proper hook registration in the SchedulerServiceProvider, possibly removing redundant hooks to prevent duplicate task executions. Backward compatibility is important too, so keeping certain methods while updating others makes sense. Next, I plan to inspect the current implementation more closely before making necessary changes and improvements.
Plan update
  ✓ Read spec and handoff
  → Inspect current implementation
  • Implement required changes
  • Run lint and tests
  • Summarize and hand off

thinking
**Reviewing scheduling methods**

I’m considering the scheduler registry and whether scheduling methods might be called before the filter, which could lead to failures. However, it's typically triggered during settings updates after the filter is added, so that’s a relief. If we decide to move scheduling to the registry, we might want to add a filter there too to be safe. Anyway, it's time to inspect tasks for potential improvements and push forward with our implementation plans.
Plan update
  ✓ Read spec and handoff
  ✓ Inspect current implementation
  → Implement required changes
  • Run lint and tests
  • Summarize and hand off








thinking
**Considering task hooks**

I’m thinking about allowing tasks to define their own hooks that don’t start with "wpha_". It could be useful, but maybe it’s not essential. I also like the idea of letting users customize the prefix using a filter, like `apply_filters('wpha_scheduler_task_hook', 'wpha_'.$task_id, $task_id)`. That sounds nice for personalization, but I’m weighing whether it’s truly necessary in the long run.
thinking
**Exploring task hook registration**

I'm considering how to properly register hooks. It might be good to use a filter for that. I could add a method, `handle_task_hook`, which determines the hook and task ID based on the current filter. But what if the task isn’t registered yet? The callback only exists if the task is registered, and if it gets unregistered, there might be issues. It could trigger a hook without a task in the registry. I need to set tasks in the registration process and ensure everything is executed correctly.
thinking
**Structuring schedule management**

I’m planning to add methods for managing schedules, like `schedule_task`, which could take parameters such as task ID, frequency, next run time, and options. It’s important to use a hook name from `get_task_hook` and ensure that the hook is registered before scheduling. I realize that even though `schedule_task` might work without registration, it may be wise to verify that the task hook is registered anyway. If it’s in the registry, I can call it directly, but I need to consider if tasks are enabled during scheduling.
thinking
**Detailing task scheduling implementation**

I’m outlining the implementation for `schedule_task`. The method will first check if the frequency is set to 'disabled' and call `unschedule_task` if it is. Then, it retrieves the task hook and the interval based on the frequency. It's essential to register the task hook to ensure the callback works correctly. 

Also, if the necessary functions exist, I’ll use `as_schedule_recurring_action` for recurring scheduling; otherwise, I’ll default to `wp_schedule_event`. I note that when using WP Cron, options should be passed as an array, which aligns with our hook's expected parameters.
thinking
**Refining scheduling architecture**

I’m working on how `schedule_task` operates within the settings provider. Currently, it’s set to schedule hooks without passing arguments, which is fine since our callback has a default empty array. However, if we want to start passing arguments, previous tasks will still run correctly. I’m considering how Action Scheduler needs arguments for recurring actions and what happens if we pass options. 

It seems best to keep the schedule management tied to hooks only, avoiding added complexity with arguments. This way, I can simplify `schedule_task` and even integrate it into the settings provider without duplicating functionality. Still, I’m cautious about managing dependencies while ensuring smooth operation across all components.
thinking
**Refining provider interactions**

In the plugin's `register_providers`, the order matters since `SettingsServiceProvider` runs before `SchedulerServiceProvider`. If `handle_scheduling_update` needs the registry, I’ll adjust it to access the registry after booting. While `schedule_task` methods are private in `SettingsServiceProvider`, I may need to reconsider their usage or keep them for potential future needs.

In terms of scheduling logic, we could consolidate how tasks are managed, possibly moving some responsibility to the registry. I also see room for creating tests, although running PHP tests might be tricky with the current setup. Still, I plan to implement modifications in relevant files, focusing on maintaining central task management while ensuring compatibility with existing components.
thinking
**Integrating schedule management**

It seems that "schedule management" should be integrated into the registry for easier functionality. I could change the `SettingsServiceProvider` to use the registry's schedule management instead of keeping the private methods. This would involve creating methods in the registry that accept both hooks and task IDs. To keep existing logic, I can delegate the current scheduling functions so that they continue to work while creating a more streamlined process.

The focus will be on ensuring that the tasks get scheduled correctly with either Action Scheduler or WP Cron. I'll keep in mind that the settings provider uses hooks, but I may also need to accommodate task_ids. This refactor will maintain compatibility with the existing functionality while meeting our scheduling requirements.
thinking
**Reviewing interface usage**

I’m thinking about how I can type-hint the interface variable. I can retrieve it using `$registry = $this->container->get(SchedulerRegistryInterface::class)`, which is neat since PHP doesn’t enforce method existence at runtime. However, if I want to ensure all methods are implemented correctly, extending the interface to include schedule management might help.

I need to check where `SchedulerRegistryInterface` is used elsewhere, especially in the tests and mocks. If I modify the interface, it may require updates to any tests or mocks related to it, but that’s manageable for a good design.
exec
/bin/zsh -lc 'rg -n "SchedulerRegistryInterface" tests includes -S | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 55ms:
includes/Scheduler/SchedulerRegistry.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
includes/Scheduler/SchedulerRegistry.php:28:class SchedulerRegistry implements SchedulerRegistryInterface {
includes/Providers/SchedulerServiceProvider.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
includes/Providers/SchedulerServiceProvider.php:52:		SchedulerRegistryInterface::class,
includes/Providers/SchedulerServiceProvider.php:65:			SchedulerRegistryInterface::class,
includes/Providers/SchedulerServiceProvider.php:70:		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
includes/Providers/SchedulerServiceProvider.php:141:		$registry = $this->container->get( SchedulerRegistryInterface::class );
includes/Providers/SchedulerServiceProvider.php:166:		 * @param SchedulerRegistryInterface $registry The scheduler registry.
includes/Providers/SchedulerServiceProvider.php:194:		$registry = $this->container->get( SchedulerRegistryInterface::class );
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:18: * Interface SchedulerRegistryInterface
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:24:interface SchedulerRegistryInterface {
includes/Scheduler/Traits/HasScheduledTasks.php:13:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
includes/Scheduler/Traits/HasScheduledTasks.php:48:		if ( ! $this->container->has( SchedulerRegistryInterface::class ) ) {
includes/Scheduler/Traits/HasScheduledTasks.php:52:		$registry = $this->container->get( SchedulerRegistryInterface::class );








thinking
**Evaluating task management strategy**

I’m thinking about how to implement hook registration and task discovery methods in the registry without changing the settings provider's scheduling logic. This might meet the specifications partially, but the "schedule management" aspect still wouldn't be included in the registry. However, it could be there for internal use. Since the review tasks list implies they want specific improvements, for Q08-01, I think I should focus on the scheduler registry class rather than the interface. Schedule management might involve handling task scheduling states, potentially using `wp_next_scheduled` for that purpose.
thinking
**Considering registry implementation**

I'm thinking about how to implement functions within the registry. They might not be used right now, but if I add schedule methods in the registry and they aren't used, do they still count as implemented? It seems tricky. Since the tasks are internal, they probably want code improvements, but I need to be careful about conflicts with other review tasks. The user specifically asked for Q08-01. I’ll add schedule management methods to the registry without touching the interface for now, but I might consider some minimal updates later.
thinking
**Assessing code quality issues**

I need to think about code quality, especially with many service provider singleton closures missing the $container parameter. While that might not be my primary focus, adjusting the scheduler provider to accept this parameter would ensure consistency. However, if the rest of the closures remain without parameters, that could create issues with PHP 8. I have to remember that fixing only the scheduler provider may not address the larger problem, as many closures would still fail under PHP 8. It’s complex!
thinking
**Planning modifications for task discovery**

I’m considering that, even on PHP 7.4, those closures produce warnings, though they might be suppressed in production. I think the `container->resolve` does pass the container argument, which is important to note. The spec didn’t mention PHP 8 or the container, so I’ll focus on crafting modifications. 

For "task discovery," I see a way to enhance it by adding methods like `get_task_ids()` or `get_task_hooks()`, but I might just add `get_cron_hook_name` instead. I want to ensure proper hook registration and consider using a static closure for `array_filter`, but that might not be necessary. Now, I’ll implement these modifications in `SchedulerRegistry.php`.
thinking
**Designing modifications and locking strategy**

I’m outlining several additions, like creating a constant `TASK_HOOK_PREFIX` and private arrays for registered task hooks. I’ll introduce methods for task management, including getting and registering task hooks. For scheduling, I’ll also add methods to schedule and unschedule tasks. 

However, I need to be cautious about naming conflicts with existing functions. Regarding locking, I'll implement a fallback mechanism using transients to prevent tasks from getting stuck. This involves checking the availability of MySQL locks and falling back to transient locks when necessary, while ensuring to check for expiration based on timestamps.
thinking
**Planning locking mechanisms and scheduling**

I want to improve the approach by using MD5 to shorten keys for locks. Given it’s crucial for WP Cron task registration, schedule management, and task discovery, I'm focusing on implementing a proper fallback for locks. I’ll ensure consistency by using `self::LOCK_PREFIX . md5($task_id)` for keys, which will simplify the naming process and avoid conflicts. 

For the lock acquisition, I’ll set up procedures using MySQL, and if that fails, I’ll fall back on options. I’ll also implement methods for managing scheduled tasks and ensure hooks are registered correctly to prevent duplicates. Overall, it seems like an important structural improvement to enhance functionality.
thinking
**Implementing task registration and hooks**

I'm looking to implement a private method called `ensure_task_hook_registered` to ensure our task hooks are properly set up. In the `register` method, I’ll call this to register individual task hooks. I'll also add a public method to register all task hooks based on an array of tasks, which helps avoid duplication.

As for the hook naming, instead of sanitizing the task IDs during hook registration, I'll just convert the IDs to strings, keeping them intact. This is to prevent any unnecessary modifications that could lead to mismatches. 

To ensure valid hooks, I’ll think about applying some filters, allowing customization while keeping the original task IDs for execution. This feels like a structured approach to keep everything organized!
thinking
**Implementing task discovery and scheduling**

To improve task discovery, I’m adding a `get_task_hook` method and a `handle_task_hook` callback. I’ll also create a mapping between hooks and task IDs for better reliability. If a hook name is filtered, parsing the task ID could be tricky, but maintaining this mapping helps.

I need to adjust the SchedulerServiceProvider to remove hard-coded `add_action` hooks for each task and only register the generic `wpha_execute_registered_task` hook. I'll also modify `execute_registered_task` to allow mixed types for `$task_id` and sanitize it within the method for robustness. Additionally, I’ll update scheduling methods to utilize the registry.
exec
/bin/zsh -lc "sed -n '1,80p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
<?php
/**
 * Settings Service Provider
 *
 * Registers settings-related services.
 *
 * @package WPAdminHealth\Settings
 */

namespace WPAdminHealth\Settings;

use WPAdminHealth\Container\ServiceProvider;
use WPAdminHealth\Contracts\SettingsInterface;
use WPAdminHealth\HealthCalculator;
use WPAdminHealth\Settings\Contracts\SettingsRegistryInterface;
use WPAdminHealth\Settings\Domain\CoreSettings;
use WPAdminHealth\Settings\Domain\DatabaseSettings;
use WPAdminHealth\Settings\Domain\MediaSettings;
use WPAdminHealth\Settings\Domain\PerformanceSettings;
use WPAdminHealth\Settings\Domain\SchedulingSettings;









thinking
**Clarifying class existence checks**

I’m recalling that the `class_exists` function returns true for defined classes and interfaces, but I wonder if `class_exists` checks interfaces. Actually, it seems it should. When calling `class_exists('Iterator')`, it returns true since Iterator is an interface. This can lead to issues with `container->has`, returning true even if there’s no binding. However, the SettingsServiceProvider does bind it. For more robustness, I’m considering checking `$this->container->bindings[$id]`, but it may not be accessible.
thinking
**Considering scheduling management**

I’m thinking about calling `get` and handling the `NotFound` exception. The `container->get` method for an interface will auto-wire and could fail, but since it's bound, it should be fine. To avoid issues, I can just call `container->get` and rely on binding. In `handle_scheduling_update`, I want to schedule tasks using the scheduler registry methods, and while we may not implement everything in the interface, making optional schedule/unschedule methods in the registry could work. To keep things stable, I could maintain scheduling management in the settings provider. However, to satisfy the registry requirements, I might need to update the settings provider to call the appropriate methods in the registry. I’m also pondering if I should add this to the interface or if I could call it on a concrete type instead, knowing PHP's dynamic nature means it may not strictly matter at runtime, though it could be seen as a type violation.
thinking
**Analyzing type hinting in PHP**

I’m wondering about type hinting in PHP. If I type-hint a variable as `SchedulerRegistryInterface` and the method isn’t defined, will it cause a fatal error? It seems calling an undefined method on an object leads to a fatal error, but if the method is available in the object class, the interface doesn’t affect it. PHP doesn’t check static types at runtime, but if declared with `SchedulerRegistryInterface`, could this lead to issues? There's no strict variable typing, though I can annotate with phpdoc, which might be flagged by tools like phpstan. Existing code might use phpdoc, so it’s manageable. A good design could involve updating the interface, but given that "Scheduler Contracts Review" relates to Q08-03, they might address that later. Changes in schedule management may not necessitate interface updates if the settings provider remains unchanged, but the spec could still require it.
thinking
**Interpreting schedule management**

I’m thinking about how schedule management might fit into the scheduler registry without being directly exposed. The registry holds tasks, manages locks, and executes tasks, which is all in place. They mention WP-Cron tasks, so I’m considering the responsibilities of the scheduler registry: registering tasks, managing scheduling (including locks), and executing tasks. The only missing piece could be linking tasks to WP Cron. Task discovery via `get_task_definitions` exists, but perhaps it should be included in the interface. If the scheduler service provider is absent, tasks like 'wpha_database_cleanup' won't execute, but they are still registered.
thinking
**Reviewing scheduler registry for integration**

They want to review the scheduler registry for hook registration, perhaps to confirm tasks register their hooks correctly. The spec is a bit vague, but it makes sense to implement improvements. I’ll focus on ensuring task hooks are registered in the registry and modify the scheduler service provider to eliminate hard-coded hooks. For schedule management, adding wrapper methods to the registry seems necessary, even if they're not used immediately. We could also adapt the SettingsServiceProvider to utilize these scheduling methods for minimal disruption, ensuring that the integration is effective while keeping the existing methods for compatibility.
thinking
**Implementing scheduling changes**

If we move schedule logic to the registry, the settings provider can simply call `registry->schedule_hook($hook,...)`. The frequency logic can be kept or adjusted. I need to consider `calculate_next_run_time`, used in `handle_scheduling_update` for computing the next run. It might not need to move to the registry, but I’ll keep working on unscheduling tasks and ensure method wrappers in the registry are in place.

For the new methods, I'll create `schedule_hook`, `unschedule_hook`, and `get_next_run_for_hook` in the registry. It seems sensible to accept the `task_id`, aligning the scheduling processes. I can implement both scheduling methods by hook and task ID.

In the `SettingsServiceProvider`, I’ll update the task list accordingly and ensure methods like `schedule_task` use the new registry functions while still retaining the current logic for cron schedules.

It’s essential now to ensure minimal changes while maintaining clarity and consistency within the scheduling logic. I’m almost ready to draft the patch to implement these modifications properly!
thinking
**Adding constants and task management methods**

I'm about to implement some constants for the task management system, specifically a default hook prefix for tasks and a default group for recurring tasks. Following the existing style, I'll mimic the docblock format utilized in the code. 

Next, I’ll add properties that map hooks to task IDs and register task hooks using the specified prefix. I’ll ensure a robust implementation by handling task execution properly and managing any unexpected argument types. 

The new scheduling methods will include scheduling and unscheduling tasks and retrieving their run times. I'll also add helper methods for converting frequencies to time intervals, all while ensuring compatibility with existing WordPress functions. This should make for a seamless integration!
thinking
**Implementing task management methods**

I'm adding the `unschedule_task` method, where I'll clear scheduled tasks based on their task ID and group. The `get_next_run` method will also be implemented, returning the next scheduled time for a task, but I need to confirm the return type. Since PHP 7.4 doesn't support union types, I’ll use `?int` for returning the next run or null.

I’m considering adding a method for discovering task statuses, but I think enhancing the existing definitions to include hooks and next run times will suffice. Additionally, ensuring that weekly/monthly cron schedules are registered adds robustness. I want to make this as self-contained as possible while sticking to the existing framework.
thinking
**Updating task management functions**

I’m planning to update the lock handling by changing to `delete_transient($lock_key)` and perhaps using `delete_option($lock_key)`. Next, I’ll look into updating the `SchedulerServiceProvider` and possibly the settings provider if they’re using any scheduling methods. To minimize changes, I might skip updates to the settings provider for now. 

However, I think enhancing `get_task_definitions` to include scheduling information is beneficial. Since the schedule management methods will be useful moving forward, I'll proceed to patch everything accordingly.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/SchedulerRegistry.php
@@ -44,2 +44,22 @@
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
@@ -51,2 +71,9 @@
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
@@ -62,4 +89,8 @@
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
@@ -78,2 +109,12 @@
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
@@ -213,2 +254,51 @@
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
@@ -216,3 +306,3 @@
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
@@ -226,2 +316,3 @@
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
@@ -243,9 +334,10 @@
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
@@ -253,2 +345,28 @@
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
@@ -267,2 +385,3 @@
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
@@ -283,3 +402,6 @@
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
@@ -319,2 +441,4 @@
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
@@ -325,2 +449,103 @@
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M includes/Scheduler/SchedulerRegistry.php
file update:
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

file update:
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Updating Scheduler methods**

I’ve updated the SchedulerRegistry to include new methods and a lock fallback. I want to be careful about ensuring there are no trailing spaces. We added functions like schedule_task, unschedule_task, and get_next_run. Also, we modified get_task_definitions to call get_next_run for each task, which might involve heavier WP functions. Now, I need to revise the SchedulerServiceProvider to eliminate hook duplication and utilize the new scheduling methods, possibly removing any hard-coded actions. Time to patch things up!
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Providers/SchedulerServiceProvider.php
@@ -65,4 +65,11 @@
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
@@ -176,9 +183,4 @@
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
@@ -192,3 +194,9 @@
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M includes/Providers/SchedulerServiceProvider.php
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }






thinking
**Evaluating MySQL Lock Mechanism**

I'm considering the behavior of acquiring a lock in MySQL. If `GET_LOCK` returns null but the lock is already held, it could still yield a result of 0 rather than null. I can treat a null result as a fallback, but I need to ensure that query errors are handled since `$wpdb->get_var` returns null on an error, which is crucial for my logic.

When calling `add_option`, if the lock is active, the result should be 0, and we should return false without falling back. If `GET_LOCK` returns null for both processes, they could both try to execute `add_option`, but since it's atomic, only one will succeed, which is good.

However, we haven't implemented TTL for the option-based lock, just a check for stale tasks using `started_at`. Now, I need to consider the schedule management methods like `schedule_task` and `unschedule_task`, but I need to ensure that `as_unschedule_all_actions` and `as_schedule_recurring_action` are available at runtime with proper checks.
thinking
**Reviewing Task Definitions**

I'm diving into `get_task_definitions`, which now includes `next_run` that calls `$this->get_next_run`. It checks if `as_next_scheduled_action` exists, but that requires the Action Scheduler to be loaded. On sites without it, WP Cron will fallback to `wp_next_scheduled`.

Even if WordPress is loaded, `get_task_definitions` might still run too early. I want to ensure it doesn't have unintended side effects since it calls `get_next_run` for each task. However, these methods might invoke WordPress functions that don't exist in the CLI context. Thankfully, plugin files start with a check for `ABSPATH`, ensuring they're not misused outside of WordPress. That feels safe. I'll need to consider updating some tests and ensure task discovery specs are improved. Good!
thinking
**Optimizing Hook Registration**

I need to ensure proper hook registration and consider removing any unused generic registrations still in the scheduler provider. The `SchedulerRegistry` maps hooks to task IDs by their names. If a hook is triggered that isn't mapped, it falls back to parsing, allowing task execution even if the hook isn't registered. 

However, there's a potential issue with `wpha_execute_registered_task`, as it may yield a name that doesn't exist, leading to null if tasks aren't found. Since `handle_task_hook` isn't hooked to that, I'm okay there. 

I also consider whether tasks would need different hook names, but probably not. Maybe it’s time to run lint and tests with npm.
thinking
**Ensuring Task Management Integrity**

I want to make sure the code passes PHP syntax checks, but that’s not the main focus right now. Step 3 of my plan is still in progress as I've implemented changes. I might need to modify parts of the code that use `wpha_execute_registered_task`. 

I should check for other instances where tasks might be hooked to cron, but I've already removed duplicates in `SchedulerServiceProvider`. However, other controllers could still trigger `do_action('wpha_media_scan')`. The registry will handle this, as long as tasks are registered after plugin initialization.

If Action Scheduler is available, it will enqueue an async action for `wpha_media_scan`, ensuring the appropriate tasks run once everything is loaded. Good!
thinking
**Refining the Scheduler Registry**

The scheduling group is distinct since our registry's methods operate under the `wpha_scheduling` group, which is intended for recurring tasks. The `SchedulerRegistry::register_task_hook` checks for duplicates using `has_action`, but that only returns false if the callback isn't registered. 

If another piece of code registers the same hook with a different priority, `has_action` will return that priority, allowing us to skip it. If tasks register again with the same ID but different task objects, the tasks array updates, while the hook still points to `handle_task_hook`. 

I’ve added private methods like `get_interval_seconds` and `get_cron_schedule_name`, though similar methods exist in `SettingsServiceProvider`, causing duplication, but that's okay. Next, I need to ensure the file ends with a closing newline. 

Plan step 3 involves verifying that schedule management methods compile, so I’ll run `php -l` on modified files to check syntax, which doesn't require approval, and since I can run it in sandbox mode, let's proceed with that. I'll also look into running npm commands after checking that the necessary Node modules are already present. We should execute `php -l` for the `SchedulerRegistry.php` and `SchedulerServiceProvider.php` files.
exec
/bin/zsh -lc 'php -l includes/Scheduler/SchedulerRegistry.php && php -l includes/Providers/SchedulerServiceProvider.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 158ms:
No syntax errors detected in includes/Scheduler/SchedulerRegistry.php
No syntax errors detected in includes/Providers/SchedulerServiceProvider.php
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Preparing to run tests**

I need to make sure everything's set up correctly. First, I'll confirm that the package dependencies are installed by checking if the node_modules directory exists. If it does, I can move on to running `npm lint` and then the tests. Getting this step right is important because I want to avoid any issues later on. Let’s make sure everything is lined up before diving into the commands!
exec
/bin/zsh -lc 'npm run lint' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.46s:

> wp-admin-health-suite@1.0.0 lint
> eslint assets/js --ext .js,.jsx


/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/admin.js
    7:1  warning  Missing JSDoc @param "window" type    jsdoc/require-param-type
    8:1  warning  Missing JSDoc @param "$" type         jsdoc/require-param-type
  276:1  warning  Missing JSDoc @param "message" type   jsdoc/require-param-type
  277:1  warning  Missing JSDoc @param "duration" type  jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/charts.js
  7:1  warning  Missing JSDoc @param "window" type  jsdoc/require-param-type
  8:1  warning  Missing JSDoc @param "$" type       jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/HealthScoreCircle.jsx
  31:30  warning  'score' is missing in props validation    react/prop-types
  31:41  warning  'grade' is missing in props validation    react/prop-types
  31:54  warning  'loading' is missing in props validation  react/prop-types
  57:1   warning  Missing JSDoc @param "timestamp" type     jsdoc/require-param-type
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Checking lint and running tests**

I successfully ran `npm run lint`, and it exited with code 0, which is good, but there were some warnings. That's alright; I can handle warnings. Now, I need to move on and run `npm test` to make sure everything is working as expected. I'll keep an eye out for any issues that might pop up during the tests. Let's see what happens!
exec
/bin/zsh -lc 'npm test' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.09s:

> wp-admin-health-suite@1.0.0 test
> jest --passWithNoTests

PASS assets/js/components/QuickActions.test.jsx
PASS assets/js/components/ActivityTimeline.test.jsx
  ● Console

    console.error
      Warning: An update to ActivityTimeline inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at ActivityTimeline (/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/ActivityTimeline.jsx:108:46)
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Updating test plan**

The npm test passed, which is good, even though there are some console.error warnings. Still, the exit code is 0, so that means no issues were encountered. Now, I need to move on to step 4, which is to run lint/test. After completing that, I can summarize the progress. Actually, it seems that step 3 for implementing required changes may now be complete, so I'll adjust the plan to reflect that.
Plan update
  ✓ Read spec and handoff
  ✓ Inspect current implementation
  ✓ Implement required changes
  ✓ Run lint and tests
  → Summarize and hand off
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Preparing final response**

I need to craft the final response with the required format, including a status update (DONE or NEEDS-REVIEW), a summary of changes, details on how to verify with exact commands, and mentioning any risks or follow-ups. Before finalizing, it’s essential to review the modifications to avoid any mistakes. I’ll quickly inspect the modified files to ensure proper formatting and check for any missing documentation comments. Time to open the relevant sections!
exec
/bin/zsh -lc "sed -n '1,220p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 56ms:
<?php
/**
 * Scheduler Registry
 *
 * Manages registration and execution of schedulable tasks.
 *
 * @package WPAdminHealth\Scheduler
 */

namespace WPAdminHealth\Scheduler;

use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

exec
/bin/zsh -lc "sed -n '220,520p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 32ms:
			 * @hook wpha_scheduler_task_failed
			 *
			 * @param SchedulableInterface $task      The task that failed.
			 * @param \Throwable           $exception The exception that was thrown.
			 * @param array                $options   Task options.
			 */
			do_action( 'wpha_scheduler_task_failed', $task, $e, $options );

			return array(
				'success' => false,
				'error'   => $e->getMessage(),
				'task_id' => $task_id,
			);
		}

		// Release lock after successful execution.
		$this->release_lock( $task_id );

		/**
		 * Fires after a scheduled task executes.
exec
/bin/zsh -lc "sed -n '1,260p' includes/Providers/SchedulerServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * Scheduler Service Provider
 *
 * Registers the Scheduler service and task registry.
 *
 * @package WPAdminHealth\Providers
 */

namespace WPAdminHealth\Providers;

use WPAdminHealth\Container\ServiceProvider;
use WPAdminHealth\Scheduler\SchedulerRegistry;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
use WPAdminHealth\Database\Tasks\DatabaseCleanupTask;
use WPAdminHealth\Media\Tasks\MediaScanTask;
use WPAdminHealth\Performance\Tasks\PerformanceCheckTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..191653398bbb374bd65f02e38b16fe13b5061649
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id               = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Patching code style**

I see a small code style issue in the `register()` method of `SchedulerRegistry`. The alignment of `$task_id               = ...` has extra spaces, which seems like a leftover. While it’s okay, I think it would be clearer to adjust it to one space for better code quality according to PHP standards. 

Also, we could use `$task_id` instead of calling `$task->get_task_id()` for clarity, but it’s not necessary. I'll apply a quick patch to remove the extra spaces.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/SchedulerRegistry.php
@@ -89,3 +89,3 @@
 	public function register( SchedulableInterface $task ): void {
-		$task_id               = $task->get_task_id();
+		$task_id = $task->get_task_id();
 		$this->tasks[ $task_id ] = $task;
apply_patch(auto_approved=true) exited 0 in 57ms:
Success. Updated the following files:
M includes/Scheduler/SchedulerRegistry.php
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

exec
/bin/zsh -lc 'php -l includes/Scheduler/SchedulerRegistry.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 96ms:
No syntax errors detected in includes/Scheduler/SchedulerRegistry.php
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }


thinking
**Summarizing steps**

There's no change needed right now. We already ran npm lint/test, but since we only made changes to the PHP file, there's no requirement to rerun it. However, it might be a good idea to keep that in mind. It’s all good! Now, I’ll focus on summarizing step 5 and update the plan to reflect that it’s completed.
Plan update
  ✓ Read spec and handoff
  ✓ Inspect current implementation
  ✓ Implement required changes
  ✓ Run lint and tests
  ✓ Summarize and hand off
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

exec
/bin/zsh -lc "rg -n \"get_task_hook\\(|handle_task_hook\\(|schedule_task\\(|unschedule_task\\(|get_next_run\\(\" includes/Scheduler/SchedulerRegistry.php && rg -n \"setup_cron_hooks\\(|execute_registered_task\\(\" includes/Providers/SchedulerServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
115:	public function get_task_hook( string $task_id ): string {
263:	public function handle_task_hook( $options = array() ): void {
292:		$hook = $this->get_task_hook( $task_id );
442:				'hook'              => $this->get_task_hook( $task->get_task_id() ),
443:				'next_run'          => $this->get_next_run( $task->get_task_id() ),
460:	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
461:		$hook = $this->get_task_hook( $task_id );
464:			$this->unschedule_task( $task_id, $group );
491:	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
492:		$hook = $this->get_task_hook( $task_id );
508:	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
509:		$hook = $this->get_task_hook( $task_id );
139:		$this->setup_cron_hooks();
183:	private function setup_cron_hooks(): void {
195:	public function execute_registered_task( $task_id = '', $options = array() ): void {
212:		$this->execute_registered_task( 'database_cleanup' );
221:		$this->execute_registered_task( 'media_scan' );
230:		$this->execute_registered_task( 'performance_check' );
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

exec
/bin/zsh -lc "rg -n \"acquire_lock\\(|option-based lock|LOCK_PREFIX\" includes/Scheduler/SchedulerRegistry.php | head" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
42:	const LOCK_PREFIX = 'wpha_task_lock_';
175:		if ( ! $this->acquire_lock( $task_id ) ) {
307:	 * Falls back to an option-based lock if GET_LOCK is unavailable.
315:	private function acquire_lock( string $task_id ): bool {
317:		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
346:		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
386:		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
405:		// Clean up option-based lock fallback (if used).
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

codex
Status: DONE

Summary of changes
- Auto-register WP-Cron/Action Scheduler hooks per task on registry registration (so any registered task can be executed via `wpha_{task_id}`) in `includes/Scheduler/SchedulerRegistry.php:263`.
- Added schedule management + discovery helpers to the registry (`get_task_hook`, `schedule_task`, `unschedule_task`, `get_next_run`) in `includes/Scheduler/SchedulerRegistry.php:115`.
- Added an option-based lock fallback when MySQL `GET_LOCK()` is unavailable, and switched lock keys to a stable `md5(task_id)` form in `includes/Scheduler/SchedulerRegistry.php:315`.
- Simplified Scheduler cron hook wiring: removed hardcoded per-task `add_action` calls and made the generic executor hook safer, plus inject `ConnectionInterface` into the registry for lock queries in `includes/Providers/SchedulerServiceProvider.php:195`.

How to verify
- `npm run lint`
- `npm test`

Risks / follow-ups
- `npm run lint` reports warnings (no errors); `npm test` passes but prints React `act(...)` warnings to console.
- New registry methods (`schedule_task`, `unschedule_task`, etc.) aren’t declared on `SchedulerRegistryInterface` yet; consider adding them when doing Q08-03 if you want to call them via the interface type.
file update:
diff --git a/includes/Providers/SchedulerServiceProvider.php b/includes/Providers/SchedulerServiceProvider.php
index a112cfd654cfdf2a97e04ae2917365ce26703dda..1638ee802830665c0802332ccda43a5a5c15f404
--- a/includes/Providers/SchedulerServiceProvider.php
+++ b/includes/Providers/SchedulerServiceProvider.php
@@ -63,8 +63,15 @@
 		// Register the SchedulerRegistry.
 		$this->container->singleton(
 			SchedulerRegistryInterface::class,
-			function () {
-				return new SchedulerRegistry();
+			function ( $container ) {
+				$registry = new SchedulerRegistry();
+
+				// Inject database connection for lock operations when available.
+				if ( $container->has( ConnectionInterface::class ) ) {
+					$registry->set_connection( $container->get( ConnectionInterface::class ) );
+				}
+
+				return $registry;
 			}
 		);
 		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
@@ -174,13 +181,8 @@
 	 * @return void
 	 */
 	private function setup_cron_hooks(): void {
-		// Hook for executing tasks from the registry.
+		// Optional generic hook for executing tasks from the registry (task_id, options).
 		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
-
-		// Hook individual task execution to cron hooks.
-		add_action( 'wpha_database_cleanup', array( $this, 'execute_database_cleanup' ) );
-		add_action( 'wpha_media_scan', array( $this, 'execute_media_scan' ) );
-		add_action( 'wpha_performance_check', array( $this, 'execute_performance_check' ) );
 	}
 
 	/**
@@ -190,7 +192,13 @@
 	 * @param array  $options Task options.
 	 * @return void
 	 */
-	public function execute_registered_task( string $task_id, array $options = array() ): void {
+	public function execute_registered_task( $task_id = '', $options = array() ): void {
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
 		$registry = $this->container->get( SchedulerRegistryInterface::class );
 		$registry->execute( $task_id, $options );
 	}
diff --git a/includes/Scheduler/SchedulerRegistry.php b/includes/Scheduler/SchedulerRegistry.php
index 27822324b553cca19c592d0f0d06cb9dc3e80a75..7efc0e20dd7e7b06379afe2e48216171e8648169
--- a/includes/Scheduler/SchedulerRegistry.php
+++ b/includes/Scheduler/SchedulerRegistry.php
@@ -42,6 +42,26 @@
 	const LOCK_PREFIX = 'wpha_task_lock_';
 
 	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
+	 * Default Action Scheduler group for recurring tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
 	 * Registered tasks.
 	 *
 	 * @var array<string, SchedulableInterface>
@@ -49,6 +69,13 @@
 	private array $tasks = array();
 
 	/**
+	 * Map of hook name to task ID for registered task hooks.
+	 *
+	 * @var array<string, string>
+	 */
+	private array $hook_to_task_id = array();
+
+	/**
 	 * Database connection.
 	 *
 	 * @since 1.3.0
@@ -60,8 +87,12 @@
 	 * {@inheritdoc}
 	 */
 	public function register( SchedulableInterface $task ): void {
-		$this->tasks[ $task->get_task_id() ] = $task;
+		$task_id = $task->get_task_id();
+		$this->tasks[ $task_id ] = $task;
 
+		// Register the WP-Cron hook for this task so WP-Cron / Action Scheduler can execute it.
+		$this->register_task_hook( $task_id );
+
 		/**
 		 * Fires when a task is registered with the scheduler.
 		 *
@@ -76,6 +107,16 @@
 	}
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string {
+		return self::TASK_HOOK_PREFIX . $task_id;
+	}
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get( string $task_id ): ?SchedulableInterface {
@@ -211,10 +252,59 @@
 	}
 
 	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * This enables WP-Cron and Action Scheduler to execute registered tasks
+	 * using their hook names (e.g. "wpha_database_cleanup").
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void {
+		$hook = current_filter();
+		if ( ! is_string( $hook ) || '' === $hook ) {
+			return;
+		}
+
+		$options = is_array( $options ) ? $options : array();
+
+		$task_id = $this->hook_to_task_id[ $hook ] ?? null;
+
+		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
+		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
+			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
+		}
+
+		if ( ! is_string( $task_id ) || '' === $task_id ) {
+			return;
+		}
+
+		$this->execute( $task_id, $options );
+	}
+
+	/**
+	 * Register the WP hook used to execute a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return void
+	 */
+	private function register_task_hook( string $task_id ): void {
+		$hook = $this->get_task_hook( $task_id );
+		$this->hook_to_task_id[ $hook ] = $task_id;
+
+		// Avoid duplicate registrations on repeated task registration.
+		if ( has_action( $hook, array( $this, 'handle_task_hook' ) ) ) {
+			return;
+		}
+
+		add_action( $hook, array( $this, 'handle_task_hook' ), 10, 1 );
+	}
+
+	/**
 	 * Acquire a lock for task execution.
 	 *
 	 * Uses MySQL advisory locks (GET_LOCK) for truly atomic locking.
-	 * Falls back to transients if GET_LOCK is unavailable.
+	 * Falls back to an option-based lock if GET_LOCK is unavailable.
 	 *
 	 * @since 1.2.0
 	 * @since 1.2.1 Use MySQL GET_LOCK for atomic operations.
@@ -224,6 +314,7 @@
 	 */
 	private function acquire_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Try MySQL advisory lock first (atomic operation).
 		// GET_LOCK returns: 1 = acquired, 0 = already held, NULL = error.
@@ -241,16 +332,43 @@
 			);
 		}
 
+		$lock_value = array(
+			'started_at' => time(),
+			'pid'        => getmypid(),
+		);
+
 		if ( 1 === (int) $result ) {
 			// Store lock info in transient for debugging/monitoring.
-			$lock_value = array(
-				'started_at' => time(),
-				'pid'        => getmypid(),
-			);
-			set_transient( self::LOCK_PREFIX . $task_id, $lock_value, self::LOCK_TIMEOUT );
+			set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
 			return true;
 		}
 
+		// If GET_LOCK is unavailable (NULL/error), fall back to an option-based lock.
+		if ( null === $result ) {
+			// add_option is atomic at the DB level and provides a reasonable fallback for environments
+			// where GET_LOCK is unavailable (e.g. some DB proxies).
+			$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+			if ( $acquired ) {
+				set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+				return true;
+			}
+
+			$existing = get_option( $lock_key );
+			$started  = is_array( $existing ) && isset( $existing['started_at'] ) ? (int) $existing['started_at'] : 0;
+
+			// If the lock appears stale, attempt to recover.
+			if ( $started > 0 && ( time() - $started ) > self::LOCK_TIMEOUT ) {
+				delete_option( $lock_key );
+				$acquired = add_option( $lock_key, $lock_value, '', 'no' );
+
+				if ( $acquired ) {
+					set_transient( $lock_key, $lock_value, self::LOCK_TIMEOUT );
+					return true;
+				}
+			}
+		}
+
 		return false;
 	}
 
@@ -265,6 +383,7 @@
 	 */
 	private function release_lock( string $task_id ): bool {
 		$lock_name = 'wpha_task_' . md5( $task_id );
+		$lock_key  = self::LOCK_PREFIX . md5( $task_id );
 
 		// Release MySQL advisory lock.
 		if ( $this->connection ) {
@@ -281,7 +400,10 @@
 		}
 
 		// Also clean up the transient.
-		delete_transient( self::LOCK_PREFIX . $task_id );
+		delete_transient( $lock_key );
+
+		// Clean up option-based lock fallback (if used).
+		delete_option( $lock_key );
 
 		return 1 === (int) $result;
 	}
@@ -317,10 +439,113 @@
 				'description'       => $task->get_description(),
 				'default_frequency' => $task->get_default_frequency(),
 				'enabled'           => $task->is_enabled(),
+				'hook'              => $this->get_task_hook( $task->get_task_id() ),
+				'next_run'          => $this->get_next_run( $task->get_task_id() ),
 				'settings_schema'   => $task->get_settings_schema(),
 			);
 		}
 
 		return $definitions;
 	}
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( 'disabled' === $frequency ) {
+			$this->unschedule_task( $task_id, $group );
+			return;
+		}
+
+		$interval = $this->get_interval_seconds( $frequency );
+		if ( ! $interval ) {
+			return;
+		}
+
+		if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+			as_schedule_recurring_action( $next_run, $interval, $hook, array(), $group );
+			return;
+		}
+
+		// Ensure we don't accidentally leave multiple schedules behind.
+		wp_clear_scheduled_hook( $hook );
+		wp_schedule_event( $next_run, $this->get_cron_schedule_name( $frequency ), $hook );
+	}
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_unschedule_all_actions' ) ) {
+			as_unschedule_all_actions( $hook, array(), $group );
+		}
+
+		wp_clear_scheduled_hook( $hook );
+	}
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {
+		$hook = $this->get_task_hook( $task_id );
+
+		if ( function_exists( 'as_next_scheduled_action' ) ) {
+			$next = as_next_scheduled_action( $hook, array(), $group );
+		} else {
+			$next = wp_next_scheduled( $hook );
+		}
+
+		return false === $next ? null : (int) $next;
+	}
+
+	/**
+	 * Get interval in seconds for a frequency.
+	 *
+	 * @param string $frequency Frequency name.
+	 * @return int|false Interval in seconds, or false if invalid.
+	 */
+	private function get_interval_seconds( string $frequency ) {
+		$intervals = array(
+			'daily'   => DAY_IN_SECONDS,
+			'weekly'  => WEEK_IN_SECONDS,
+			'monthly' => 30 * DAY_IN_SECONDS,
+		);
+
+		return $intervals[ $frequency ] ?? false;
+	}
+
+	/**
+	 * Get WP-Cron schedule name.
+	 *
+	 * @param string $frequency Frequency.
+	 * @return string Schedule name.
+	 */
+	private function get_cron_schedule_name( string $frequency ): string {
+		$schedules = array(
+			'daily'   => 'daily',
+			'weekly'  => 'weekly',
+			'monthly' => 'monthly',
+		);
+
+		return $schedules[ $frequency ] ?? 'daily';
+	}
 }

tokens used
258,211
