Status: DONE

Summary of changes
- Tightened `SchedulableInterface` contract docs (removed outdated frequency note, documented result/schema expectations) and added frequency constants in `includes/Scheduler/Contracts/SchedulableInterface.php:17`.
- Expanded `SchedulerRegistryInterface` to cover the public scheduling/lookup APIs already provided by `SchedulerRegistry` (hook mapping, scheduling/unscheduling, next-run, task definitions) in `includes/Scheduler/Contracts/SchedulerRegistryInterface.php:17`.

How to verify
- `npm run lint`
- `npm test`

Risks / follow-ups
- Adding methods/constants to `SchedulerRegistryInterface` is a breaking change for any third-party implementations of that interface (none exist in this repo).
- `npm run lint` still reports existing warnings (no errors).

OpenAI Codex v0.86.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite
model: gpt-5.2
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: xhigh
reasoning summaries: auto
session id: 019bcb3e-a0a3-7f91-8ce3-7d63872d0c0b
--------
user
You are implementing task Q08-03 in this git repository.

1) Read the spec: .plans/Q08-03.md
2) Read handoff/context: .t2/handoff/Q08-03.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: npm run lint
- test: npm test

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
Plan update
  → Read spec and handoff docs
  • Inspect current code paths
  • Implement required changes
  • Add/update tests as needed
  • Run lint and tests
  • Summarize and hand off
exec
/bin/zsh -lc 'ls -la' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
total 2208
drwxr-xr-x   55 ahmedyounis  staff    1760 Jan 16 09:09 .
drwxr-xr-x   43 ahmedyounis  staff    1376 Jan 11 22:56 ..
-rw-------@   1 ahmedyounis  staff     189 Jan  7 14:37 .babelrc
-rw-r--r--@   1 ahmedyounis  staff    1286 Jan  8 22:57 .eslintrc.json
drwxr-xr-x   14 ahmedyounis  staff     448 Jan 17 01:17 .git
drwxr-xr-x@   3 ahmedyounis  staff      96 Jan 14 06:48 .github
-rw-------@   1 ahmedyounis  staff     346 Jan  8 22:53 .gitignore
drwxr-xr-x@   4 ahmedyounis  staff     128 Jan  7 17:43 .husky
drwxr-xr-x@  10 ahmedyounis  staff     320 Jan 16 23:08 .idea
drwxr-xr-x@ 392 ahmedyounis  staff   12544 Jan 17 01:17 .logs
-rw-r--r--@   1 ahmedyounis  staff   28892 Jan 16 22:58 .phpunit.result.cache
drwxr-xr-x@ 131 ahmedyounis  staff    4192 Jan 17 01:17 .plans
-rw-r--r--@   1 ahmedyounis  staff     119 Jan  7 17:43 .prettierignore
-rw-r--r--@   1 ahmedyounis  staff     409 Jan  8 22:57 .prettierrc.json
drwx------@   3 ahmedyounis  staff      96 Jan  7 14:59 .scripts
drwxr-xr-x@   6 ahmedyounis  staff     192 Jan 16 06:56 .t2
-rw-r--r--@   1 ahmedyounis  staff    9207 Jan  8 22:57 ACCESSIBILITY.md
drwxr-xr-x@   4 ahmedyounis  staff     128 Jan  9 00:36 admin
drwxr-xr-x@   6 ahmedyounis  staff     192 Jan  7 10:29 assets
exec
/bin/zsh -lc "sed -n '1,200p' .plans/Q08-03.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
# Q08-03 — Scheduler Contracts Review

Review includes/Scheduler/Contracts/ for SchedulableInterface and SchedulerRegistryInterface definitions. Verify proper abstraction and extensibility.

thinking
**Verifying interfaces for review**

The spec is brief but states that I need to review the definitions for SchedulableInterface and SchedulerRegistryInterface. This means I need to ensure they offer proper abstraction and extensibility. I’m considering whether I might need to implement or perhaps even restructure these interfaces. It makes sense to look through the handoff for more details on this. Let’s take a closer look and see what additional information it holds!
exec
/bin/zsh -lc "sed -n '1,200p' .t2/handoff/Q08-03.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
# Handoff: Q08-03

Created: 2026-01-17T09:17:17.812397Z

Spec: .plans/Q08-03.md

thinking
**Inspecting contracts directory**

I need to review the existing contracts since the handoff has nothing else to provide. It seems like the logical step is to update them if necessary. So, I'm planning to inspect the includes/Scheduler/Contracts/ directory for the relevant documents. I want to ensure everything is in order and ready for any upcoming changes. It’s essential to have everything properly reviewed and updated!
exec
/bin/zsh -lc 'ls -la includes/Scheduler/Contracts' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
total 16
drwxr-xr-x@ 4 ahmedyounis  staff   128 Jan  8 23:36 .
drwxr-xr-x@ 6 ahmedyounis  staff   192 Jan 16 04:39 ..
-rw-r--r--@ 1 ahmedyounis  staff  1500 Jan  8 23:36 SchedulableInterface.php
-rw-r--r--@ 1 ahmedyounis  staff  1665 Jan  8 23:36 SchedulerRegistryInterface.php
exec
/bin/zsh -lc "sed -n '1,200p' includes/Scheduler/Contracts/SchedulableInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
<?php
/**
 * Schedulable Interface
 *
 * Contract for scheduled task implementations.
 *
 * @package WPAdminHealth\Scheduler\Contracts
 */

namespace WPAdminHealth\Scheduler\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface SchedulableInterface
 *
 * Defines the contract for tasks that can be scheduled.
exec
/bin/zsh -lc "sed -n '1,240p' includes/Scheduler/Contracts/SchedulerRegistryInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * Scheduler Registry Interface
 *
 * Contract for the scheduler registry that manages schedulable tasks.
 *
 * @package WPAdminHealth\Scheduler\Contracts
 */

namespace WPAdminHealth\Scheduler\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface SchedulerRegistryInterface
 *
 * Defines the contract for task registration and management.

thinking
**Verifying abstraction and extensibility**

I need to ensure that my abstraction and extensibility are properly set. I’m thinking the interfaces might be too specific since they return an array with items_cleaned and bytes_freed. It could be better if they were more generic, like having execute return an array of string and mixed or a TaskResultInterface. Also, I want to check how frequently defaults are applied and look into the settings schema. Let’s inspect the includes/Scheduler classes for more details!
exec
/bin/zsh -lc 'ls -ლა includes/Scheduler' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 67ms:
ls: invalid option -- á
usage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]

thinking
**Correcting terminology**

Oh no, I accidentally used the word "weird." Now, I need to make sure to list the files and directories properly by executing the command `ls -la includes/Scheduler`. This should help me see what’s in that directory without any confusion. I want to ensure I'm on track and addressing everything correctly. Let's focus on getting the right information from this command!
exec
/bin/zsh -lc 'ls -la includes/Scheduler' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
total 56
drwxr-xr-x@  6 ahmedyounis  staff    192 Jan 16 04:39 .
drwxr-xr-x@ 28 ahmedyounis  staff    896 Jan 16 22:08 ..
-rw-r--r--@  1 ahmedyounis  staff  10165 Jan 17 01:14 AbstractScheduledTask.php
drwxr-xr-x@  4 ahmedyounis  staff    128 Jan  8 23:36 Contracts
-rw-r--r--@  1 ahmedyounis  staff  14251 Jan 17 00:58 SchedulerRegistry.php
drwxr-xr-x@  3 ahmedyounis  staff     96 Jan  8 23:45 Traits
exec
/bin/zsh -lc "sed -n '1,240p' includes/Scheduler/AbstractScheduledTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
<?php
/**
 * Abstract Scheduled Task
 *
 * Base class for scheduled task implementations.
 *
 * @package WPAdminHealth\Scheduler
 */

namespace WPAdminHealth\Scheduler;

use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class AbstractScheduledTask
exec
/bin/zsh -lc "sed -n '240,520p' includes/Scheduler/AbstractScheduledTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
		}

		$elapsed = microtime( true ) - $this->start_time;
		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
	}

	/**
	 * Get the option key used for persisting task progress.
	 *
	 * @return string Progress option key or empty string when disabled.
	 */
	protected function get_progress_option_key(): string {
		return $this->progress_option_key;
	}

	/**
	 * Load saved progress from a previous interrupted run.
	 *
	 * @return array Progress data or empty array.
	 */

thinking
I'm analyzing the AbstractScheduledTask, which implements the SchedulableInterface and includes progress methods like get_progress, has_pending_progress, and reset_progress—none of which are in the original interface. This makes the interface seem minimal, even though tasks may have progress capabilities without a defined contract. I’m wondering if a separate interface for progress or resumable tasks is needed. Plus, get_default_frequency currently returns a string, but it could be improved with enumeration. I’ll check SchedulerRegistry.php for additional methods.
exec
/bin/zsh -lc "sed -n '1,260p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * Scheduler Registry
 *
 * Manages registration and execution of schedulable tasks.
 *
 * @package WPAdminHealth\Scheduler
 */

namespace WPAdminHealth\Scheduler;

use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

exec
/bin/zsh -lc "sed -n '260,520p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
	 * @param mixed $options Optional task options (must be an array).
	 * @return void
	 */
	public function handle_task_hook( $options = array() ): void {
		$hook = current_filter();
		if ( ! is_string( $hook ) || '' === $hook ) {
			return;
		}

		$options = is_array( $options ) ? $options : array();

		$task_id = $this->hook_to_task_id[ $hook ] ?? null;

		// Fallback for hooks not registered via the registry (e.g. legacy hooks).
		if ( null === $task_id && 0 === strpos( $hook, self::TASK_HOOK_PREFIX ) ) {
			$task_id = substr( $hook, strlen( self::TASK_HOOK_PREFIX ) );
		}

		if ( ! is_string( $task_id ) || '' === $task_id ) {
			return;
exec
/bin/zsh -lc "sed -n '520,920p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:
	/**
	 * Get interval in seconds for a frequency.
	 *
	 * @param string $frequency Frequency name.
	 * @return int|false Interval in seconds, or false if invalid.
	 */
	private function get_interval_seconds( string $frequency ) {
		$intervals = array(
			'daily'   => DAY_IN_SECONDS,
			'weekly'  => WEEK_IN_SECONDS,
			'monthly' => 30 * DAY_IN_SECONDS,
		);

		return $intervals[ $frequency ] ?? false;
	}

	/**
	 * Get WP-Cron schedule name.
	 *
	 * @param string $frequency Frequency.
exec
/bin/zsh -lc 'rg -n "SchedulerRegistryInterface" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 76ms:
./review_tasks.csv:49:Q08-03,"Scheduler Contracts Review","Review includes/Scheduler/Contracts/ for SchedulableInterface and SchedulerRegistryInterface definitions. Verify proper abstraction and extensibility."
./includes/Providers/SchedulerServiceProvider.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
./includes/Providers/SchedulerServiceProvider.php:52:		SchedulerRegistryInterface::class,
./includes/Providers/SchedulerServiceProvider.php:65:			SchedulerRegistryInterface::class,
./includes/Providers/SchedulerServiceProvider.php:77:		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
./includes/Providers/SchedulerServiceProvider.php:148:		$registry = $this->container->get( SchedulerRegistryInterface::class );
./includes/Providers/SchedulerServiceProvider.php:173:		 * @param SchedulerRegistryInterface $registry The scheduler registry.
./includes/Providers/SchedulerServiceProvider.php:202:		$registry = $this->container->get( SchedulerRegistryInterface::class );
./includes/Scheduler/SchedulerRegistry.php:14:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
./includes/Scheduler/SchedulerRegistry.php:28:class SchedulerRegistry implements SchedulerRegistryInterface {
./includes/Scheduler/Contracts/SchedulerRegistryInterface.php:18: * Interface SchedulerRegistryInterface
./includes/Scheduler/Contracts/SchedulerRegistryInterface.php:24:interface SchedulerRegistryInterface {
./includes/Scheduler/Traits/HasScheduledTasks.php:13:use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
./includes/Scheduler/Traits/HasScheduledTasks.php:48:		if ( ! $this->container->has( SchedulerRegistryInterface::class ) ) {
./includes/Scheduler/Traits/HasScheduledTasks.php:52:		$registry = $this->container->get( SchedulerRegistryInterface::class );

thinking
I'm looking into Provider and Trait to identify the necessary interface methods. I think this step is important for understanding how these components interact and function together. By examining their interface methods, I can ensure that everything aligns properly. I'm curious to find out what specific methods are required, as that will help clarify the overall structure. It's essential to get this right for any related development. Let's figure this out!
exec
/bin/zsh -lc "sed -n '1,260p' includes/Providers/SchedulerServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 49ms:
<?php
/**
 * Scheduler Service Provider
 *
 * Registers the Scheduler service and task registry.
 *
 * @package WPAdminHealth\Providers
 */

namespace WPAdminHealth\Providers;

use WPAdminHealth\Container\ServiceProvider;
use WPAdminHealth\Scheduler\SchedulerRegistry;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;
use WPAdminHealth\Database\Tasks\DatabaseCleanupTask;
use WPAdminHealth\Media\Tasks\MediaScanTask;
use WPAdminHealth\Performance\Tasks\PerformanceCheckTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
exec
/bin/zsh -lc "sed -n '1,200p' includes/Scheduler/Traits/HasScheduledTasks.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 50ms:
<?php
/**
 * Has Scheduled Tasks Trait
 *
 * Provides functionality for service providers to register scheduled tasks.
 *
 * @package WPAdminHealth\Scheduler\Traits
 */

namespace WPAdminHealth\Scheduler\Traits;

use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
exec
/bin/zsh -lc 'rg -n "class .*Task" includes -S | head' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 57ms:
includes/Media/Tasks/MediaScanTask.php:33:class MediaScanTask extends AbstractScheduledTask {
includes/Scheduler/AbstractScheduledTask.php:26:abstract class AbstractScheduledTask implements SchedulableInterface {
includes/Performance/Tasks/PerformanceCheckTask.php:30:class PerformanceCheckTask extends AbstractScheduledTask {
includes/Database/Tasks/DatabaseCleanupTask.php:33:class DatabaseCleanupTask extends AbstractScheduledTask {
exec
/bin/zsh -lc "sed -n '1,260p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
<?php
/**
 * Database Cleanup Task
 *
 * Scheduled task for database maintenance operations.
 *
 * @package WPAdminHealth\Database\Tasks
 */

namespace WPAdminHealth\Database\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
use WPAdminHealth\Contracts\OrphanedCleanerInterface;
use WPAdminHealth\Contracts\TrashCleanerInterface;
use WPAdminHealth\Contracts\OptimizerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '260,560p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
			 *
			 * @hook wpha_db_cleanup_after_subtask
			 *
			 * @param string $task    The subtask identifier.
			 * @param array  $result  The subtask result.
			 * @param array  $options Task options.
			 */
			do_action( 'wpha_db_cleanup_after_subtask', $task, $result, $options );
		}

		// Optionally optimize tables (only if not interrupted and all tasks completed).
		if ( ! $was_interrupted && empty( $subtask_errors ) ) {
			if ( ! empty( $settings['optimize_tables_weekly'] ) || ! empty( $options['optimize_tables'] ) ) {
				if ( ! $this->is_time_limit_approaching() ) {
					try {
						$this->optimizer->optimize_all_tables();
						$this->log( 'Database tables optimized' );
					} catch ( \Throwable $e ) {
						$subtask_errors['optimize'] = $e->getMessage();
						$this->log( sprintf( 'Table optimization failed: %s', $e->getMessage() ), 'error' );
exec
/bin/zsh -lc "sed -n '560,820p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 29ms:
	public function get_settings_schema(): array {
		return array(
			'clean_revisions'    => array(
				'type'        => 'boolean',
				'default'     => true,
				'description' => __( 'Clean post revisions', 'wp-admin-health-suite' ),
			),
			'max_revisions'      => array(
				'type'        => 'integer',
				'default'     => 5,
				'min'         => 0,
				'max'         => 100,
				'description' => __( 'Maximum revisions to keep per post', 'wp-admin-health-suite' ),
			),
			'clean_transients'   => array(
				'type'        => 'boolean',
				'default'     => true,
				'description' => __( 'Clean expired transients', 'wp-admin-health-suite' ),
			),
			'clean_orphaned'     => array(

thinking
**Evaluating database tasks**

I am looking into the DatabaseCleanupTask, which returns a create_result that includes keys like items_cleaned and was_interrupted. I think the interface documentation should reflect these result keys accordingly. The MediaScanTask seems like it might return a different structure, so I should check that too. It's essential to ensure the documentation is coherent with what each task returns for clarity!
exec
/bin/zsh -lc "sed -n '1,260p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
<?php
/**
 * Media Scan Task
 *
 * Scheduled task for media library scanning and maintenance.
 *
 * @package WPAdminHealth\Media\Tasks
 */

namespace WPAdminHealth\Media\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\Contracts\DuplicateDetectorInterface;
use WPAdminHealth\Contracts\LargeFilesInterface;
use WPAdminHealth\Contracts\AltTextCheckerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '260,560p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 50ms:
						'completed_tasks' => $completed_tasks,
						'errors'          => $subtask_errors,
						'interrupted_at'  => current_time( 'mysql' ),
					)
				);
				break;
			}

			/**
			 * Fires before a scan subtask is executed.
			 *
			 * @since 1.6.0
			 *
			 * @hook wpha_media_scan_before_subtask
			 *
			 * @param string $task    The subtask identifier.
			 * @param array  $options Task options.
			 */
			do_action( 'wpha_media_scan_before_subtask', $task, $options );

exec
/bin/zsh -lc "sed -n '560,920p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 43ms:
				break;
		}
	}

	/**
	 * Store scan results for later review.
	 *
	 * @since 1.2.0
	 *
	 * @param array $results Scan results.
	 * @return void
	 */
	private function store_scan_results( array $results ): void {
		$table = $this->connection->get_prefix() . 'wpha_scan_history';

		// If the table doesn't exist yet, don't fail the scan task.
		$table_check_query = $this->connection->prepare(
			'SHOW TABLES LIKE %s',
			$this->connection->esc_like( $table )
		);

thinking
**Evaluating task functions**

I'm analyzing the MediaScanTask, which uses create_result with items_cleaned and total_issues, though it doesn't seem fully cleaned. It's calling create_result(issues, bytes, success), leading me to think that the interface documentation might be too specific. I should check into the PerformanceCheckTask next to see if it exhibits similar patterns or issues. It feels like there's something more to understand here!
exec
/bin/zsh -lc "sed -n '1,300p' includes/Performance/Tasks/PerformanceCheckTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 34ms:
<?php
/**
 * Performance Check Task
 *
 * Scheduled task for performance monitoring and analysis.
 *
 * @package WPAdminHealth\Performance\Tasks
 */

namespace WPAdminHealth\Performance\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\AutoloadAnalyzerInterface;
use WPAdminHealth\Contracts\QueryMonitorInterface;
use WPAdminHealth\Contracts\PluginProfilerInterface;
use WPAdminHealth\Contracts\ConnectionInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
exec
/bin/zsh -lc "sed -n '300,560p' includes/Performance/Tasks/PerformanceCheckTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
				'type'        => 'boolean',
				'default'     => true,
				'description' => __( 'Monitor slow queries', 'wp-admin-health-suite' ),
			),
			'profile_plugins'  => array(
				'type'        => 'boolean',
				'default'     => false,
				'description' => __( 'Profile plugin performance', 'wp-admin-health-suite' ),
			),
		);
	}
}
exec
/bin/zsh -lc "rg -n \"get_task_definitions\\(\" -S includes" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 44ms:
includes/Scheduler/SchedulerRegistry.php:432:	public function get_task_definitions(): array {

thinking
**Investigating registry usage**

I’m thinking that only the registry uses this specific element. I should search for how execution return keys are being utilized. Maybe the JS admin is involved, and it could be useful to look for something like 'items_cleaned.' There's definitely a thread to pull on there, and I want to get to the bottom of how all this is connected! Let's see what I can uncover with these searches.
exec
/bin/zsh -lc 'rg -n "items_cleaned" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 56ms:
./assets/js/components/ActivityTimeline.test.jsx:16:			items_cleaned: 10,
./assets/js/components/ActivityTimeline.test.jsx:23:			items_cleaned: 5,
./assets/js/components/ActivityTimeline.test.jsx:30:			items_cleaned: 0,
./assets/js/components/ActivityTimeline.test.jsx:217:					items_cleaned: 1,
./assets/js/components/ActivityTimeline.test.jsx:239:					items_cleaned: 1,
./assets/js/components/ActivityTimeline.test.jsx:279:					items_cleaned: 1,
./assets/js/components/ActivityTimeline.test.jsx:299:					items_cleaned: 2,
./assets/js/components/ActivityTimeline.jsx:411:									{activity.items_cleaned > 0 && (
./assets/js/components/ActivityTimeline.jsx:420:											{activity.items_cleaned}{' '}
./assets/js/components/ActivityTimeline.jsx:421:											{activity.items_cleaned === 1
./tasks.csv:4:M00-03,"Database Schema & Installation","Create /includes/class-installer.php handling plugin installation. Create custom tables on activation: {prefix}wpha_scan_history (id, scan_type, items_found, items_cleaned, bytes_freed, created_at), {prefix}wpha_scheduled_tasks (id, task_type, frequency, last_run, next_run, status, settings JSON). Use dbDelta() for table creation. Store plugin version in options. Add upgrade routine checking version. Create uninstall.php that removes all tables and options when DELETE_PLUGIN_DATA constant is true. Acceptance: Tables created with proper charset/collation, upgrade path works, clean uninstall removes all data."
./docs/developers/rest-api.md:276:				"items_cleaned": 100,
./docs/developers/rest-api.md:330:		"items_cleaned": 15,
./docs/developers/rest-api.md:1488:			"items_cleaned": 100,
./docs/developers/rest-api.md:1496:			"items_cleaned": 5,
./docs/developers/hooks.md:34:    - `items_cleaned` (int) - Number of items cleaned
./docs/developers/hooks.md:52:            'items_cleaned' => $custom_result['count'],
./docs/developers/hooks.md:474:    $items_cleaned = 0;
./docs/developers/hooks.md:488:                $items_cleaned++;
./docs/developers/hooks.md:494:        'items_cleaned' => $items_cleaned,
exec
/bin/zsh -lc 'rg -n "SchedulableInterface" -S docs includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 37ms:
includes/Scheduler/AbstractScheduledTask.php:12:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
includes/Scheduler/AbstractScheduledTask.php:26:abstract class AbstractScheduledTask implements SchedulableInterface {
includes/Scheduler/SchedulerRegistry.php:13:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
includes/Scheduler/SchedulerRegistry.php:67:	 * @var array<string, SchedulableInterface>
includes/Scheduler/SchedulerRegistry.php:89:	public function register( SchedulableInterface $task ): void {
includes/Scheduler/SchedulerRegistry.php:103:		 * @param SchedulableInterface $task    The registered task.
includes/Scheduler/SchedulerRegistry.php:122:	public function get( string $task_id ): ?SchedulableInterface {
includes/Scheduler/SchedulerRegistry.php:158:			function ( SchedulableInterface $task ) {
includes/Scheduler/SchedulerRegistry.php:191:		 * @param SchedulableInterface $task    The task about to execute.
includes/Scheduler/SchedulerRegistry.php:222:			 * @param SchedulableInterface $task      The task that failed.
includes/Scheduler/SchedulerRegistry.php:245:		 * @param SchedulableInterface $task    The task that executed.
includes/Scheduler/SchedulerRegistry.php:415:	 * @return array<string, SchedulableInterface> Filtered tasks.
includes/Scheduler/SchedulerRegistry.php:421:			function ( SchedulableInterface $task ) use ( $prefix ) {
includes/Scheduler/Contracts/SchedulableInterface.php:18: * Interface SchedulableInterface
includes/Scheduler/Contracts/SchedulableInterface.php:24:interface SchedulableInterface {
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:29:	 * @param SchedulableInterface $task Task to register.
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:32:	public function register( SchedulableInterface $task ): void;
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:38:	 * @return SchedulableInterface|null Task instance or null if not found.
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:40:	public function get( string $task_id ): ?SchedulableInterface;
includes/Scheduler/Contracts/SchedulerRegistryInterface.php:45:	 * @return array<string, SchedulableInterface> Array of registered tasks keyed by task ID.

thinking
**Considering task scheduling specifications**

I’m noticing that the documentation doesn’t seem to mention anything about how to implement a more robust contract for tasks that can be scheduled, like in ActionScheduler. Maybe I should consider including methods for getting hooks or scheduling frequencies. I plan to inspect the documentation regarding scheduled tasks and the REST API to see what’s outlined there. It’ll be helpful to clarify this part!
exec
/bin/zsh -lc 'rg -n "scheduled task" docs -S | head' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 39ms:
docs/getting-started.md:28:- **Recommended:** Action Scheduler plugin (optional, but improves scheduled task reliability)
docs/getting-started.md:63:- Creates two database tables for storing scan history and scheduled tasks
docs/getting-started.md:583:#### Issue: Scheduled Tasks Don't Run
docs/getting-started.md:591:3. **Install Action Scheduler:** This plugin improves scheduled task reliability
docs/getting-started.md:593:5. **Review logs:** Check activity logs for scheduled task errors
docs/database-cleanup.md:1461:1. Scheduled tasks are registered
docs/database-cleanup.md:1518:- Toggle off to disable all scheduled tasks
docs/database-cleanup.md:1740:### Monitoring Scheduled Tasks
docs/database-cleanup.md:1755:2. View **Next Scheduled Tasks** section:
docs/database-cleanup.md:1844:### Troubleshooting Scheduled Tasks

thinking
**Exploring task documentation**

I think I should check the documentation for scheduled tasks. It seems like the spec focuses on interfaces, but I can gather some insights. I should look up information regarding custom tasks specifically, maybe by searching for "custom tasks" or similar terms. That way, I can figure out what's available and how to implement it effectively. Let's see what I can find!
exec
/bin/zsh -lc 'rg -n "custom task" -S docs | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 36ms:
docs/developers/hooks.md:164:    // Run custom tasks before WPHA activation
docs/developers/hooks.md:469:    // Only handle our custom task type
exec
/bin/zsh -lc "sed -n '420,560p' docs/developers/hooks.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 31ms:

```php
add_action( 'wpha_admin_init', 'my_admin_customizations' );

function my_admin_customizations() {
    // Add custom admin functionality
    add_menu_page( 'Custom Page', 'Custom', 'manage_options', 'custom-page', 'render_custom_page' );
}
```

---

## Common Customization Examples

### Example 1: Adding Custom Plugin Tables to Exclusions

Prevent your plugin's tables from being detected as orphaned:

```php
/**
exec
/bin/zsh -lc "rg -n \"schedule_task\\(\" -S includes | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 36ms:
includes/Settings/SettingsServiceProvider.php:875:				$this->unschedule_task( $hook );
includes/Settings/SettingsServiceProvider.php:880:				$this->schedule_task( $hook, (string) $new_frequency, $next_run );
includes/Settings/SettingsServiceProvider.php:969:	private function schedule_task( string $hook, string $frequency, int $next_run ): void {
includes/Settings/SettingsServiceProvider.php:971:			$this->unschedule_task( $hook );
includes/Settings/SettingsServiceProvider.php:996:	private function unschedule_task( string $hook ): void {
includes/Settings/SettingsServiceProvider.php:1013:			$this->unschedule_task( $hook );
includes/Scheduler/SchedulerRegistry.php:460:	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void {
includes/Scheduler/SchedulerRegistry.php:464:			$this->unschedule_task( $task_id, $group );
includes/Scheduler/SchedulerRegistry.php:491:	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void {
exec
/bin/zsh -lc "sed -n '800,1080p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 64ms:

		wp_safe_redirect( $redirect );
		exit;
	}

	/**
	 * Handle scheduling settings updates.
	 *
	 * Only reschedules tasks when their frequency changes, preferred time changes,
	 * or when the scheduler is newly enabled.
	 *
	 * @param array $old_value Previous settings.
	 * @param array $new_value New settings.
	 * @return void
	 */
	public function handle_scheduling_update( $old_value, $new_value ): void {
		if ( ! is_array( $old_value ) ) {
			$old_value = array();
		}


thinking
I'm considering whether there's a REST controller for scheduling tasks. It seems logical to search for "scheduler" in relation to REST. I wonder how these two concepts might connect. Perhaps it would help to explore how RESTful APIs handle scheduling functionalities. It’s interesting to think about the different ways these technologies could work together. Let's dive into this search and see what I can find!
exec
/bin/zsh -lc 'rg -n "SchedulerRegistry" includes/REST -S | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 71ms:

exec
/bin/zsh -lc "rg -n \"scheduler\\.registry\" -S includes | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 34ms:
includes/Providers/SchedulerServiceProvider.php:53:		'scheduler.registry',
includes/Providers/SchedulerServiceProvider.php:77:		$this->container->alias( 'scheduler.registry', SchedulerRegistryInterface::class );
exec
/bin/zsh -lc 'rg -n "wpha_scheduler_tasks_registered" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 36ms:
./includes/Providers/SchedulerServiceProvider.php:171:		 * @hook wpha_scheduler_tasks_registered
./includes/Providers/SchedulerServiceProvider.php:175:		do_action( 'wpha_scheduler_tasks_registered', $registry );


thinking
**Reviewing task scheduling**

I’m thinking about how tasks might rely on the scheduler registry, specifically the `get_task_hook`. This allows tasks to not worry about the hook name yet raises a question: should tasks have the option to override the hook name? It seems that while the plugin uses the `wpha_{task_id}`, some tasks may benefit from different hooks or naming conventions to avoid conflicts. 

I’m also noticing discrepancies between the interface documentation and the actual settings regarding custom days. This could lead to a contract issue that might need clarification for future extensibility.
thinking
**Examining frequency settings**

I’m considering that the interface method `get_default_frequency` currently returns a string, but maybe it should return a union of allowed values. However, it seems PHP doesn't support this. Perhaps I can define constants for things like `FREQUENCY_DAILY`, `FREQUENCY_WEEKLY`, `FREQUENCY_MONTHLY`, and `FREQUENCY_DISABLED`. 

But then again, tasks might need to specify other frequencies. I wonder if providing a method like `get_default_schedule` would be more efficient. While that feels a bit heavy, adjusting the documentation to omit `custom_days` seems reasonable while mentioning `disabled` could help clarify usage. I should check for any references to `custom_days`.
exec
/bin/zsh -lc 'rg -n "custom_days" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 37ms:
./tasks.csv:24:M02-10,"Cleanup Scheduler System","Create /includes/class-scheduler.php using Action Scheduler library (or WP-Cron fallback). Methods: schedule_cleanup(type, frequency, options), unschedule_cleanup(type), get_scheduled_tasks(), run_scheduled_task(task_id). Frequencies: daily, weekly, monthly, custom_days. Store schedules in wpha_scheduled_tasks table. Hook into action_scheduler_run or wp_cron. Email notification option on completion (uses wp_mail). Acceptance: Tasks run on schedule, handles missed schedules gracefully, email notifications work, logs all executions."
./includes/Scheduler/Contracts/SchedulableInterface.php:50:	 * @return string Default frequency (daily, weekly, monthly, custom_days).
exec
/bin/zsh -lc 'rg -n "wpha_scheduled_tasks" -S includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 34ms:
includes/Installer.php:142:		$scheduled_tasks_table = $prefix . 'wpha_scheduled_tasks';
includes/Installer.php:553:			$connection->query( "DROP TABLE IF EXISTS `{$prefix}wpha_scheduled_tasks`" );
includes/Installer.php:560:			$wpdb->query( "DROP TABLE IF EXISTS {$prefix}wpha_scheduled_tasks" );


thinking
**Evaluating scheduler contracts**

I'm noticing that only the installer is mentioned, and it seems like the scheduler table isn't being used. To simplify, I think we need robust contract definitions for future use. Maybe adding methods like `get_task_group` or `get_task_hooks` could help integrate with the Action Scheduler group, although that might not be necessary. The spec is ambiguous, and we need to verify the definitions for proper abstraction and extensibility by running tests or linting to identify any contract mismatches.
thinking
**Searching for interface usage**

I think the tests might check if the interface methods exist, so I should search the tests for any usage of `SchedulerRegistryInterface::`. This could help me identify where it’s being referenced and ensure that all methods are properly implemented. By examining these tests, I can confirm that the interface aligns with what's expected and determine if there’s anything I need to adjust or add for proper functionality.
exec
/bin/zsh -lc 'rg -n "SchedulerRegistryInterface" tests -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 72ms:


thinking
**Checking tasks and PHP version**

I'm thinking about whether tasks need to check if they're enabled. It might be a good idea to open the includes/Scheduler/Contracts files since there are only two. I could adjust them with proper PHP documentation, like using `@phpstan-type TaskResult`, which would enhance abstraction. Also, I should verify the PHP version; composer might be using PHP 8.1, so I’ll look into the composer.json file to confirm.
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
{
  "name": "wp-admin-health/suite",
  "description": "A comprehensive suite for monitoring and maintaining WordPress admin health and performance",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "version": "1.0.0",
  "require": {
    "php": ">=7.4",
    "composer/installers": "^1.0 || ^2.0"
  },
  "require-dev": {
    "dealerdirect/phpcodesniffer-composer-installer": "^1.2",
    "phpcompatibility/phpcompatibility-wp": "^2.1",
    "phpdocumentor/phpdocumentor": "^3.0",
    "phpstan/extension-installer": "^1.4",
    "phpstan/phpstan": "^2.1",
    "phpunit/phpunit": "^9.5",
    "squizlabs/php_codesniffer": "^3.13",
    "szepeviktor/phpstan-wordpress": "^2.0",
    "wp-coding-standards/wpcs": "^3.3",

thinking
**Evaluating PHP version compatibility**

I see that Composer recommends PHP 7.4 or higher, which is fine since the code uses typed properties that require at least 7.4. However, wait, union types were introduced in PHP 8.0, so they won't work in 7.4. With typed properties and return types in use, we'll stick with PHP 7.4 and avoid union types. We can use phpdoc generics as an alternative. I should also check the package.json for the Node tasks and see how JS tests fit in.
exec
/bin/zsh -lc 'cat package.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
{
  "name": "wp-admin-health-suite",
  "version": "1.0.0",
  "description": "A comprehensive suite for monitoring and maintaining WordPress admin health and performance",
  "scripts": {
    "build": "webpack --mode production",
    "build:dev": "webpack --mode development",
    "watch": "webpack --mode development --watch",
    "dev": "webpack serve --mode development --open",
    "lint": "eslint assets/js --ext .js,.jsx",
    "lint:fix": "eslint assets/js --ext .js,.jsx --fix",
    "format": "prettier --write \"**/*.{js,jsx,json,css,scss,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,json,css,scss,md}\"",
    "test": "jest --passWithNoTests",
    "prepare": "husky"
  },
  "keywords": [
    "wordpress",
    "plugin",
    "health",




thinking
**Examining method compatibility**

I'm checking compatibility rules in PHP—like making sure that an implementing method can't have required parameters if the interface defines them as optional. I think changing default values might be allowed as long as it still meets the requirements. For Liskov Substitution Principle (LSP), if an interface has a parameter with a default value of 'foo,' the implementing method could use 'bar' instead. I'll need to confirm how PHP handles this. To be safe, I should match the default by defining a constant in the interface to ensure compatibility.
thinking
**Analyzing compatibility in SchedulerRegistry**

In the `SchedulerRegistry` class, the `schedule_task` method uses `string $group = self::ACTION_SCHEDULER_GROUP`, which refers to a class constant. However, in the interface, `self::` refers to the interface itself. When the method is implemented, it uses the default value as a compiled constant. I’m considering that if both constants have the same value, it should work fine. Compatibility checks likely compare values rather than expressions, so I'm making sure they are identical to avoid potential errors.
thinking
**Considering interface constants in SchedulerRegistry**

I’m thinking about changing the `schedule_task` method signature in the `SchedulerRegistry` to use the interface constant `SchedulerRegistryInterface::ACTION_SCHEDULER_GROUP`. I realize I can reference the interface constant, but default values might be tricky. It could be simpler just to use the same string 'wpha_scheduling' in both places. I need to confirm that the class constant exists, which it does. The `get_next_run` method also uses the group constant, and I wonder if we should define a constant for the TASK_HOOK_PREFIX in the interface too — even if it might not be necessary.
thinking
**Examining execute method documentation**

I'm considering updating the `execute` method's return PHPDoc to include any new constants or types. I wonder if I should also add methods like `get_default_options()` or `get_default_settings()`, although that might not be necessary. The `create_result` in `AbstractScheduledTask` includes keys like 'task_id' and 'executed_at.' The Registry's `execute` returns 'task_id,' and it seems many parts of the code rely on these keys. I’ll check the REST API documentation to see if it expects 'task_id' and search for 'executed_at' for clarity.
exec
/bin/zsh -lc 'rg -n "executed_at" -S docs includes tests | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 74ms:
includes/Scheduler/AbstractScheduledTask.php:408:			'executed_at'   => current_time( 'mysql' ),

thinking
**Evaluating scheduler contracts**

I need to think about how the scheduler contracts should be abstract and extensible. That could mean adding new interfaces for different capabilities and adjusting existing ones so we don't force unnecessary methods. However, I have to stick to a minimal spec. Let's check the review_tasks.csv file to look into other Q08 tasks that might help guide this process. There might be useful insights there!
exec
/bin/zsh -lc "sed -n '1,120p' review_tasks.csv" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
id,title,spec
Q01-01,"Core Plugin Architecture Review","Review includes/Plugin.php for singleton pattern correctness, DI container initialization, hook registration order, and plugin lifecycle management (activation/deactivation). Check for memory leaks, proper dependency resolution, and WordPress best practices compliance."
Q01-02,"Dependency Injection Container Review","Review includes/Container/Container.php and ServiceProvider.php for proper service registration, singleton vs factory behavior, circular dependency handling, and lazy loading of services. Verify interface binding and resolution logic."
Q01-03,"Service Provider Registration Review","Review all files in includes/Providers/ (CoreServiceProvider, DatabaseServiceProvider, MediaServiceProvider, PerformanceServiceProvider, AIServiceProvider, RESTServiceProvider, SchedulerServiceProvider) for proper service binding, dependency ordering, and initialization logic."
Q01-04,"Autoloader and Namespace Review","Review includes/autoload.php for PSR-4 compliance, proper namespace mapping, error handling for missing classes, and performance of class loading. Verify all classes are properly namespaced."
Q01-05,"Contracts and Interfaces Review","Review all interfaces in includes/Contracts/ for proper abstraction, method signatures, return type declarations, and documentation. Ensure interfaces follow ISP (Interface Segregation Principle)."
Q02-01,"Database Analyzer Review","Review includes/database/Analyzer.php for SQL query safety, accurate size calculations, proper caching strategy (5-min TTL), and handling of large databases. Check for N+1 queries and proper use of $wpdb->prepare()."
Q02-02,"Database Revisions Manager Review","Review includes/database/RevisionsManager.php for safe revision deletion logic, configurable retention, proper batch processing, and recovery mechanisms. Verify it doesn't delete revisions of unpublished posts incorrectly."
Q02-03,"Database Transients Cleaner Review","Review includes/database/TransientsCleaner.php for proper expired transient detection, handling of site transients vs regular transients, and multisite compatibility. Check for race conditions during cleanup."
Q02-04,"Database Trash Cleaner Review","Review includes/database/TrashCleaner.php for safe trash/spam post deletion, proper handling of scheduled posts, attachment cleanup, and comment spam removal. Verify no accidental deletion of valid content."
Q02-05,"Database Orphaned Cleaner Review","Review includes/database/OrphanedCleaner.php for accurate orphaned metadata detection (postmeta, usermeta, commentmeta), safe cleanup logic, and handling of multisite metadata. Check for false positives."
Q02-06,"Database Optimizer Review","Review includes/database/Optimizer.php for safe table optimization operations, InnoDB vs MyISAM handling, table locking implications, and progress reporting. Verify it handles large tables gracefully."
Q02-07,"Database Orphaned Tables Review","Review includes/database/OrphanedTables.php for accurate detection of tables from deactivated plugins, safe deletion safeguards, and handling of shared tables. Check false positive prevention."
Q02-08,"Database Connection Wrapper Review","Review includes/database/WpdbConnection.php for proper $wpdb wrapping, error handling, query logging, and connection state management. Verify it properly handles reconnection scenarios."
Q02-09,"Database Cleanup Task Review","Review includes/database/Tasks/DatabaseCleanupTask.php for proper WP-Cron integration, batch processing, error recovery, and progress tracking. Check for timeout handling on long-running cleanups."
Q03-01,"Media Scanner Review","Review includes/media/Scanner.php for efficient media library scanning, proper detection of unused/duplicate/large files, batch processing with generators, and memory management for large libraries."
Q03-02,"Media Duplicate Detector Review","Review includes/media/DuplicateDetector.php for accurate duplicate detection algorithm (hash-based vs content-based), handling of different image sizes, and performance with large media libraries."
Q03-03,"Media Large Files Review","Review includes/media/LargeFiles.php for configurable threshold detection, proper size calculation, handling of different file types, and integration with optimization recommendations."
Q03-04,"Media Alt Text Checker Review","Review includes/media/AltTextChecker.php for accurate detection of missing alt text, handling of decorative images, multilingual support (WPML/Polylang), and accessibility compliance reporting."
Q03-05,"Media Safe Delete Review","Review includes/media/SafeDelete.php for two-step deletion mechanism, 30-day recovery window implementation, proper file system cleanup, and thumbnail handling. Verify recovery actually works."

thinking
**Reviewing scheduler contracts**

I'm diving into Q08 tasks, specifically Q08-03, which relates to scheduler contracts. These seem to be about small improvements, like updating interface documentation and adding constants or methods for extensibility. I see this involves reviewing the SchedulableInterface and SchedulerRegistryInterface definitions and possibly modifying contracts to align with the Interface Segregation Principle (ISP). I'm not entirely certain, but I should check other interface definitions in includes/Contracts for established patterns. Let's inspect those!
exec
/bin/zsh -lc 'ls -la includes/Contracts | head' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
total 208
drwxr-xr-x@ 26 ahmedyounis  staff   832 Jan 16 09:15 .
drwxr-xr-x@ 28 ahmedyounis  staff   896 Jan 16 22:08 ..
-rw-r--r--@  1 ahmedyounis  staff  2710 Jan 16 03:33 ActivityLoggerInterface.php
-rw-r--r--@  1 ahmedyounis  staff  1344 Jan 16 07:11 AltTextCheckerInterface.php
-rw-------@  1 ahmedyounis  staff  3433 Jan 16 01:04 AnalyzerInterface.php
-rw-r--r--@  1 ahmedyounis  staff  2014 Jan 16 07:11 AutoloadAnalyzerInterface.php
-rw-------@  1 ahmedyounis  staff  3685 Jan  7 21:42 CacheInterface.php
-rw-r--r--@  1 ahmedyounis  staff  1859 Jan 16 03:32 ConfigurationInterface.php
-rw-------@  1 ahmedyounis  staff  7393 Jan 16 09:08 ConnectionInterface.php
exec
/bin/zsh -lc "sed -n '1,120p' includes/Contracts/ActivityLoggerInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
<?php
/**
 * Activity Logger Interface
 *
 * Contract for activity logging operations.
 *
 * @package WPAdminHealth\Contracts
 */

namespace WPAdminHealth\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface ActivityLoggerInterface
 *
 * Defines the contract for logging scan and cleanup activities.

thinking
**Looking into task progress queries**

I'm considering if there's a UI or REST method to check the progress of scheduled tasks. I think I should search for "has_pending_progress" usage to see how it might be implemented. I wonder if this function can give me the information I need or if there are other methods available. It's important for me to understand how to effectively track scheduled tasks!
exec
/bin/zsh -lc "rg -n \"has_pending_progress\\(\" -S includes tests" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 75ms:
includes/Scheduler/AbstractScheduledTask.php:318:	public function has_pending_progress(): bool {



thinking
**Evaluating interface design**

I’m noticing a potential issue with the interface in that it performs an ABSPATH check and terminates. This is common in WordPress, but it might be a bit unconventional for interfaces. I’m also considering whether we should specify return and parameter types in phpdoc. There's a question about handling tasks that aren't registered. 

While the interface lacks an `unregister` method for extensibility, it could be useful to allow removing tasks. There are existing methods like `register`, `get_enabled`, and `execute`, but no clear way to unregister tasks.
thinking
**Reviewing contract definitions**

The specification indicates that I should focus only on reviewing contract definitions, not the rest of the code, so my modifications will be limited. I’m examining the tasks.md or plan file for more details, but it’s just one line. 

For the SchedulableInterface, I aim to define constants for standard result keys and update the `execute` documentation to include those keys like `task_id`, `executed_at`, and possibly `error`. I’m considering providing a typed alias for the result array and introducing a method like `get_default_frequency`, specifying supported values such as `'daily'`, `'weekly'`, and `'monthly'`. I want to ensure that the documentation reflects these changes accurately.
thinking
**Ensuring proper abstraction**

I see that the spec emphasizes the need for proper abstraction and extensibility, which means I shouldn't enforce a rigid structure. The method `get_settings_schema` might be too generic. 

For the SchedulerRegistryInterface, I plan to include capabilities like retrieving hooks, scheduling and unscheduling tasks, getting the next run, handling hooks, and obtaining task definitions categorized by type. These methods might be necessary for other components later on, and I notice the interface appears incomplete. I need to check if there are any type hints in the code that reference this interface, potentially causing some static analysis issues or IDE complaints.
exec
/bin/zsh -lc "rg -n \"->get_task_hook\\(\" -S includes tests docs | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
rg: unrecognized flag ->
exec
/bin/zsh -lc "rg -n \"get_task_hook\\(\" -S includes tests docs | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 76ms:
includes/Scheduler/SchedulerRegistry.php:115:	public function get_task_hook( string $task_id ): string {
includes/Scheduler/SchedulerRegistry.php:292:		$hook = $this->get_task_hook( $task_id );
includes/Scheduler/SchedulerRegistry.php:442:				'hook'              => $this->get_task_hook( $task->get_task_id() ),
includes/Scheduler/SchedulerRegistry.php:461:		$hook = $this->get_task_hook( $task_id );
includes/Scheduler/SchedulerRegistry.php:492:		$hook = $this->get_task_hook( $task_id );
includes/Scheduler/SchedulerRegistry.php:509:		$hook = $this->get_task_hook( $task_id );

thinking
**Exploring interface functionality**

I'm considering whether adding to the interface will disrupt its current functionality. I need to think about other uses, like schedule_task or get_next_run. Maybe they’re utilized in the UI. I should search for how `get_next_run` is being used. I want to make sure everything integrates smoothly and works correctly. It's essential to ensure that no issues arise with any existing features during this process. I'll dive into this further!
exec
/bin/zsh -lc "rg -n \"get_next_run\\(\" -S includes tests docs | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 71ms:
includes/Scheduler/SchedulerRegistry.php:443:				'next_run'          => $this->get_next_run( $task->get_task_id() ),
includes/Scheduler/SchedulerRegistry.php:508:	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int {





thinking
**Evaluating scheduling logic**

I'm dealing with the logic from SchedulerRegistry. It does provide a method to schedule tasks by their ID, yet SettingsServiceProvider seems to bypass it. Maybe it existed before the registry's scheduling method, or perhaps task schedules are independent of it? Actually, since SettingsServiceProvider is about plugin settings, it reschedules tasks when settings change but relies on WP cron directly. The scheduler registry already has methods for scheduling based on IDs, and its task hooks match the names used by the settings provider, so it could work! Hmm, I wonder if keeping them separate was intentional to avoid dependency. For better extensibility, unifying the scheduling through the registry interface might help avoid duplication and problems.
thinking
**Improving scheduling extensibility**

To enhance extensibility, I should consider having SettingsServiceProvider utilize SchedulerRegistryInterface for scheduling tasks, instead of using its own implementations. This would mean updating the interface to include methods like schedule_task and unschedule_task, which makes sense. It aligns with keeping proper abstraction in mind. Currently, the scheduler registry handles task registration and execution while SettingsServiceProvider separately manages scheduling, leading to duplicated logic. By extending the interface to include relevant scheduling methods, I can refactor SettingsServiceProvider to rely on the registry, enhancing abstraction and allowing for customization of the scheduling mechanism.
thinking
**Considering abstraction updates**

The spec references the contracts folder, not directly addressing SettingsServiceProvider. To ensure proper abstraction and extensibility, there might be a need to update the code usage. However, it's possible that Q08-03 is solely about reviewing contracts, which could mean no refactoring is necessary elsewhere. But if we expand the interface to include methods like schedule_task, I'd have to assess where registry usage needs updating. It’s a big file, but I could simplify things by keeping the current functions while integrating the registry. Ideally, I would modify SettingsServiceProvider to accept the scheduler registry and utilize its methods for handling tasks, enhancing its functionality.
thinking
**Refactoring task scheduling**

I’m considering changing the approach to use task IDs and call registry methods. First, I need to determine the `preferred_time` and compute the `next_run`. For each task configuration, I'd call `$registry->schedule_task($task_id, $new_frequency, $next_run`, ensuring the registry expects frequency values like "daily," "weekly," or "monthly." While the SettingsServiceProvider currently handles disabled tasks, we can leverage the registry’s unschedule_task method to manage these tasks effectively. When the scheduler is disabled, unscheduling each known task ID is necessary, so I can call `registry->get_all()` to ensure everything is accounted for. Since handle_scheduling_update gets triggered when options change, the registry should be available in the service provider when options are updated.
thinking
**Analyzing task scheduling updates**

I'm considering that handle_scheduling_update might run during options updates, which raises concerns about whether tasks will be registered by then. However, the methods schedule_task and unschedule_task operate on hooks, meaning task registration isn't required. They rely on the get_task_hook method, allowing me to schedule using task IDs regardless of registration.

Currently, it's important to ensure the task configurations use hook names correctly, like 'wpha_database_cleanup' for the task_id 'database_cleanup.' While built-in tasks are manageable, custom tasks registered through plugins might not conform to this naming. I wonder if the settings should automatically schedule all registered tasks to enhance extensibility. 

There's also the option of exposing a TASK_HOOK_PREFIX constant in the interface to streamline that process. Additionally, I ponder the organization of options like frequency being better suited in the scheduler registry rather than within task definitions.
exec
/bin/zsh -lc 'rg -n "scheduled" docs/developers/rest-api.md | head -n 80' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
899:		"status": "scheduled",
900:		"message": "Media scan has been scheduled to run in the background."
902:	"message": "Media scan scheduled successfully."
exec
/bin/zsh -lc "sed -n '820,960p' docs/developers/rest-api.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
{
	"success": true,
	"data": {
		"items": [
			{
				"id": 150,
				"filename": "large-image.jpg",
				"size": 2097152,
				"size_formatted": "2 MB",
				"dimensions": "3000x2000",
				"thumbnail_url": "https://example.com/.../large-image-150x150.jpg",
				"edit_link": "https://example.com/wp-admin/post.php?post=150&action=edit"
			}
		],
		"total": 12,
		"cursor": null,
		"has_more": false
	},
	"message": "Large files retrieved successfully."
}

thinking
**Investigating media scan scheduling**

I'm exploring how the media scan endpoint triggers background tasks. It seems it could be using the Action Scheduler instead of the scheduler registry. I wonder if the scheduler registry contract should allow for on-demand scheduling, like running tasks once in the background. I need to check the actual media scan REST controller for scheduling. I'll search the code for `POST /wpha/v1/media/scan`, possibly in the MediaController or MediaCleanupController files.
exec
/bin/zsh -lc 'rg -n "media/scan" -S includes/REST | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 73ms:
includes/REST/Media/MediaScanController.php:39:	protected $rest_base = 'media/scan';
includes/REST/Media/MediaScanController.php:74:		// POST /wpha/v1/media/scan - Trigger full media scan.
includes/REST/MediaController.php:262:		// POST /wpha/v1/media/scan - Trigger full media scan.

thinking
**Inspecting scheduling mechanism**

I need to take a closer look at the MediaScanController to understand how its scheduling mechanism works and how it relates to the scheduler registry. It sounds like there might be a connection that could help clarify the overall functionality. Let’s analyze the code structure and see how these components interact! I’m curious to find out if there are specific methods or properties that highlight their relationship.
exec
/bin/zsh -lc "sed -n '1,220p' includes/REST/Media/MediaScanController.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:
<?php
/**
 * Media Scan REST Controller
 *
 * Handles media scanning operations.
 *
 * @package WPAdminHealth\REST\Media
 */

namespace WPAdminHealth\REST\Media;

use WP_REST_Request;
use WP_REST_Response;
use WP_Error;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\SettingsInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\REST\RestController;

// Exit if accessed directly.

thinking
**Improving task scheduling**

I'm considering how the scheduler registry contract could have a method like `get_task_hook`, which would let controllers schedule tasks without hardcoding specific hook strings. For instance, the MediaScanController currently uses the string 'wpha_media_scan', but it could call registry->get_task_hook('media_scan' ) to reduce duplication. This would enhance extensibility. I should also search for other instances like 'wpha_database_cleanup' to see if there are similar opportunities. Let's look for occurrences of 'wpha_media_scan'.
exec
/bin/zsh -lc "rg -n \"'wpha_(database_cleanup|media_scan|performance_check)'\" -S includes | head -n 100" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 74ms:
includes/REST/Media/MediaScanController.php:100:			as_enqueue_async_action( 'wpha_media_scan', array(), 'wpha_media' );
includes/REST/MediaController.php:675:			as_enqueue_async_action( 'wpha_media_scan', array(), 'wpha_media' );
includes/Settings/SettingsServiceProvider.php:841:			'wpha_database_cleanup'  => array(
includes/Settings/SettingsServiceProvider.php:846:			'wpha_media_scan'        => array(
includes/Settings/SettingsServiceProvider.php:851:			'wpha_performance_check' => array(
includes/Settings/SettingsServiceProvider.php:1011:		$hooks = array( 'wpha_database_cleanup', 'wpha_media_scan', 'wpha_performance_check' );
includes/Installer.php:300:			'wpha_database_cleanup'  => array(
includes/Installer.php:305:			'wpha_media_scan'        => array(
includes/Installer.php:310:			'wpha_performance_check' => array(
includes/Installer.php:581:			'wpha_database_cleanup',
includes/Installer.php:582:			'wpha_media_scan',
includes/Installer.php:583:			'wpha_performance_check',
exec
/bin/zsh -lc "sed -n '240,360p' includes/Installer.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
		return true;
	}

	/**
	 * Set plugin version in options.
	 *
	 * @since 1.0.0
	 *
	 * @return void
	 */
	private static function set_version() {
		update_option( self::VERSION_OPTION, WP_ADMIN_HEALTH_VERSION );
	}

	/**
	 * Schedule initial tasks on fresh install.
	 *
	 * Since update_option_{$option} hook doesn't fire when an option is first
	 * created (only when an existing option is updated), we need to manually
	 * schedule initial cron tasks based on default settings.
exec
/bin/zsh -lc 'rg -n "cron_schedules" -S includes | head -n 80' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 58ms:
includes/Installer.php:270:			'cron_schedules',
includes/Settings/SettingsServiceProvider.php:136:		add_filter( 'cron_schedules', array( $this, 'register_cron_schedules' ) );
includes/Settings/SettingsServiceProvider.php:298:	public function register_cron_schedules( array $schedules ): array {
exec
/bin/zsh -lc "sed -n '120,340p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 49ms:
			}
		);

		$this->container->bind(
			'settings.advanced',
			function () {
				return new AdvancedSettings();
			}
		);
	}

	/**
	 * {@inheritdoc}
	 */
	public function boot(): void {
		// Register custom cron schedules for weekly and monthly intervals.
		add_filter( 'cron_schedules', array( $this, 'register_cron_schedules' ) );

		// Register WordPress settings hooks.
		add_action( 'admin_init', array( $this, 'register_settings' ) );





thinking
**Evaluating task scheduling**

I'm examining how the `schedule_initial_tasks` function in Installer adds a filter to ensure schedules exist. If I switch to using `SchedulerRegistry` for scheduling tasks, I need to ensure the same filter is included. It seems that refactoring `Installer schedule_single_task` to utilize `SchedulerRegistry` could work, though Installer’s static methods don't need a container. It looks like I can instantiate `SchedulerRegistry`, which doesn't require certain constants but involves locks for task management. However, I'm contemplating whether to change existing task arrays or keep it simple with the static method.
thinking
**Clarifying spec requirements**

I see that the specification is about contract reviews rather than removing duplicates. If I update the scheduler registry interface to include methods like `schedule_task`, I might need to actually implement those methods. But it doesn't seem necessary. To fully address the spec, I should ensure the contracts are in order. This might mean updating interface definitions and docblocks or even creating a new interface for optional methods. It’s crucial to consider the principles of interface segregation and extensibility without overcomplicating things. The `SchedulableInterface` currently requires tasks to define various attributes like UI name and settings.
thinking
**Refining the Schedulable concept**

I'm thinking that the "Schedulable" concept might be overloaded. A task could be schedulable without needing settings, so returning a default stub could work. However, if someone wants a custom schedulable task outside the plugin settings UI, those methods still need to be provided. One idea I have is to separate into two interfaces: the `SchedulableInterface` for scheduling and execution methods like `get_task_id()` and `execute(array $options): array`, and the `TaskDefinitionInterface` for UI aspects like `get_task_name()` and `get_description()`. Tasks would implement both or extend from a base, allowing minimalist implementations when features aren't needed. But I need to consider whether any existing code expects the task name or description. The registry currently relies on that information. To improve extensibility, I could ensure those calls are only made if a task implements the new interface, providing defaults otherwise. This approach would mean updating the code and tests, though.
thinking
**Assessing abstraction and extensibility**

I'm considering that making the interfaces more manageable could align with the specification regarding proper abstraction and extensibility. Currently, the registry requires specific methods from tasks, which might not always be necessary. While the specification doesn’t explicitly mention Interface Segregation Principle (ISP), the focus seems to be on creating smaller, more specific interfaces. Given that tasks may also involve progress tracking, it might be beneficial to implement a `ProgressAwareInterface` that includes methods like `get_progress()` and `has_pending_progress()`. This would improve UI interactions and ensure that tasks can handle progress/resumable features more effectively.
thinking
**Exploring optional interface for progress**

Right now, it looks like there's no usage for a progress interface, but maybe we could define one in the Contracts folder. The specification only mentions `SchedulableInterface` and `SchedulerRegistryInterface`, yet creating a new interface could support extension without altering the current ones. While the spec doesn't explicitly require it, introducing a new interface might still be beneficial but should be minimal. Alternatively, I could modify `SchedulableInterface` to add optional progress methods, but that could require all tasks to implement them. Since tasks based on `AbstractScheduledTask` already handle progress, a separate interface feels better. I'm also checking tasks like `DatabaseCleanupTask` and `MediaScanTask`, which have progress tracking, while `PerformanceCheckTask` has methods that return empty values. It may be worth searching the documentation for any details about progress.
exec
/bin/zsh -lc 'rg -n "progress" docs -S | head -n 80' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 71ms:
docs/getting-started.md:128:_Screenshot: Health score calculation in progress_
docs/database-cleanup.md:1263:3. **Monitor progress:**
docs/database-cleanup.md:1334:- Monitor the progress
docs/performance.md:1220:- Course/lesson progression tracking
docs/performance.md:1241:5. **Background Process Progress**: Use Action Scheduler for lesson completion
docs/performance.md:1439:4. **Report Progress**: Show stakeholders performance improvements

thinking
**Examining interface completeness**

I don't think the scheduler progress is the main focus right now. It seems better to concentrate on the completeness of the scheduler registry interface. I’m considering looking at other contract interface designs. I might find definitions for things like `get_prefix` or the usage of `@phpstan-return array<string,mixed>` in the includes/Contracts. Maybe opening up different interfaces, like `CacheInterface`, could reveal useful patterns.
exec
/bin/zsh -lc "sed -n '1,160p' includes/Contracts/CacheInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 27ms:
<?php
/**
 * Cache Interface
 *
 * Contract for caching operations.
 *
 * @package WPAdminHealth\Contracts
 */

namespace WPAdminHealth\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface CacheInterface
 *
 * Defines the contract for caching operations. Implementations can use
exec
/bin/zsh -lc 'rg -n "execute_registered_task" -S docs includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 74ms:
includes/Providers/SchedulerServiceProvider.php:185:		add_action( 'wpha_execute_registered_task', array( $this, 'execute_registered_task' ), 10, 2 );
includes/Providers/SchedulerServiceProvider.php:195:	public function execute_registered_task( $task_id = '', $options = array() ): void {
includes/Providers/SchedulerServiceProvider.php:212:		$this->execute_registered_task( 'database_cleanup' );
includes/Providers/SchedulerServiceProvider.php:221:		$this->execute_registered_task( 'media_scan' );
includes/Providers/SchedulerServiceProvider.php:230:		$this->execute_registered_task( 'performance_check' );
exec
/bin/zsh -lc "rg -n \"as_enqueue_async_action\\( 'wpha_\" -S includes/REST | head -n 100" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 75ms:
includes/REST/Media/MediaScanController.php:100:			as_enqueue_async_action( 'wpha_media_scan', array(), 'wpha_media' );
includes/REST/MediaController.php:675:			as_enqueue_async_action( 'wpha_media_scan', array(), 'wpha_media' );


thinking
**Reviewing testing commands**

I’m considering that the media scan uses the scheduler registry for scheduled tasks rather than immediate ones. I wonder if interface changes will affect JavaScript—hmm. I think I can make adjustments to interface definitions and refactor the scheduling code to cut down on duplication. Gotta be careful not to break anything! I'll plan to run `npm run lint`, `npm test`, and possibly `phpunit`, even if the user didn’t specifically ask for that. We should follow approval policies too.
thinking
**Checking agent instructions**

So, the user seems to expect us to run specific tests, but I wonder if we could run additional ones even though they indicated they'd only prefer non-empty checks. I could run `composer test` since it might work with phpunit, but it could take time. I need to examine the other AGENTS instructions they provided. They’ve mentioned root instructions about skills, but I should probably look for the actual AGENTS.md file in the repository to see what else I might find. Let's check that!
exec
/bin/zsh -lc 'find .. -name AGENTS.md -print' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 25.87s:
../DeliverPlan/AGENTS.md
../lamie/lamie-frontend/AGENTS.md
../lamie/lamie-backend/AGENTS.md
../FlowReviewFrontend-worktree-C/AGENTS.md
../wooflow-guard/AGENTS.md
../FlowReviewFrontend-worktree-B/AGENTS.md
../clientora/AGENTS.md
../NovaSaaS/AGENTS.md
../whatsapp-commerce-hub/vendor/wp-cli/i18n-command/AGENTS.md
../lumina/AGENTS.md
../wltv-analytics/AGENTS.md
../FlowReviewFrontend-worktree-A/AGENTS.md
../FlowReviewFrontend/AGENTS.md
../pseo-pro/AGENTS.md

thinking
**Implementing updates**

I'm noticing that the AGENTS.md file isn't present in this repo, and it seems to be in other directories instead. Since I only have the user's instructions to follow, I'll proceed based on those. Right now, it's time to focus on updating plan statuses. I've completed step 1 of reading the specifications, so I’ll mark that as done and move forward to step 2, which is currently in progress. Let's keep things organized!
Plan update
  ✓ Read spec and handoff docs
  → Inspect current code paths
  • Implement required changes
  • Add/update tests as needed
  • Run lint and tests
  • Summarize and hand off



thinking
**Clarifying interface constants in PHP**

In PHP, implementing classes don’t automatically inherit interface constants, which must be accessed as `InterfaceName::CONSTANT`. It's worth noting that interface constants don't require the class to redefine them, but we can use them as default parameters if desired. Ensuring method signature compatibility is key—for example, if an interface method has a default value, the corresponding class method must align. If I define a constant for tasks, it’s not required for method signatures, though it could be useful. Lastly, I might think about splitting `SchedulableInterface` to streamline methods, though it will involve additional code changes.
thinking
**Considering interface modifications**

I’m thinking about whether we really need to adjust the interface for "proper abstraction and extensibility.” The specifications focus on reviewing contracts, which I want to handle with minimal changes that still enhance abstraction. It’s simple to update docblocks and add missing registry methods, which improves the completeness of the contract. However, I should also think about refining overly specific documentation and modifying `get_settings_schema` to return an array more flexibly. It’s possible to change the return of `SchedulerRegistryInterface::execute`, but I need to be careful as it could break the method signature.
thinking
**Evaluating method return types**

I’m considering the implications of having the `execute` method return null versus an array. While returning null may be inconvenient for extensibility, changing it would mean I need to check all call sites, even though there might not be many—maybe just tests? It seems safer to make the method always return an array, indicating errors when a task isn’t found. Although this change isn’t spec-required, I suspect there might be a bug where returning null can lead to issues. I should investigate where `$registry->execute(` is being used.
exec
/bin/zsh -lc "rg -n \"->execute\\(\\s*\\"'$" -S includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 71ms:
rg: unrecognized flag ->
exec
/bin/zsh -lc "rg -n \"->execute\\(\" includes | head -n 80" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
rg: unrecognized flag ->

thinking
**Clarifying command options**

I’m noticing that `rg` interprets `->execute` as a flag because it starts with a dash. To fix this, I’ll need to use `--` to indicate the end of the options or quote the string and use `rg -- "->execute"`. If I don’t, `rg` will view `->execute` as an option. So, I might need to use `rg -n -- \"->execute\\(\" includes as a workaround. It's a bit tricky, but I think I can manage!
exec
/bin/zsh -lc "rg -n -- \"->execute\\(\" includes | head -n 80" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 78ms:
includes/Scheduler/SchedulerRegistry.php:197:			$result = $task->execute( $options );
includes/Scheduler/SchedulerRegistry.php:282:		$this->execute( $task_id, $options );
includes/Providers/SchedulerServiceProvider.php:203:		$registry->execute( $task_id, $options );

thinking
**Considering frequency constants**

I might mention that handling 'disabled' is linked to scheduler settings, but the default tasks could be set to something like 'daily', 'weekly', or 'monthly'. It seems defining constants for those would be beneficial, improving consistency and avoiding string duplication. I think tasks already use strings, but introducing constants could enhance extensibility without breaking anything. It’s a low-risk approach, and I'll check if other interfaces define constants by searching for `const`.
exec
/bin/zsh -lc "rg -n \"interface .*\\{\\n\\s*const\" -S includes/Contracts includes/Scheduler/Contracts | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 43ms:
rg: the literal "\n" is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.




thinking
**Evaluating frequency constants**

I’m considering adding frequency constants to the `SchedulableInterface` since that’s where the default frequency exists. I wonder if I should also include `FREQUENCY_DISABLED`. But, then I notice the scheduler uses the string `'disabled'` to unschedule, which feels more related to the scheduling frequency. 

Maybe I could define a constant in `SchedulerRegistryInterface` instead to avoid duplication. Still, I'm thinking a new small class `SchedulerFrequencies` could hold these constants, but that might feel excessive.
thinking
**Defining schedule frequencies**

I'm thinking it would be simpler to add constants for schedule frequencies in `SchedulableInterface`, like `FREQUENCY_DAILY`, `FREQUENCY_WEEKLY`, and `FREQUENCY_MONTHLY`. 

In `SchedulerRegistryInterface`, I could define `FREQUENCY_DISABLED` as `'disabled'` and maybe reference other constants from `SchedulableInterface`. But I realize that could couple them too closely, even if the values are identical. I should ensure that adding these constants doesn't break anything, and it's definitely not a PHP8 requirement. 

I also need to update the docblocks for `is_enabled` and consider settings for tasks too. I’ll document `get_settings_schema` to specify it returns an array. Finally, I’ll update `SchedulerRegistryInterface` with the new methods and docblocks, ensuring they include generics.
thinking
**Updating SchedulerRegistry class**

I need to update the `SchedulerRegistry` class to implement the interface for the new methods and include proper docblocks. Wait, the class already has these methods, but since PHP enforces interface signature matching, I must ensure the class method signatures align exactly after updating the interface.

So I’ll check several methods, including `register`, `get_task_hook`, `get`, and quite a few others to ensure everything exists and matches. I'm happy to see that most methods are already okay, but I need to ensure the parameter types are correctly defined.
thinking
**Evaluating constant definitions**

I'm considering how the interface defines a constant while the default uses `self::ACTION_SCHEDULER_GROUP`, which seems to be the same value. 

Next, I verify that methods like `unschedule_task` and `get_next_run` exist. But I realize that the method `get_task_hook` isn’t currently annotated with `@inheritdoc`; the class has it, but the interface doesn’t. I’ll add that to the interface, which should be fine. While some methods are now required to be public due to the interface, I need to confirm if there are any other classes implementing `SchedulerRegistryInterface`, though I suspect it's probably just `SchedulerRegistry`.
exec
/bin/zsh -lc "rg -n \"implements\\s+SchedulerRegistryInterface\" -S includes tests" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 55ms:
includes/Scheduler/SchedulerRegistry.php:28:class SchedulerRegistry implements SchedulerRegistryInterface {
exec
/bin/zsh -lc "rg -n \"implements\\s+SchedulableInterface\" -S includes tests" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
includes/Scheduler/AbstractScheduledTask.php:26:abstract class AbstractScheduledTask implements SchedulableInterface {





thinking
**Evaluating task implementation**

I'm considering the structure of my abstract class where tasks extend it. If we make changes to the interface, I’d need to update the AbstractScheduledTask for any new methods. But honestly, it seems we won't add many. I think the revisions will be focused on interface documentation and adding methods to the registry interface. I’m also pondering if defining type for task definitions in `SchedulerRegistryInterface` would help for clarity. Then I’ll need to craft the proper PHP doc for `get_task_definitions`.
thinking
**Considering provider closure**

I'm observing that the provider closure currently creates a `SchedulerRegistry` and uses `set_connection` directly, not through the interface. If someone changes the container binding, they might disrupt the provider. For better extensibility, it seems `SchedulerRegistryInterface` could include `set_connection` to allow connection injection in different implementations, but it’s currently just used for locking operations. Since it defaults to using global $wpdb when not set, maybe it doesn't need to be part of the interface. However, for testability, it could be useful, but it’s not essential to the registry's core functionality.
thinking
**Modifying interfaces**

I'm considering adding `get_task_hook` and similar methods. But I don’t need to update the documentation or hooks at this moment. Next, I’ll implement modifications by updating the interface files using `apply_patch`. Specifically, I’ll focus on `SchedulableInterface.php` and `SchedulerRegistryInterface.php`, making sure to keep the style intact with header comments and `@package` notation.

For `SchedulableInterface`, I’ll add new constants at the top. I have an idea to include a frequency slug for daily runs, but regarding docblocks, I’m wondering if we should include the `@var` annotation since the constant is not typed. It seems we can still use a docblock here, so I’ll proceed accordingly.
thinking
**Expanding interfaces**

I can add constants for daily, weekly, and monthly frequencies. I think it would also be beneficial to include a docblock at the interface level and update the `get_default_frequency` documentation to mention these new constants. 

I should remove `custom_days` while updating the `execute` documentation to indicate it returns an array with recommended keys. I might note that tasks can add their own as well. 

Now for `SchedulerRegistryInterface`, I’m considering reorganizing the methods in a more logical order, possibly placing `handle_task_hook` after `get_task_hook` since it executes tasks as a WP hook.
thinking
**Reorganizing the interface**

I'm focusing on improving the interface for tasks registry and scheduling. I think the order of methods could be: register, get_task_hook, handle_task_hook, get, get_all, has, get_enabled, get_by_category, get_task_definitions, schedule_task, unschedule_task, get_next_run, and execute. However, I might want to keep existing methods at the top and append new ones to minimize changes.

Also, I'm considering adding constants for `ACTION_SCHEDULER_GROUP` and `TASK_HOOK_PREFIX`, which might enhance clarity when adjusting method signatures. I realize I need to update the plan statuses and run PHP syntax checks or tests, as changes could introduce errors.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -22,2 +22,13 @@
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
@@ -26,2 +37,29 @@
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
@@ -49,3 +87,6 @@
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
@@ -57,3 +98,6 @@
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return array<string, mixed> Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
@@ -71,3 +115,3 @@
 	 *
-	 * @return array Array of setting definitions.
+	 * @return array<string, mixed> Array of setting definitions.
 	 */
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M includes/Scheduler/Contracts/SchedulableInterface.php
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..4b511b7d58135ef3452a8d14f0d8871dd13bb11b
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return array<string, mixed> Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return array<string, mixed> Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }

file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..4b511b7d58135ef3452a8d14f0d8871dd13bb11b
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return array<string, mixed> Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return array<string, mixed> Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }


thinking
**Updating type aliases**

I’m looking at the return documentation for `get_settings_schema`, which currently uses `array<string,mixed>`. I’m thinking it might be better to use a type alias like `TaskSettingsSchema` for clarity, and maybe we should switch to use `@return TaskSettingsSchema`. It's the same situation for `execute`, which also uses `array<string,mixed>`, but we have `TaskExecutionResult` defined too. I might want to standardize these and update the PHPDoc for consistency. Let's patch these!
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -98,3 +98,3 @@
 	 * @param array $options Task options/settings.
-	 * @return array<string, mixed> Result data. For consistency across logging/UI,
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
 	 *                              implementations should include a boolean 'success'
@@ -115,3 +115,3 @@
 	 *
-	 * @return array<string, mixed> Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M includes/Scheduler/Contracts/SchedulableInterface.php
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }

file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }


thinking
**Patching SchedulerRegistryInterface**

I need to update the SchedulerRegistryInterface file. It seems like a straightforward task, but I want to make sure I'm following the correct procedures. I'll double-check the existing code for any dependencies or areas that might need special attention during the patch process. It’s important to avoid introducing any errors! Overall, this should help improve the overall functionality, so I'll get started on that.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -22,2 +22,13 @@
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
@@ -26,2 +37,22 @@
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
@@ -34,2 +65,12 @@
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
@@ -64,2 +105,59 @@
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
@@ -71,2 +169,14 @@
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M includes/Scheduler/Contracts/SchedulerRegistryInterface.php
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }

file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }






thinking
**Clarifying PHP interface constants**

I'm processing how interface constants work in PHP. They’re implicitly public, right? But can I really specify `public const` in interfaces? Actually, I think you can since PHP 7.1, but I'm checking. It seems that while interface constants are always public, declaring `public` is generally possible, but generally, you won’t specify visibility. Until PHP 8.1, interface constants remain public, but wait, visibility for class constants was introduced in 7.1. It's a bit tricky!
thinking
**Verifying PHP environment and code**

I'm feeling a bit uncertain, so I think I need to check things by running `php -l` and `php -v`. Composer requires PHP >=7.4, and my code uses typed properties, which means the environment may be on 8.x. I remember that `public const` is valid for class constants in versions 7.1 and up, which I think applies to interface constants too, but I need to verify it. Oh, and we've added `@var string` docblocks for constants, which may not even be needed.
thinking
**Updating SchedulerRegistryInterface references**

I think we need to consider updating any references to SchedulerRegistryInterface since it now includes constants, which we could potentially use. However, I'm not entirely sure if we need to refactor duplication just yet. After modifying the interface, I should also double-check that no other code is extending it with incompatible definitions. Running the PHP linter or PHPUnit will help ensure everything is compatible. Before jumping into tests, I’m wondering if we should adjust the documentation or update tasks to utilize the new constants.
thinking
**Interpreting abstraction and extensibility**

I think we can interpret "proper abstraction and extensibility" to mean that SchedulerRegistryInterface should have the methods that the SchedulerRegistry class exposes for use by other parts. Meanwhile, SchedulableInterface shouldn’t be tied to specific implementation details, like custom_days or keys, which we've already addressed. I could adjust the `get_settings_schema` doc to reflect `TaskSettingsSchema` accordingly. To be thorough, I might also want to update documentation where custom_days are mentioned, even though we've removed those references.
thinking
**Validating updated files with PHP linter**

I think it's time to run `php -l` on the updated files to check for parsing issues. I’ll specifically check `includes/Scheduler/Contracts/SchedulableInterface.php` and other related files as needed. This will help me ensure everything is in order and correctly parsed after the updates. It’s a good step to catch any potential errors before moving on with further developments or testing. Let’s get that done!
exec
/bin/zsh -lc 'php -l includes/Scheduler/Contracts/SchedulableInterface.php && php -l includes/Scheduler/Contracts/SchedulerRegistryInterface.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 130ms:
No syntax errors detected in includes/Scheduler/Contracts/SchedulableInterface.php
No syntax errors detected in includes/Scheduler/Contracts/SchedulerRegistryInterface.php
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }



thinking
**Analyzing PHP compilation**

When I run `php -l file.php`, it checks the syntax and compiles the file without executing it. This means it might not require interface definitions if they aren't in the same file. However, if a class implements an undefined interface, a fatal error occurs at runtime, producing an “Interface 'X' not found” message. Since `php -l` doesn't run the code, it won't catch signature mismatches. To ensure compatibility, I should run `php -r` with autoload or use PHPUnit later.
thinking
**Checking interface compatibility**

It seems that modifications to the interface could lead to a fatal error if the class doesn't match, but it ideally should. I might consider running `php -r "require 'includes/autoload.php'..."` to leverage composer autoloading. However, a simpler approach could be running `php -r "require 'includes/Scheduler/Contracts/SchedulerRegistryInterface.php'; require 'includes/Scheduler/SchedulerRegistry.php';"`, but these files check for the ABSPATH constant. If it's not set, they’ll cause an error. So, I'll manually define ABSPATH in the command and check for fatal errors in the interfaces. Let's do that quick test!
exec
/bin/zsh -lc "php -r \"define('ABSPATH', __DIR__ . '/'); require 'includes/Scheduler/Contracts/SchedulableInterface.php'; require 'includes/Scheduler/Contracts/SchedulerRegistryInterface.php'; require 'includes/Scheduler/AbstractScheduledTask.php'; require 'includes/Scheduler/SchedulerRegistry.php'; echo 'loaded';\"" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 87ms:
loaded
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }



thinking
**Reviewing project steps**

I’m assessing interface compatibility and wondering if we need to update our plan for step three. We've implemented the required changes, so I’m considering other tasks like adjusting the code for interface methods, even though it might not be necessary. The spec suggests verifying abstraction and extensibility, which could involve updating documentation to avoid duplication. So far, we've only changed contracts, which seems sufficient. Steps two and three are mostly completed, but we might consider tests or documentation updates.
thinking
**Updating project steps**

I'm considering adding minimal PHPUnit tests to verify that the interface has methods, even if the spec may not require them. We should run npm lint and tests for step five, but for step four, adding tests might not be necessary. I need to mark it as in progress first, following the guidelines. Although creating tests for the scheduler registry might seem trivial, we can ensure coverage. So, I’ll mark step three as completed and set step four to in progress for now.
Plan update
  ✓ Read spec and handoff docs
  ✓ Inspect current code paths
  ✓ Implement required changes
  → Add/update tests as needed
  • Run lint and tests
  • Summarize and hand off
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }


thinking
**Deciding on tests for changes**

I'm considering whether tests are needed for the changes to interface documentation and methods. While PHP unit tests could validate these, it might not be necessary. I wonder if static analysis tasks would suffice. Adding a small PHP unit test for the schedule methods could ensure functionality, but that feels redundant. It’s a small change, and the guidelines suggest adding tests only if it makes sense. So, I think we can mark this step as completed without additional tests.
Plan update
  ✓ Read spec and handoff docs
  ✓ Inspect current code paths
  ✓ Implement required changes
  ✓ Add/update tests as needed
  → Run lint and tests
  • Summarize and hand off
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }


thinking
I'm going to run the npm run lint command followed by npm test. I plan to use shell_command for this, even though I know it might take some time to complete. Testing is such an important step, and linting helps catch any issues before they become problems. I hope everything runs smoothly! Let's see how long this takes; patience is key in these situations. I'm ready for whatever the result brings!
exec
/bin/zsh -lc 'npm run lint' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.47s:

> wp-admin-health-suite@1.0.0 lint
> eslint assets/js --ext .js,.jsx


/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/admin.js
    7:1  warning  Missing JSDoc @param "window" type    jsdoc/require-param-type
    8:1  warning  Missing JSDoc @param "$" type         jsdoc/require-param-type
  276:1  warning  Missing JSDoc @param "message" type   jsdoc/require-param-type
  277:1  warning  Missing JSDoc @param "duration" type  jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/charts.js
  7:1  warning  Missing JSDoc @param "window" type  jsdoc/require-param-type
  8:1  warning  Missing JSDoc @param "$" type       jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/HealthScoreCircle.jsx
  31:30  warning  'score' is missing in props validation    react/prop-types
  31:41  warning  'grade' is missing in props validation    react/prop-types
  31:54  warning  'loading' is missing in props validation  react/prop-types
  57:1   warning  Missing JSDoc @param "timestamp" type     jsdoc/require-param-type
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }


thinking
**Running tests after linting**

I just got a lint exit code 0, which means there are no errors, just warnings. That's good! Now, it’s time to take the next step and run the npm test. I'm curious about whether everything is going to pass without any issues. Let’s see how this goes! It feels nice when everything runs smoothly, but there’s always a tiny bit of anxiety during this stage. Fingers crossed!
exec
/bin/zsh -lc 'npm test' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 2.06s:

> wp-admin-health-suite@1.0.0 test
> jest --passWithNoTests

PASS assets/js/components/QuickActions.test.jsx
PASS assets/js/components/ActivityTimeline.test.jsx
  ● Console

    console.error
      Warning: An update to ActivityTimeline inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at ActivityTimeline (/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/ActivityTimeline.jsx:108:46)
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }


thinking
**Updating progress on tasks**

I see that tests are passing, even with some console warnings, but the exit code is 0, which is good! So, step 5 is done now. I need to update my plan: I've completed step 5, and I'll move on to step 6, which is currently in progress. It feels nice to make progress, but I’ll keep an eye on those warnings to ensure there aren’t any issues later on!
Plan update
  ✓ Read spec and handoff docs
  ✓ Inspect current code paths
  ✓ Implement required changes
  ✓ Add/update tests as needed
  ✓ Run lint and tests
  → Summarize and hand off
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }


thinking
**Considering interface methods**

I’m thinking about how adding interface methods could break semantic versioning for external implementers. It’s also worth noting that some constants in SchedulableInterface may not be utilized. I should mention that there’s an option to refactor the settings/installer to use registry schedule methods, but that’s not mandatory. Another follow-up is aligning other code with the new constants. I believe we can consider this task largely done, as the specifications are satisfied, even if they seem a bit ambiguous. I'll just ensure step six of the plan is completed.
Plan update
  ✓ Read spec and handoff docs
  ✓ Inspect current code paths
  ✓ Implement required changes
  ✓ Add/update tests as needed
  ✓ Run lint and tests
  ✓ Summarize and hand off
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }

exec
/bin/zsh -lc "nl -ba includes/Scheduler/Contracts/SchedulableInterface.php | sed -n '1,140p'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 39ms:
     1	<?php
     2	/**
     3	 * Schedulable Interface
     4	 *
     5	 * Contract for scheduled task implementations.
     6	 *
     7	 * @package WPAdminHealth\Scheduler\Contracts
     8	 */
     9	
    10	namespace WPAdminHealth\Scheduler\Contracts;
    11	
    12	// Exit if accessed directly.
    13	if ( ! defined( 'ABSPATH' ) ) {
    14		die;
    15	}
    16	
    17	/**
    18	 * Interface SchedulableInterface
    19	 *
    20	 * Defines the contract for tasks that can be scheduled.
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }

exec
/bin/zsh -lc "nl -ba includes/Scheduler/Contracts/SchedulerRegistryInterface.php | sed -n '1,220p'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
     1	<?php
     2	/**
     3	 * Scheduler Registry Interface
     4	 *
     5	 * Contract for the scheduler registry that manages schedulable tasks.
     6	 *
     7	 * @package WPAdminHealth\Scheduler\Contracts
     8	 */
     9	
    10	namespace WPAdminHealth\Scheduler\Contracts;
    11	
    12	// Exit if accessed directly.
    13	if ( ! defined( 'ABSPATH' ) ) {
    14		die;
    15	}
    16	
    17	/**
    18	 * Interface SchedulerRegistryInterface
    19	 *
    20	 * Defines the contract for task registration and management.
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }




thinking
**Finalizing the interface response**

I want to reference the file starting at line 17 for clarity. It’s important to mention the risks, like how the expanded interface might break external implementations and the new PHPStan types needing attention, even if it's only documentation. I'll highlight the existing ESLint warnings that were previously there, as `npm run lint` passes with warnings but no errors. I'll ensure to include the commands `npm run lint` and `npm test` in my final response, with the status marked as DONE.
thinking
**Crafting the final response**

I’m putting together a final response in plain text with the necessary sections. I’ll include the status, which will be "Status: DONE." For the summary of changes, I’ll create a bullet list covering updates to `SchedulableInterface` docs and expansion of the `SchedulerRegistryInterface`. Next, I'll outline the verification commands in another bullet list: `npm run lint` and `npm test`. 

For risks and follow-ups, I'll mention the breaking change for third-party implementations and an optional refactor for consistency in scheduling code. Keeping it clear and concise is essential!
thinking
**Finalizing the response**

I’m considering whether to mention the `eslint` warnings, even though it’s not essential. It might be worth noting that while lint shows warnings, there are no errors. I could include this information under the risks section, just to keep the user informed. Keeping the response clear and acknowledging these warnings could be helpful, even if it’s optional. I’ll finalize the response while ensuring everything is concise and organized!
codex
Status: DONE

Summary of changes
- Tightened `SchedulableInterface` contract docs (removed outdated frequency note, documented result/schema expectations) and added frequency constants in `includes/Scheduler/Contracts/SchedulableInterface.php:17`.
- Expanded `SchedulerRegistryInterface` to cover the public scheduling/lookup APIs already provided by `SchedulerRegistry` (hook mapping, scheduling/unscheduling, next-run, task definitions) in `includes/Scheduler/Contracts/SchedulerRegistryInterface.php:17`.

How to verify
- `npm run lint`
- `npm test`

Risks / follow-ups
- Adding methods/constants to `SchedulerRegistryInterface` is a breaking change for any third-party implementations of that interface (none exist in this repo).
- `npm run lint` still reports existing warnings (no errors).
file update:
diff --git a/includes/Scheduler/Contracts/SchedulableInterface.php b/includes/Scheduler/Contracts/SchedulableInterface.php
index 9642dd4c25f5d4d4a404c3b2fa74967d5a269186..f39b6330cce0e9796674b35f748b27654c78648d
--- a/includes/Scheduler/Contracts/SchedulableInterface.php
+++ b/includes/Scheduler/Contracts/SchedulableInterface.php
@@ -20,10 +20,48 @@
  * Defines the contract for tasks that can be scheduled.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskSettingSchema array{
+ *   type: string,
+ *   default: mixed,
+ *   description?: string,
+ *   min?: int|float,
+ *   max?: int|float
+ * }
+ * @phpstan-type TaskSettingsSchema array<string, TaskSettingSchema>
+ *
+ * @phpstan-type TaskExecutionResult array<string, mixed>
  */
 interface SchedulableInterface {
 
 	/**
+	 * Daily frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_DAILY = 'daily';
+
+	/**
+	 * Weekly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_WEEKLY = 'weekly';
+
+	/**
+	 * Monthly frequency slug.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const FREQUENCY_MONTHLY = 'monthly';
+
+	/**
 	 * Get the unique task identifier.
 	 *
 	 * @return string Task identifier.
@@ -47,7 +85,10 @@
 	/**
 	 * Get the default frequency for this task.
 	 *
-	 * @return string Default frequency (daily, weekly, monthly, custom_days).
+	 * Returned values should be a schedule slug compatible with the scheduler
+	 * implementation (e.g. "daily", "weekly", "monthly").
+	 *
+	 * @return string Default frequency slug.
 	 */
 	public function get_default_frequency(): string;
 
@@ -55,7 +96,10 @@
 	 * Execute the scheduled task.
 	 *
 	 * @param array $options Task options/settings.
-	 * @return array Result with 'items_cleaned', 'bytes_freed', and 'success' keys.
+	 * @return TaskExecutionResult Result data. For consistency across logging/UI,
+	 *                              implementations should include a boolean 'success'
+	 *                              key and may include 'items_cleaned', 'bytes_freed',
+	 *                              'task_id', 'executed_at', and 'error'.
 	 */
 	public function execute( array $options = array() ): array;
 
@@ -69,7 +113,7 @@
 	/**
 	 * Get the task settings schema.
 	 *
-	 * @return array Array of setting definitions.
+	 * @return TaskSettingsSchema Array of setting definitions.
 	 */
 	public function get_settings_schema(): array;
 }
diff --git a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
index e578120624e4530d1d288be388f022d28daf3785..fbf24a18a19d340ce5ac0e0a5086c58743dec534
--- a/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
+++ b/includes/Scheduler/Contracts/SchedulerRegistryInterface.php
@@ -20,10 +20,41 @@
  * Defines the contract for task registration and management.
  *
  * @since 1.2.0
+ *
+ * @phpstan-type TaskDefinition array{
+ *   id: string,
+ *   name: string,
+ *   description: string,
+ *   default_frequency: string,
+ *   enabled: bool,
+ *   hook: string,
+ *   next_run: int|null,
+ *   settings_schema: array<string, mixed>
+ * }
  */
 interface SchedulerRegistryInterface {
 
 	/**
+	 * Default Action Scheduler group used for recurring scheduled tasks.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const ACTION_SCHEDULER_GROUP = 'wpha_scheduling';
+
+	/**
+	 * Task hook prefix.
+	 *
+	 * Task IDs are mapped to WordPress hooks using: wpha_{task_id}
+	 *
+	 * @since 1.2.0
+	 *
+	 * @var string
+	 */
+	public const TASK_HOOK_PREFIX = 'wpha_';
+
+	/**
 	 * Register a schedulable task.
 	 *
 	 * @param SchedulableInterface $task Task to register.
@@ -32,6 +63,16 @@
 	public function register( SchedulableInterface $task ): void;
 
 	/**
+	 * Get the WordPress hook name for a task ID.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @return string WordPress hook name.
+	 */
+	public function get_task_hook( string $task_id ): string;
+
+	/**
 	 * Get a registered task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -62,6 +103,63 @@
 	public function get_enabled(): array;
 
 	/**
+	 * Get tasks by category/module.
+	 *
+	 * Categories are derived from the task ID prefix: {category}_{name}
+	 * (e.g. "database_cleanup", "media_scan").
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $category Category name (e.g., 'database', 'media', 'performance').
+	 * @return array<string, SchedulableInterface> Filtered tasks.
+	 */
+	public function get_by_category( string $category ): array;
+
+	/**
+	 * Get all task definitions for REST API or settings UI.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @return array<string, TaskDefinition> Task definitions keyed by task ID.
+	 */
+	public function get_task_definitions(): array;
+
+	/**
+	 * Schedule a task using Action Scheduler when available, falling back to WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id   Task identifier.
+	 * @param string $frequency Frequency (daily, weekly, monthly, disabled).
+	 * @param int    $next_run  Next run timestamp.
+	 * @param string $group     Action Scheduler group.
+	 * @return void
+	 */
+	public function schedule_task( string $task_id, string $frequency, int $next_run, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Unschedule a task from Action Scheduler and WP-Cron.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return void
+	 */
+	public function unschedule_task( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): void;
+
+	/**
+	 * Get the next scheduled run for a task.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param string $task_id Task identifier.
+	 * @param string $group   Action Scheduler group.
+	 * @return int|null Timestamp or null if not scheduled.
+	 */
+	public function get_next_run( string $task_id, string $group = self::ACTION_SCHEDULER_GROUP ): ?int;
+
+	/**
 	 * Execute a task by its ID.
 	 *
 	 * @param string $task_id Task identifier.
@@ -69,4 +167,16 @@
 	 * @return array|null Execution result or null if task not found.
 	 */
 	public function execute( string $task_id, array $options = array() ): ?array;
+
+	/**
+	 * Execute a task from its WP hook.
+	 *
+	 * Intended to be used as the callback for task hooks registered via the registry.
+	 *
+	 * @since 1.2.0
+	 *
+	 * @param mixed $options Optional task options (must be an array).
+	 * @return void
+	 */
+	public function handle_task_hook( $options = array() ): void;
 }

tokens used
177,871
