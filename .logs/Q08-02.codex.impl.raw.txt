**Status:** DONE

**Summary of changes**
- Added long-running task helpers to `includes/Scheduler/AbstractScheduledTask.php` (timeout setup/checks, progress load/save/clear, standardized exception logging + `execute_with_recovery()`).
- Refactored `includes/Database/Tasks/DatabaseCleanupTask.php` and `includes/Media/Tasks/MediaScanTask.php` to use the shared base implementations (removes duplicated timeout/progress/error-recovery code).
- Marked Q08-02 as completed in `.t2/state.json`.

**How to verify**
- `npm run lint`
- `npm test`

**Risks / follow-ups**
- Behavioral change: `time_limit` overrides now accept digit strings (e.g. `"25"`) in addition to ints; should be low-risk.
- No PHP test coverage here; if you want, I can add minimal PHP unit/smoke checks around the new base helpers.

OpenAI Codex v0.86.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite
model: gpt-5.2
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: xhigh
reasoning summaries: auto
session id: 019bcb2e-93c3-7151-97ff-372440a91cb7
--------
user
You are implementing task Q08-02 in this git repository.

1) Read the spec: .plans/Q08-02.md
2) Read handoff/context: .t2/handoff/Q08-02.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: npm run lint
- test: npm test

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers

thinking
**Organizing development steps**

I’m making a plan for the task. First, I’ll read the specifications and handoff details. Then, I need to inspect the current implementation to see how it functions. Next, I’ll implement the necessary changes based on my findings. After that, I can run lint and tests to ensure everything’s in order. Lastly, I'll summarize the results so I can track progress and make updates as necessary. Let’s get started!
Plan update
  → Read spec and handoff
  • Inspect existing code paths
  • Implement required changes
  • Run lint and tests
  • Summarize and hand off
exec
/bin/zsh -lc "ls -la .plans .t2/handoff && echo '--- .plans/Q08-02.md ---' && sed -n '1,200p' .plans/Q08-02.md && echo '--- .t2/handoff/Q08-02.md ---' && sed -n '1,200p' .t2/handoff/Q08-02.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 111ms:
.plans:
total 1024
drwxr-xr-x@ 130 ahmedyounis  staff  4160 Jan 17 00:59 .
drwxr-xr-x   55 ahmedyounis  staff  1760 Jan 16 09:09 ..
-rw-r--r--@   1 ahmedyounis  staff   721 Jan  7 10:27 M00-01.md
-rw-r--r--@   1 ahmedyounis  staff   604 Jan  7 10:33 M00-02.md
-rw-r--r--@   1 ahmedyounis  staff   660 Jan  7 10:41 M00-03.md
-rw-r--r--@   1 ahmedyounis  staff   602 Jan  7 10:43 M00-04.md
-rw-r--r--@   1 ahmedyounis  staff   620 Jan  7 10:47 M00-05.md
-rw-r--r--@   1 ahmedyounis  staff   648 Jan  7 10:50 M00-06.md
-rw-r--r--@   1 ahmedyounis  staff   645 Jan  7 10:53 M00-07.md
-rw-r--r--@   1 ahmedyounis  staff   573 Jan  7 10:56 M01-01.md
-rw-r--r--@   1 ahmedyounis  staff   572 Jan  7 11:04 M01-02.md
-rw-r--r--@   1 ahmedyounis  staff   559 Jan  7 11:06 M01-03.md
-rw-r--r--@   1 ahmedyounis  staff   605 Jan  7 11:09 M01-04.md
-rw-r--r--@   1 ahmedyounis  staff   551 Jan  7 11:12 M01-05.md
-rw-r--r--@   1 ahmedyounis  staff   598 Jan  7 11:21 M01-06.md
-rw-r--r--@   1 ahmedyounis  staff   665 Jan  7 11:25 M02-01.md
-rw-r--r--@   1 ahmedyounis  staff   666 Jan  7 11:28 M02-02.md
-rw-r--r--@   1 ahmedyounis  staff   623 Jan  7 11:30 M02-03.md

thinking
**Reviewing scheduled tasks**

I need to review the `AbstractScheduledTask.php` file for its implementation related to base tasks, progress tracking, error handling, and timeout management for long-running tasks. This involves understanding how task Q08-02 fits in and determining improvements for the base implementation. So, my next step is to inspect the content of `includes/Scheduler/AbstractScheduledTask.php` and assess what changes might be beneficial. Let’s open that file and see what I can find!
exec
/bin/zsh -lc "sed -n '1,200p' includes/Scheduler/AbstractScheduledTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 33ms:
<?php
/**
 * Abstract Scheduled Task
 *
 * Base class for scheduled task implementations.
 *
 * @package WPAdminHealth\Scheduler
 */

namespace WPAdminHealth\Scheduler;

use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class AbstractScheduledTask

thinking
**Analyzing task implementation**

The file I’m looking at has basic properties and methods like getting the enabled option key and logging. The spec asks for a review of base task implementation, which includes progress tracking, error handling, and managing timeouts during long operations. This means I’ll need to enhance the base class with features for tracking progress, catching errors, and handling timeouts. I should also check for any other scheduler classes in the includes/Scheduler folder.
exec
/bin/zsh -lc 'ls -la includes/Scheduler && rg -n "AbstractScheduledTask" -S .' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 55ms:
total 40
drwxr-xr-x@  6 ahmedyounis  staff    192 Jan 16 04:39 .
drwxr-xr-x@ 28 ahmedyounis  staff    896 Jan 16 22:08 ..
-rw-r--r--@  1 ahmedyounis  staff   3093 Jan  8 23:36 AbstractScheduledTask.php
drwxr-xr-x@  4 ahmedyounis  staff    128 Jan  8 23:36 Contracts
-rw-r--r--@  1 ahmedyounis  staff  14251 Jan 17 00:58 SchedulerRegistry.php
drwxr-xr-x@  3 ahmedyounis  staff     96 Jan  8 23:45 Traits
./review_tasks.csv:48:Q08-02,"Abstract Scheduled Task Review","Review includes/Scheduler/AbstractScheduledTask.php for base task implementation, progress tracking, error handling, and timeout management in long-running tasks."
./includes/Scheduler/AbstractScheduledTask.php:20: * Class AbstractScheduledTask
./includes/Scheduler/AbstractScheduledTask.php:26:abstract class AbstractScheduledTask implements SchedulableInterface {
./includes/Media/Tasks/MediaScanTask.php:12:use WPAdminHealth\Scheduler\AbstractScheduledTask;
./includes/Media/Tasks/MediaScanTask.php:33:class MediaScanTask extends AbstractScheduledTask {
./includes/Database/Tasks/DatabaseCleanupTask.php:12:use WPAdminHealth\Scheduler\AbstractScheduledTask;
./includes/Database/Tasks/DatabaseCleanupTask.php:33:class DatabaseCleanupTask extends AbstractScheduledTask {
./includes/Performance/Tasks/PerformanceCheckTask.php:12:use WPAdminHealth\Scheduler\AbstractScheduledTask;
./includes/Performance/Tasks/PerformanceCheckTask.php:30:class PerformanceCheckTask extends AbstractScheduledTask {

thinking
**Inspecting task classes**

I’m looking at three task classes: MediaScanTask, DatabaseCleanupTask, and PerformanceCheckTask. I think it’s important to inspect how these are utilizing the base class and see what adjustments or features might be needed. I want to ensure that each class is aligning well with the shared functionality and purpose. I'll dive into their implementations to figure out if there are any improvements or updates to consider.
exec
/bin/zsh -lc "sed -n '1,220p' includes/Media/Tasks/MediaScanTask.php && echo '---' && sed -n '1,260p' includes/Database/Tasks/DatabaseCleanupTask.php && echo '---' && sed -n '1,260p' includes/Performance/Tasks/PerformanceCheckTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
<?php
/**
 * Media Scan Task
 *
 * Scheduled task for media library scanning and maintenance.
 *
 * @package WPAdminHealth\Media\Tasks
 */

namespace WPAdminHealth\Media\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\Contracts\DuplicateDetectorInterface;
use WPAdminHealth\Contracts\LargeFilesInterface;
use WPAdminHealth\Contracts\AltTextCheckerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '1,260p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 46ms:
<?php
/**
 * Media Scan Task
 *
 * Scheduled task for media library scanning and maintenance.
 *
 * @package WPAdminHealth\Media\Tasks
 */

namespace WPAdminHealth\Media\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\Contracts\DuplicateDetectorInterface;
use WPAdminHealth\Contracts\LargeFilesInterface;
use WPAdminHealth\Contracts\AltTextCheckerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '260,520p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 31ms:
			}

			/**
			 * Fires before a scan subtask is executed.
			 *
			 * @since 1.6.0
			 *
			 * @hook wpha_media_scan_before_subtask
			 *
			 * @param string $task    The subtask identifier.
			 * @param array  $options Task options.
			 */
			do_action( 'wpha_media_scan_before_subtask', $task, $options );

			$result = $this->execute_subtask_with_recovery( $task, $options, $settings );

			if ( isset( $result['error'] ) ) {
				$subtask_errors[ $task ] = $result['error'];
				$this->log( sprintf( 'Subtask %s failed: %s', $task, $result['error'] ), 'error' );
			} else {
exec
/bin/zsh -lc "sed -n '520,840p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 38ms:
					$e->getLine()
				),
				'error'
			);

			return array(
				'error' => $e->getMessage(),
			);
		}
	}

	/**
	 * Execute a specific scan subtask.
	 *
	 * @since 1.6.0
	 *
	 * @param string $task     Task name.
	 * @param array  $options  Task options.
	 * @param array  $settings Plugin settings.
	 * @return array Result with task-specific data.

thinking
**Considering task management functionality**

I'm thinking about how MediaScanTask has its own progress tracking and time limit management. According to the spec for Q08-02, I should review AbstractScheduledTask for its base task implementation, focusing on progress tracking and error handling. It seems like I might need to add similar functionality to the base class, which could make tasks more consistent and easier to manage. I should also check if other tasks, like DatabaseCleanupTask, require long-run management too.
exec
/bin/zsh -lc "sed -n '1,320p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 32ms:
<?php
/**
 * Database Cleanup Task
 *
 * Scheduled task for database maintenance operations.
 *
 * @package WPAdminHealth\Database\Tasks
 */

namespace WPAdminHealth\Database\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
use WPAdminHealth\Contracts\OrphanedCleanerInterface;
use WPAdminHealth\Contracts\TrashCleanerInterface;
use WPAdminHealth\Contracts\OptimizerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
exec
/bin/zsh -lc "sed -n '320,720p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 34ms:
		return $result;
	}

	/**
	 * Determine which cleanup tasks to run based on settings and options.
	 *
	 * @since 1.5.0
	 *
	 * @param array $settings Plugin settings.
	 * @param array $options  Task options.
	 * @return array List of task identifiers.
	 */
	private function determine_cleanup_tasks( array $settings, array $options ): array {
		$cleanup_tasks = array();

		if ( ! empty( $settings['cleanup_revisions'] ) || ! empty( $options['clean_revisions'] ) ) {
			$cleanup_tasks[] = 'revisions';
		}
		if ( ! empty( $settings['cleanup_expired_transients'] ) || ! empty( $options['clean_transients'] ) ) {
			$cleanup_tasks[] = 'transients';

thinking
**Evaluating database cleanup tasks**

I’m thinking about the DatabaseCleanupTask, which has its own progress, time limits, and error handling. However, the base class doesn’t support these features, leading to duplicated code in tasks. It seems like Q08-02 might want to abstract this code into the base class for better use among tasks. I’ll need to inspect the SchedulableInterface and SchedulerRegistry to get a clearer understanding of how this could work.
exec
/bin/zsh -lc "sed -n '1,200p' includes/Scheduler/Contracts/SchedulableInterface.php && echo '---' && sed -n '1,240p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 43ms:
<?php
/**
 * Schedulable Interface
 *
 * Contract for scheduled task implementations.
 *
 * @package WPAdminHealth\Scheduler\Contracts
 */

namespace WPAdminHealth\Scheduler\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface SchedulableInterface
 *
 * Defines the contract for tasks that can be scheduled.
exec
/bin/zsh -lc "sed -n '240,520p' includes/Scheduler/SchedulerRegistry.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 30ms:
		 *
		 * @since 1.2.0
		 *
		 * @hook wpha_scheduler_after_execute
		 *
		 * @param SchedulableInterface $task    The task that executed.
		 * @param array                $result  Execution result.
		 * @param array                $options Task options.
		 */
		do_action( 'wpha_scheduler_after_execute', $task, $result, $options );

		return $result;
	}

	/**
	 * Execute a task from its WP hook.
	 *
	 * This enables WP-Cron and Action Scheduler to execute registered tasks
	 * using their hook names (e.g. "wpha_database_cleanup").
	 *

thinking
**Evaluating task scheduling enhancements**

SchedulerRegistry manages locking and exceptions at the registry level, while each task handles its own progress and timeouts. The specification indicates that I should review AbstractScheduledTask for its core implementation, focusing on progress tracking, error handling, and timeout management for long-running tasks. I’ll interpret this as needing to enhance AbstractScheduledTask with optional helpers to avoid duplication in tasks. Maybe implementing traits or base class methods from the includes/Scheduler/Traits could be useful, so I’ll check that directory.
exec
/bin/zsh -lc 'ls -la includes/Scheduler/Traits && rg -n "progress" includes/Scheduler -S && rg -n "time_limit" includes/Scheduler -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 48ms:
total 8
drwxr-xr-x@ 3 ahmedyounis  staff    96 Jan  8 23:45 .
drwxr-xr-x@ 6 ahmedyounis  staff   192 Jan 16 04:39 ..
-rw-r--r--@ 1 ahmedyounis  staff  1964 Jan  8 23:45 HasScheduledTasks.php
exec
/bin/zsh -lc "sed -n '1,260p' includes/Scheduler/Traits/HasScheduledTasks.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 33ms:
<?php
/**
 * Has Scheduled Tasks Trait
 *
 * Provides functionality for service providers to register scheduled tasks.
 *
 * @package WPAdminHealth\Scheduler\Traits
 */

namespace WPAdminHealth\Scheduler\Traits;

use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
use WPAdminHealth\Scheduler\Contracts\SchedulerRegistryInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**

thinking
**Evaluating AbstractScheduledTask**

I’m looking at Q08-02 and thinking about improvements for AbstractScheduledTask. Maybe I could add a `with_error_handling` wrapper since it already has a log method. It seems like DatabaseCleanupTask and MediaScanTask have repeated patterns with their time limit configurations and error recovery. AbstractScheduledTask might benefit from having generic methods to reduce this duplication. However, the specifications are quite minimal, so I’ll need to interpret what’s necessary. I’ll also check the release history later.
exec
/bin/zsh -lc "sed -n '1,120p' includes/Performance/Tasks/PerformanceCheckTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 36ms:
<?php
/**
 * Performance Check Task
 *
 * Scheduled task for performance monitoring and analysis.
 *
 * @package WPAdminHealth\Performance\Tasks
 */

namespace WPAdminHealth\Performance\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\AutoloadAnalyzerInterface;
use WPAdminHealth\Contracts\QueryMonitorInterface;
use WPAdminHealth\Contracts\PluginProfilerInterface;
use WPAdminHealth\Contracts\ConnectionInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;



thinking
**Evaluating task implementation**

I see that PerformanceCheckTask lacks timeouts and progress features. I think Q08-02 might work on unifying these by improving the base class. It seems wise to review the base task implementation and consider adding a default `execute` wrapper. The SchedulableInterface requires `execute`, and tasks implement it. But, oh, I realize changing the interface could break existing tasks. Maybe I could introduce optional helper methods for error handling that tasks would use only if modified. The spec indicates we should review a specific file for features, suggesting it currently lacks these capabilities.
thinking
**Adding features to base class**

It seems necessary to enhance the base class with several features. First, I should consider adding an execution wrapper with a try/catch block for consistent error reporting. Even though SchedulerRegistry handles top-level errors, tasks may want to manage internal errors and return an array indicating failure.

Next, I'll think about implementing progress tracking with methods like `load_progress` and `save_progress`. Also, for timeout management, I might need to set parameters like `start_time` and `time_limit`. I should check if other tasks, like DatabaseCleanupTask and MediaScanTask, could benefit from these improvements and reduce redundancy while aligning with the specification that focuses on reviewing the AbstractScheduledTask.
thinking
**Considering implementation adjustments**

Implementing base features might mean adjusting tasks to work with them, but it isn't mandatory. Currently, tasks have their own ways of managing progress and timeouts, so adding to the base class likely won’t disrupt anything. Still, the specifications suggest a complete implementation, which could imply they expect tasks to be modified to utilize these base features.

However, I'm pondering if simply adding unused helper methods might meet the specifications. I need to review tasks within the .plans and check the Q08-01 spec to better grasp the context and expectations.
exec
/bin/zsh -lc "sed -n '1,200p' .plans/Q08-01.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 51ms:
# Q08-01 — Scheduler Registry Review

Review includes/Scheduler/SchedulerRegistry.php for WP-Cron task registration, schedule management, and task discovery. Check for proper hook registration.

thinking
**Reviewing scheduler tasks**

I'm looking at Q08-01, which is about reviewing the scheduler registry. There might have been improvements in previous tasks, which could affect this. For Q08-02, it seems like scheduled tasks are also under review, potentially benefiting from enhancements in earlier tasks. I might inspect older plans for style insights, though it isn't strictly necessary. I want to check the repository for existing implementations and features, as the specs are minimal for both tasks. Additionally, it'd be good to see if we can unify some timeouts or progress implementations across tasks.
exec
/bin/zsh -lc 'rg -n "PROGRESS_OPTION_KEY" -S includes | head' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 51ms:
includes/Media/Tasks/MediaScanTask.php:77:	const PROGRESS_OPTION_KEY = 'wpha_media_scan_progress';
includes/Media/Tasks/MediaScanTask.php:624:		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
includes/Media/Tasks/MediaScanTask.php:642:		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
includes/Media/Tasks/MediaScanTask.php:653:		return delete_option( self::PROGRESS_OPTION_KEY );
includes/Media/Tasks/MediaScanTask.php:675:		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
includes/Database/Tasks/DatabaseCleanupTask.php:57:	const PROGRESS_OPTION_KEY = 'wpha_db_cleanup_progress';
includes/Database/Tasks/DatabaseCleanupTask.php:475:		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
includes/Database/Tasks/DatabaseCleanupTask.php:493:		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
includes/Database/Tasks/DatabaseCleanupTask.php:504:		return delete_option( self::PROGRESS_OPTION_KEY );
includes/Database/Tasks/DatabaseCleanupTask.php:526:		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
exec
/bin/zsh -lc "rg -n \"create_result\\(\" includes | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 58ms:
includes/Media/Tasks/MediaScanTask.php:202:			return $this->create_result( 0, 0, false );
includes/Media/Tasks/MediaScanTask.php:342:		$result                    = $this->create_result( $scan_results['total_issues'], $scan_results['total_bytes'], empty( $subtask_errors ) );
includes/Performance/Tasks/PerformanceCheckTask.php:228:		return $this->create_result(
includes/Scheduler/AbstractScheduledTask.php:118:	protected function create_result( int $items_cleaned = 0, int $bytes_freed = 0, bool $success = true ): array {
includes/Database/Tasks/DatabaseCleanupTask.php:315:		$result = $this->create_result( $total_items, $total_bytes, empty( $subtask_errors ) );

thinking
**Inspecting interface constraints**

I think I need to consider adding a new interface or trait for `LongRunningTaskInterface`, but the specification only talks about the base class. So, I'm planning to check the repository tests and linting to get a clearer understanding of the constraints. I'll open the package.json to see if there are any dependencies or configurations that might inform my approach. It's essential to grasp the full context for any implementation!
exec
/bin/zsh -lc 'cat package.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
{
  "name": "wp-admin-health-suite",
  "version": "1.0.0",
  "description": "A comprehensive suite for monitoring and maintaining WordPress admin health and performance",
  "scripts": {
    "build": "webpack --mode production",
    "build:dev": "webpack --mode development",
    "watch": "webpack --mode development --watch",
    "dev": "webpack serve --mode development --open",
    "lint": "eslint assets/js --ext .js,.jsx",
    "lint:fix": "eslint assets/js --ext .js,.jsx --fix",
    "format": "prettier --write \"**/*.{js,jsx,json,css,scss,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,json,css,scss,md}\"",
    "test": "jest --passWithNoTests",
    "prepare": "husky"
  },
  "keywords": [
    "wordpress",
    "plugin",
    "health",






thinking
**Considering task improvements**

I notice that linting is limited to JS, with Jest tests possibly covering it. However, since this task is PHP, I'm realizing tests may not cover everything. Even so, I'll run npm lint/test to ensure quality. There's guidance about not adding overhead, but the spec is minimal, prompting me to consider improvements in the AbstractScheduledTask. I suspect tasks might already have overlapping functions, so enhancing the base may help with that too. I'll check the provided files for better understanding but might start with the root readme or documentation.
thinking
**Planning improvements for WordPress plugin**

I need to focus on implementing improvements in the base class, particularly in progress tracking, error handling, and timeout management. It's crucial to design these changes carefully to avoid breaking any existing tasks. I have to keep in mind that this is a WordPress plugin, and it appears to be compatible with PHP 7. This adds a layer of consideration since I want everything to function smoothly while enhancing the overall functionality.
thinking
**Examining PHP requirements and improvements**

It turns out the plugin uses typed properties like `protected string $task_id`, which means it requires PHP 7.4 or higher. So, I need to keep this in mind as I move forward. 

I should also consider whether to explore Composer. However, it looks like the plugin relies on a custom dependency injection container, so that might not be necessary. I want to inspect the includes directory to examine the tasks. 

As for improvements in the base class, I’m thinking of implementing a default `execute` wrapper method, although that might be tricky since tasks can override it. I could create a `safe_execute` method to log exceptions and return appropriate results. Additionally, I might add a `with_timeout` function to manage time limits during execution.
thinking
**Developing timer functionality in base class**

I see that I should create a set of timer-related methods. For instance, a function like `start_timer` to set up basic timing properties such as `$this->start_time`, `$this->time_limit`, and `$this->time_buffer`, with options to override the time limit if needed. 

There's also a need for an `is_time_limit_approaching` function. However, I realize that tasks have their own private implementation. If I add overlapping property names in the base class, it could lead to property shadowing issues. In PHP, derived classes can’t redeclare properties with the same name without causing errors, and I'll need to carefully navigate that.
thinking
**Navigating method naming and refactoring tasks**

I need to be careful with method names like `configure_time_limit` because tasks already have private methods with those names. If the base class adds them, I could break things, so I should choose unique names to avoid conflicts. It might be tempting to refactor tasks, but that's more complex. 

The spec seems to need us to strengthen the base class with features like execution wrappers, progress tracking, and timeout management without forcing changes on existing tasks. Perhaps integrating these into new methods in the base class would streamline things. I should also avoid method name overlaps to ensure compatibility, while still enabling features for tasks to utilize later.
thinking
**Implementing unique base methods**

I believe I can implement base methods with distinct names to avoid conflicts. For instance, I could create `init_execution_timer`, `is_execution_time_limit_approaching`, and `get_execution_remaining_time`, which will utilize base properties without overlapping.

Regarding progress tracking, I'm considering methods like `load_task_progress`, `save_task_progress`, and `clear_task_progress`. Establishing a `$progress_option_key` property in the base class might be beneficial despite potential naming conflicts with child classes using constants. 

I want to ensure that if I introduce a `get_progress` method, it won't disrupt the existing API or break any external code. So, keeping it protected or renaming it could be a safer approach.
exec
/bin/zsh -lc "rg -n \"get_progress\\(\" -S includes | head -n 50 && rg -n \"method_exists\\(.*get_progress\" -S ." in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 67ms:
includes/Media/Tasks/MediaScanTask.php:663:	public function get_progress(): array {
includes/Database/Tasks/DatabaseCleanupTask.php:514:	public function get_progress(): array {

thinking
**Evaluating potential impacts**

I’m considering whether changes could break tests. It seems unlikely, but clients might expect specific keys. Adding keys usually feels safe, yet the specification states not to modify the results, just to implement core features. Still, it’s good to question this! I need to look into how the results are utilized, especially when searching for 'items_cleaned' and similar terms to assess the implications of any adjustments.
exec
/bin/zsh -lc 'rg -n "items_cleaned" -S includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 51ms:
includes/Media/Tasks/MediaScanTask.php:725:				'items_cleaned' => 0,
includes/REST/Media/MediaCleanupController.php:606:		$items_cleaned = 0;
includes/REST/Media/MediaCleanupController.php:611:				$items_cleaned = $items_found;
includes/REST/Media/MediaCleanupController.php:616:				$items_cleaned = 1;
includes/REST/Media/MediaCleanupController.php:627:				'items_cleaned' => absint( $items_cleaned ),
includes/REST/ActivityController.php:149:			"SELECT id, scan_type, items_found, items_cleaned, bytes_freed, created_at
includes/REST/ActivityController.php:184:					'items_cleaned' => isset( $activity['items_cleaned'] ) ? absint( $activity['items_cleaned'] ) : 0,
includes/REST/MediaController.php:972:		$items_cleaned = 0;
includes/REST/MediaController.php:977:				$items_cleaned = $items_found;
includes/REST/MediaController.php:982:				$items_cleaned = 1;
includes/REST/MediaController.php:993:				'items_cleaned' => absint( $items_cleaned ),
includes/REST/DashboardController.php:305:			"SELECT id, scan_type, items_found, items_cleaned, bytes_freed, created_at
includes/REST/DashboardController.php:340:					'items_cleaned' => isset( $activity['items_cleaned'] ) ? absint( $activity['items_cleaned'] ) : 0,
includes/REST/DashboardController.php:399:					'items_cleaned' => $result['items_cleaned'],
includes/REST/DashboardController.php:430:			$result['items_cleaned']
includes/REST/DashboardController.php:441:				'items_cleaned' => $result['items_cleaned'],
includes/REST/DashboardController.php:487:					'items_cleaned' => $deleted,
includes/REST/DashboardController.php:512:					'items_cleaned' => $deleted,
includes/REST/DashboardController.php:537:					'items_cleaned' => $deleted,
includes/REST/DashboardController.php:566:					'items_cleaned' => (int) $deleted,

thinking
**Inspecting REST controllers**

I’m looking into whether the REST controllers might call scheduler tasks. I should check out the includes/REST/DashboardController and other relevant sections to see what result keys are expected. It seems like the dashboard has endpoints like "run task now" that might be linked to these scheduler tasks. So, let's delve into those areas and conduct a search for the scheduler registry to understand the execution better.
exec
/bin/zsh -lc "rg -n \"SchedulerRegistry\" includes/REST -S && rg -n \"->execute\\(\" includes/REST -S | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 48ms:

exec
/bin/zsh -lc 'rg -n "wpha_.*execute" includes/REST -S && rg -n "get_task_definitions" -S includes/REST includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 70ms:


thinking
**Exploring scheduler tasks**

I'm considering whether scheduler tasks are exclusively run through wp-cron rather than via REST. I think there could be an Admin interface involved as well. To get more insights, I should search for information specifically about the usage of "scheduler." This way, I can better understand how everything ties together and what options are indeed available for managing tasks effectively. Let's see what I can find!
exec
/bin/zsh -lc 'rg -n "scheduler" includes -S | head -n 200' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
includes/Media/Tasks/MediaScanTask.php:12:use WPAdminHealth\Scheduler\AbstractScheduledTask;
includes/REST/Media/MediaScanController.php:98:		// Schedule scan in background using action scheduler.
includes/REST/Media/MediaScanController.php:112:		// Fallback: run scan immediately if Action Scheduler is not available.
includes/REST/MediaController.php:673:		// Schedule scan in background using action scheduler.
includes/REST/MediaController.php:687:		// Fallback: run scan immediately if Action Scheduler is not available.
includes/Services/ConfigurationService.php:83:			'scheduler'   => array(
includes/Installer.php:290:		// Only schedule if scheduler is enabled (default is true).
includes/Installer.php:291:		if ( empty( $settings['scheduler_enabled'] ) ) {
includes/Installer.php:348:		// Use Action Scheduler if available, otherwise fall back to WP-Cron.
includes/Scheduler/AbstractScheduledTask.php:7: * @package WPAdminHealth\Scheduler
includes/Scheduler/AbstractScheduledTask.php:10:namespace WPAdminHealth\Scheduler;
includes/Scheduler/AbstractScheduledTask.php:12:use WPAdminHealth\Scheduler\Contracts\SchedulableInterface;
includes/Settings/SettingsServiceProvider.php:809:	 * or when the scheduler is newly enabled.
includes/Settings/SettingsServiceProvider.php:824:		// Handle scheduler being disabled.
includes/Settings/SettingsServiceProvider.php:825:		if ( empty( $new_value['scheduler_enabled'] ) ) {
includes/Settings/SettingsServiceProvider.php:830:		// Check if scheduler was just enabled or preferred time changed.
includes/Settings/SettingsServiceProvider.php:831:		$was_enabled    = ! empty( $old_value['scheduler_enabled'] );
includes/Settings/Domain/SchedulingSettings.php:53:			'scheduler_enabled'             => array(
includes/Settings/Domain/SchedulingSettings.php:55:				'title'       => __( 'Enable Scheduler', 'wp-admin-health-suite' ),
includes/Settings/Domain/SchedulingSettings.php:59:				'description' => __( 'Enable automated task scheduling using Action Scheduler.', 'wp-admin-health-suite' ),

thinking
**Inspecting MediaScanController**

I’m looking at REST/Media/MediaScanController right now, and it seems like it potentially uses MediaScanTask directly. I should take a closer look at the details to see if the base progress and locking are relevant here. It’s important to understand how these elements might interact and if they’ll affect anything down the line. I'm curious about the connections and implications! Let's dig a bit deeper.
exec
/bin/zsh -lc "sed -n '1,220p' includes/REST/Media/MediaScanController.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
<?php
/**
 * Media Scan REST Controller
 *
 * Handles media scanning operations.
 *
 * @package WPAdminHealth\REST\Media
 */

namespace WPAdminHealth\REST\Media;

use WP_REST_Request;
use WP_REST_Response;
use WP_Error;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\SettingsInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\REST\RestController;

// Exit if accessed directly.
exec
/bin/zsh -lc 'rg -n "wpha_database_cleanup" -S includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 58ms:
includes/Installer.php:300:			'wpha_database_cleanup'  => array(
includes/Installer.php:581:			'wpha_database_cleanup',
includes/Scheduler/SchedulerRegistry.php:258:	 * using their hook names (e.g. "wpha_database_cleanup").
includes/Settings/SettingsServiceProvider.php:841:			'wpha_database_cleanup'  => array(
includes/Settings/SettingsServiceProvider.php:1011:		$hooks = array( 'wpha_database_cleanup', 'wpha_media_scan', 'wpha_performance_check' );
exec
/bin/zsh -lc "sed -n '260,380p' includes/Installer.php && echo '---' && sed -n '800,940p' includes/Settings/SettingsServiceProvider.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 59ms:
	 *
	 * @since 1.2.0
	 *
	 * @return void
	 */
	private static function schedule_initial_tasks(): void {
		$settings = get_option( SettingsRegistry::OPTION_NAME, array() );

		// Ensure our custom schedules are available during activation/fresh install.
		add_filter(
			'cron_schedules',
			function ( array $schedules ): array {
				if ( ! isset( $schedules['weekly'] ) ) {
					$schedules['weekly'] = array(
						'interval' => WEEK_IN_SECONDS,
						'display'  => __( 'Once Weekly', 'wp-admin-health-suite' ),
					);
				}

				if ( ! isset( $schedules['monthly'] ) ) {





thinking
**Evaluating task scheduling improvements**

I see we're using an older approach for scheduling tasks with hooks. The goal is to improve task-based tracking and ensure consistent timeouts, though the details feel a bit ambiguous.

I think we need to modify the AbstractScheduledTask to set up standardized execution with error capture and optional timeout aborts. Also, implementing progress tracking with a persistent store is vital. However, I should be careful to avoid method naming collisions, possibly using a `task_` prefix. I’m also considering removing private helper methods to streamline calls.
thinking
**Considering task rewriting risks**

Rewriting tasks could introduce risk, but let's consider the potential benefits. The spec indicates we should review the base class for task implementation, including progress tracking and error handling. This suggests that the base class should implement these features.

I can add generic progress functions and timeouts to the base class and then update DatabaseCleanupTask and MediaScanTask to utilize these functions, which would help reduce code duplication. It’s critical that we maintain the same public method behavior, like get_progress and has_pending_progress. We’ll ensure tasks inherit from the base class while accommodating any specialized progress structures.
thinking
**Developing timeout management for tasks**

I see that tasks can share certain functionalities. For timeout management, the base class should provide timers like `start_execution_timer`, which tasks can easily call. We could also create a generic method called `configure_time_limit`, which tasks can utilize. Tasks can define defaults for time limits and buffers in protected properties, but they also currently use constants like DEFAULT_TIME_LIMIT.

However, while the base can access these constants using `static::DEFAULT_TIME_LIMIT`, it isn’t guaranteed. Instead, I could design a base method called `init_timeout` for tasks to pass their constants. Another approach is defining protected properties for default limits that tasks can override, but I’ll have to check if those values match up across tasks like DatabaseCleanupTask and MediaScanTask.
thinking
**Reevaluating constant definitions in tasks**

Tasks currently define constants, and I wonder if we could remove them to rely on the base class instead. I'm considering the risk of breaking external references—though it seems unlikely. It might be safer to keep those constants since tasks could use them internally.

One concern is that if the base defines a property like `$default_time_limit`, it shouldn't conflict with tasks that lack it. However, upon reviewing MediaScanTask, I noticed it redeclares `$default_frequency`, which the base class also defines. This makes me rethink whether property redeclaration is fatal—maybe it’s allowed after all? I’ll need to take a closer look.
thinking
**Checking property redeclaration rules in PHP**

I previously thought redeclaring a property with the same name in a child class was fatal, but I've noticed that the base class AbstractScheduledTask defines `$default_frequency = 'daily'`, and MediaScanTask redeclares it as `protected string $default_frequency = 'weekly'`. This makes me think it’s allowed in PHP, possibly if the same visibility and type are maintained.

I'm wondering if redeclaration is only prohibited for `private` properties, but that's not entirely clear to me. I need to verify this by running a quick test in PHP using a shell command. Let's see what it says!
exec
/bin/zsh -lc 'php -v' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 129ms:
PHP 8.4.16 (cli) (built: Dec 16 2025 16:03:34) (NTS)
Copyright (c) The PHP Group
Built by Homebrew
Zend Engine v4.4.16, Copyright (c) Zend Technologies
    with Zend OPcache v8.4.16, Copyright (c), by Zend Technologies

thinking
I'll check out PHP 8.4.16 to see how property redeclaration works. It seems like a straightforward thing to test, but I want to make sure I’m thorough. My next step will be to run a small code snippet to see if it behaves as expected. It’s always good to confirm things directly, right? This should help me get a clear understanding of how the property redeclaration functions in this version!
exec
/bin/zsh -lc "php -r 'class A { protected string "'$x = "a"; } class B extends A { protected string $x = "b"; } echo (new B())->x;'"'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 255 in 88ms:

Fatal error: Uncaught Error: Cannot access protected property B::$x in Command line code:1
Stack trace:
#0 {main}
  thrown in Command line code on line 1
PHP Fatal error:  Uncaught Error: Cannot access protected property B::$x in Command line code:1
Stack trace:
#0 {main}
  thrown in Command line code on line 1
exec
/bin/zsh -lc "php -r 'class A { protected string "'$x = "a"; } class B extends A { protected int $x = 1; }'"'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 255 in 91ms:

Fatal error: Type of B::$x must be string (as in class A) in Command line code on line 1
PHP Fatal error:  Type of B::$x must be string (as in class A) in Command line code on line 1
exec
/bin/zsh -lc "php -r 'class A { protected string "'$x = "a"; } class B extends A { private string $x = "b"; }'"'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 255 in 91ms:

Fatal error: Access level to B::$x must be protected (as in class A) or weaker in Command line code on line 1
PHP Fatal error:  Access level to B::$x must be protected (as in class A) or weaker in Command line code on line 1





thinking
**Evaluating code refactoring options**

I think it's better to refactor tasks and share names for improved readability. We need to be careful with method access, like the protected method in the base class and the private one in the child class. One option is to keep child methods and adjust visibility. We might do a full refactor, which seems manageable. Option A is safer, adding unique methods in AbstractScheduledTask without changing tasks, but I might lean towards Option B, to fully implement the spec as the user requested.
thinking
**Exploring task refactoring options**

I’m considering expanding the base class to include generic progress, timeouts, and error handling, which would let long-running tasks leverage these base methods and reduce duplications. I want to ensure that both DatabaseCleanupTask and MediaScanTask maintain their existing behaviors while using the new base methods. Looking closely, I see that they replicate `configure_time_limit` and `is_time_limit_approaching` logic, so the base can implement those just once. Additionally, I could develop a helper for standardized error handling, which aligns with the spec's requirements.
thinking
**Refining error and timeout handling**

I’m considering providing a `protected function handle_exception(Throwable $e, string $context = ''): string` to return messages, or perhaps a `protected function log_exception(Throwable $e, string $context): void` for logging errors in the tasks. They already log exceptions, but base methods could offer a `protected function safe_execute_subtask(callable, string $context)`. 

Regarding error logging styles, I notice that DatabaseCleanupTask and MediaScanTask both have specific catch logs. The base could unify this with a method like `format_exception_message(Throwable $e)`. Additionally, for timeout and progress management, I could implement generic methods in the base class for tasks to use, though they might need name adjustments to fit the same method conventions.
thinking
**Considering refactoring strategies**

I’m thinking about keeping the task methods but changing them to call base helper methods with different names. If the base adds a unique method like `load_progress_data`, tasks can continue using their private methods while benefiting from the new helper. This would reduce some duplication. However, the spec likely intends for the base to implement progress tracking. If the base offers helper methods like `load_task_progress`, it would allow the tasks to leverage those directly without name collisions! That way, I think I can address both the spec requirements and task needs.
thinking
**Planning timeout management**

I’m considering adding uniquely named helper methods in the base class for timeouts, like `initialize_time_limit`, and then updating tasks to use those. This approach could avoid collisions and reduce code duplication. While we might still face duplicates with names like `configure_time_limit`, one idea is to keep the task method names as a thin wrapper calling the base method directly. To avoid conflicts, it’s crucial to check if other tasks also have a `configure_time_limit` method. If they do, we need to ensure that no name clashes happen when removing the tasks’ duplicate methods.
exec
/bin/zsh -lc "rg -n \"configure_time_limit\\(\" includes -S" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 60ms:
includes/Media/Tasks/MediaScanTask.php:195:		$this->configure_time_limit( $options );
includes/Media/Tasks/MediaScanTask.php:386:	private function configure_time_limit( array $options ): void {
includes/Database/Tasks/DatabaseCleanupTask.php:175:		$this->configure_time_limit( $options );
includes/Database/Tasks/DatabaseCleanupTask.php:382:	private function configure_time_limit( array $options ): void {
Reconnecting... 1/5 (stream disconnected before completion: Transport error: network error: error decoding response body)

thinking
**Evaluating task methods**

I’m considering the current public methods like get_progress, has_pending_progress, and reset_progress in DatabaseCleanupTask and MediaScanTask. I’m thinking we might want to remove them to inherit from the base class or keep them but call the base class. Leaving them could help maintain the documentation. However, I need to ensure these methods aren’t part of SchedulableInterface, but they might still be useful in REST contexts. I should search for how has_pending_progress is being used.
exec
/bin/zsh -lc "rg -n \"has_pending_progress\\(\" -S includes | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 56ms:
includes/Media/Tasks/MediaScanTask.php:674:	public function has_pending_progress(): bool {
includes/Database/Tasks/DatabaseCleanupTask.php:525:	public function has_pending_progress(): bool {

thinking
**Checking for property conflicts**

I need to ensure that no other derived class is using the property names with different visibility, as that could create conflicts. To make sure everything aligns properly, I’ll search for the `$start_time` property in tasks. It’s crucial to avoid any naming collisions, so being thorough in this search will help prevent potential issues down the line. I want everything to work smoothly!
exec
/bin/zsh -lc "rg -n \"\\"'$start_time" includes -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 50ms:


thinking
**Investigating exit code issue**

I’m trying to figure out why ripgrep is returning exit code 1 when there should be matches. I’ve noticed that `$start_time` is in tasks, but it seems that in the file, it’s preceded by 'private float $start_time'. So, I’m thinking it should match. But, maybe the regex in the rg command is treating `$` as a special character? I probably need to escape it. Let’s go ahead and search again.
exec
/bin/zsh -lc 'rg -n "start_time" includes/Media/Tasks/MediaScanTask.php includes/Database/Tasks/DatabaseCleanupTask.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 53ms:
includes/Media/Tasks/MediaScanTask.php:154:	private float $start_time = 0.0;
includes/Media/Tasks/MediaScanTask.php:194:		$this->start_time = microtime( true );
includes/Media/Tasks/MediaScanTask.php:315:		$elapsed_time = microtime( true ) - $this->start_time;
includes/Media/Tasks/MediaScanTask.php:420:		$elapsed = microtime( true ) - $this->start_time;
includes/Database/Tasks/DatabaseCleanupTask.php:134:	private float $start_time = 0.0;
includes/Database/Tasks/DatabaseCleanupTask.php:174:		$this->start_time = microtime( true );
includes/Database/Tasks/DatabaseCleanupTask.php:287:		$elapsed_time = microtime( true ) - $this->start_time;
includes/Database/Tasks/DatabaseCleanupTask.php:416:		$elapsed = microtime( true ) - $this->start_time;
includes/Database/Tasks/DatabaseCleanupTask.php:428:		$elapsed = microtime( true ) - $this->start_time;
exec
/bin/zsh -lc "rg -n \"\\b(load_progress|save_progress|clear_progress)\\b\" includes -S" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 57ms:
includes/Media/Tasks/MediaScanTask.php:206:		$progress = $this->load_progress();
includes/Media/Tasks/MediaScanTask.php:247:				$this->save_progress(
includes/Media/Tasks/MediaScanTask.php:304:			$this->clear_progress();
includes/Media/Tasks/MediaScanTask.php:623:	private function load_progress(): array {
includes/Media/Tasks/MediaScanTask.php:641:	private function save_progress( array $progress ): bool {
includes/Media/Tasks/MediaScanTask.php:652:	private function clear_progress(): bool {
includes/Media/Tasks/MediaScanTask.php:664:		return $this->load_progress();
includes/Media/Tasks/MediaScanTask.php:688:		return $this->clear_progress();
includes/Database/Tasks/DatabaseCleanupTask.php:180:		$progress = $this->load_progress();
includes/Database/Tasks/DatabaseCleanupTask.php:215:				$this->save_progress(
includes/Database/Tasks/DatabaseCleanupTask.php:284:			$this->clear_progress();
includes/Database/Tasks/DatabaseCleanupTask.php:474:	private function load_progress(): array {
includes/Database/Tasks/DatabaseCleanupTask.php:492:	private function save_progress( array $progress ): bool {
includes/Database/Tasks/DatabaseCleanupTask.php:503:	private function clear_progress(): bool {
includes/Database/Tasks/DatabaseCleanupTask.php:515:		return $this->load_progress();
includes/Database/Tasks/DatabaseCleanupTask.php:539:		return $this->clear_progress();





thinking
**Evaluating method implementation**

I notice that the base method `execute_subtask_with_recovery` could create conflicts. Instead, I could implement it generically to handle both tasks. The challenge is that `Media` calls this method with three arguments: `$task`, `$options`, and `$settings`, whereas `Database` only uses two. Perhaps I can add an optional parameter for `$settings`. I wonder if I should keep the original task methods or just refactor everything to streamline the process instead.
thinking
**Streamlining error handling**

I see an example using `$this->execute_with_recovery` that captures a subtask’s execution but there's still some duplication. I could introduce a new base method, `capture_exception`, to log messages and trigger expected actions consistently. While tasks do their own logging now, I think I could unify that. 

Additionally, implementing an `execute_wrapper` method in the base class could simplify things by managing timings and exceptions. However, that would require significant changes across tasks. So, I’ll focus on adding helper methods and properties in `AbstractScheduledTask` instead.
thinking
**Enhancing scheduled task properties**

I'm considering adding properties for `AbstractScheduledTask`, such as a time buffer of 3, a minimum time limit of 5, and maybe a progress option key. I think the `progress_ttl` might not be necessary since I can just use `update_option` to store progress. 

To manage long-running tasks, I could create protected methods like `start_execution_timer` to set the start time and configure the time limit, and another method, `configure_time_limit`, to set up limits based on the maximum execution time plus a buffer.
thinking
**Refining progress handling methods**

I want to use `$default_time_limit` while allowing an override through `options['time_limit']`.  I’ll add a method, `is_time_limit_approaching`, to return whether the time limit is close, and `get_remaining_time` for seconds left in the limit.

For progress tracking, I’ll include methods to load, save, and clear progress. I’m considering a public method for `get_progress` and checking for pending progress, as well as a potential `reset_progress`. But I need to ensure base methods are safe when tasks don’t want to persist progress. 

To determine the `progress_option_key`, I think I’ll set a default pattern based on the task ID. The existing patterns seem consistent, but the key for `database_cleanup` needs a match with how I set it.
thinking
**Adjusting progress option key**

The base default for progress should be set to `'wpha_' . $task_id . '_progress'`. For example, the `DatabaseCleanupTask` should explicitly have the key as `wpha_db_cleanup_progress` for compatibility with saved options. To achieve this, I can define a property in the class or use a constant. 

The base property `protected string $progress_option_key = '';` could be set in tasks to keep things organized. I can also have a constant `PROGRESS_OPTION_KEY` in each task. It seems I can use the constant in the default property, but I need to confirm that it's allowed in PHP. Let's test that quickly!
exec
/bin/zsh -lc "php -r 'class A { const K=\"x\"; protected string "'$p = self::K; } echo (new A())->p;'"'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 255 in 87ms:

Fatal error: Uncaught Error: Cannot access protected property A::$p in Command line code:1
Stack trace:
#0 {main}
  thrown in Command line code on line 1
PHP Fatal error:  Uncaught Error: Cannot access protected property A::$p in Command line code:1
Stack trace:
#0 {main}
  thrown in Command line code on line 1
exec
/bin/zsh -lc "php -r 'class A { const K=\"x\"; public string "'$p = self::K; } echo (new A())->p;'"'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 90ms:
x





thinking
**Considering timeout management**

I'm exploring how to implement timeout management in long-running tasks. I wonder if I need to set a PHP time limit, but I'm not sure if that's applicable since WordPress Cron might have its own settings. I think I might consider calling `set_time_limit`. The spec mentions several key functions, like tracking max execution time, checking time left, and saving progress. I also need to think about a base task implementation that includes these properties and maybe even a new `create_result` to add duration. It's a lot to think about!
thinking
**Evaluating function implementation**

I'm thinking about implementing a base method called `create_execution_result`, which takes parameters for items cleaned, bytes freed, and an optional success flag along with additional metadata. There's already a `create_result`, so I wonder if I should adjust it to accept the extra array or create a new method. Right now, tasks call `create_result` with three args, but by making the new parameter optional, I can avoid impacting existing calls. Do I need to update the method and any potential overrides? That's a lot to consider!
thinking
**Refining result handling**

I'm considering how to improve the result handling. Should I add `'meta' => $meta` to the result? But maybe that creates unnecessary nesting, so merging meta keys could work better. However, if there are key conflicts, do I override? It seems tasks already add extra keys after calling `create_result`, meaning adding another parameter might not be helpful. Instead, I think I should keep `create_result` unchanged for compatibility. I could introduce a `create_error_result` method to manage errors efficiently and focus on implementing improvements necessary for handling long-running tasks.
thinking
**Assessing task modifications**

I need to think carefully about risks when modifying tasks. Changes might break functionality, so I'll inspect the current DatabaseCleanupTask and MediaScanTask for potential bugs or improvements. The spec hints that perhaps the base class should manage tasks with automatic progress resumes, though it's not explicitly mentioned. I need to ensure the base class includes methods for execution tracking, storing progress, handling resets and errors, and managing timeouts. It looks like progress tracking isn't consistent across tasks, so I'll have to address that.
thinking
**Defining task properties**

I'm considering whether the base should define a standard format for progress, which could include properties like `started_at`, `last_update`, `completed_steps`, and `errors`. While it's fine if tasks have their own shapes, I wonder if the base should enforce time limits and handle completion checks. Additionally, the `AbstractScheduledTask` currently has an uninitialized `task_id` property. To prevent errors, I could set default values to empty strings, ensuring everything is initialized properly. The spec points toward creating improvements without being too invasive, so I’ll move ahead with a thoughtful plan.
Plan update
  ✓ Read spec and handoff
  → Inspect existing code paths
  • Implement required changes
  • Run lint and tests
  • Summarize and hand off

thinking
**Inspecting scheduled tasks**

I'm reviewing the existing code paths, including the base class, tasks, and scheduler registry. I need to see if there are other scheduled tasks patterns or documentation. Maybe searching for "AbstractScheduledTask" could help.

I’ll check if there’s an AGENTS.md file in the root or subdirectories since the user provided root instructions. It’s crucial to look for AGENTS in the directories related to my changes, like AbstractScheduledTask.php, DatabaseCleanupTask.php, and MediaScanTask.php. I'll start searching for AGENTS now.
exec
/bin/zsh -lc 'find .. -name AGENTS.md -print' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 25.96s:
../DeliverPlan/AGENTS.md
../lamie/lamie-frontend/AGENTS.md
../lamie/lamie-backend/AGENTS.md
../FlowReviewFrontend-worktree-C/AGENTS.md
../wooflow-guard/AGENTS.md
../FlowReviewFrontend-worktree-B/AGENTS.md
../clientora/AGENTS.md
../NovaSaaS/AGENTS.md
../whatsapp-commerce-hub/vendor/wp-cli/i18n-command/AGENTS.md
../lumina/AGENTS.md
../wltv-analytics/AGENTS.md
../FlowReviewFrontend-worktree-A/AGENTS.md
../FlowReviewFrontend/AGENTS.md
../pseo-pro/AGENTS.md
Plan update
  ✓ Read spec and handoff
  ✓ Inspect existing code paths
  → Implement required changes
  • Run lint and tests
  • Summarize and hand off





thinking
**Clarifying autoload settings**

I need to make sure I use `false` for the autoload parameter when setting tasks in WordPress. I'm recalling that the third parameter in the `update_option` function is indeed for autoload. It's interesting how these details really matter in function calls. I should double-check the documentation to confirm that I'm on the right track with using `false` as the autoload option to avoid unnecessary loading of data. Keeping things streamlined is important!
thinking
**Refactoring exception handling**

Tasks currently catch exceptions in subtasks, and I'm wondering if we should refactor that. There might be a benefit in ensuring consistent log formatting. I could implement `protected function format_exception_for_log(\Throwable $e): string` and `protected function log_exception(\Throwable $e, string $context = ''): void`.

In the tasks, I could replace catch blocks with a call to `$this->log_exception($e, sprintf('subtask %s', $task));`. Also, I think we can add a hook for handling task exceptions. But I'll keep logging minimal to avoid complications! Additionally, implementing a normalization method for time limits seems like a neat idea.
thinking
**Considering task refactoring**

I'm thinking about refactoring the `DatabaseCleanupTask` and `MediaScanTask` to utilize base properties and methods. I might consider removing the constants `DEFAULT_TIME_LIMIT` and `TIME_BUFFER`, but I'm not sure if that's necessary since tasks may refer to these in their code.

If I keep them, I could set base properties to override those values. However, if I remove methods that use these constants, they might become unused, which is something to consider. It seems like they could still be helpful for manual overrides, but I’ll need to assess their actual usage.
thinking
**Simplifying task structure**

I think it's better to remove unnecessary complexity and rely on the base `default_time_limit` and other properties, allowing for value overrides in the class. While reviewing the specifications, we can centralize this approach, but we need to ensure we don't break any references to existing constants—though that's unlikely.

For backward compatibility, it might be wise to keep the constants while ensuring base properties reference them, like: `protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;`. I believe I can refer to `self` in property defaults, which helps maintain usage of constants. Finally, I should consider removing the time limit assignment in the constructor since the base configuration now handles that.
thinking
**Reviewing time limit handling**

I’m noticing that the base `configure_time_limit` method uses the `default_time_limit` property, and I want to set the `time_limit` property to `default_time_limit` at the start. That seems manageable. Currently, tasks call `$this->configure_time_limit($options);`, which will set `$this->time_limit`. If the default is 0, the base might need to set it to `default_time_limit`, so I’ll ensure that works.

Tasks also calculate elapsed time using `$this->start_time`, which is good. I need to check how `get_remaining_time` is used in the `DatabaseCleanupTask` subtask since it seems defined but potentially unused. I'll search for its usage next.
exec
/bin/zsh -lc "rg -n \"get_remaining_time\\(\" includes/Database/Tasks/DatabaseCleanupTask.php includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 40ms:
includes/Database/Tasks/DatabaseCleanupTask.php:427:	private function get_remaining_time(): float {








thinking
**Considering class structure**

I'm noticing that the base class has some protected properties like task_id, task_name, description, default_frequency, and enabled_option_key. I plan to add new properties after enabled_option_key. Next, I'll incorporate progress/timeouts and error handling helper methods into the class, potentially after the existing methods. Hmm, maybe placing them after the get_settings_schema method but before create_result could work well. Alright, time to craft the code!
thinking
**Defining properties and methods**

I’m working on setting up some properties related to execution timing for long-running tasks. I have a protected float for the start time, as well as integers for time limits, a safety buffer, and a minimum limit. There’s also a string for the progress option key that can be left empty to disable progress persistence.

Next up, I plan to add a method to initialize timing for a long-running task execution. It’s essential to get this right!
thinking
**Implementing execution context functions**

I'm setting up the `init_execution_context` method to set the start time and configure the time limit using task options. I realize that tasks already call `microtime` and `configure_time_limit` separately, but this will be useful for new tasks.

Next, I need to configure the time limit using `configure_time_limit`, which will extract options using a helper function. I plan to implement `get_positive_int_option` to parse the option for time limits, while ensuring it won’t conflict with existing tasks. This should streamline the process!
thinking
**Implementing time limit logic**

I’m keeping things simple for the implementation. I’ll start by checking if the `time_limit` exists in the options. If so, I’ll determine its value—whether it’s an integer or a string that's a digit—to set `override`. If `override` is a positive integer, I’ll assign it to `time_limit`.

Next, I need to consider the maximum execution time. I’m going to ensure that `time_buffer` is less than `max_execution_time`, which will help in calculating an effective limit. The use of `max` functions will help in ensuring it never drops below the minimum!
thinking
**Refining time limit checks and progress options**

I'm working on the `is_time_limit_approaching` method. I see that the time buffer is used to ensure we stop significantly before hitting the limit, but using it twice seems overly cautious. Tasks previously used a constant for the buffer, while my implementation relies on a property. 

For the progress option key, I need to ensure that `task_id` is initialized. Since it might be uninitialized, I should set defaults for base properties like `$task_id`, `$task_name`, and `$description` to avoid runtime errors if a subclass forgets to define them. This makes the implementation more robust!
thinking
**Implementing task properties and methods**

I'm planning to modify base properties to include `task_id`, `task_name`, and `description`, all initialized to empty strings. This way, even if subclasses don't set these, they won't cause an error. 

Next, I’m looking into the `load_progress` method, which retrieves saved progress from options. I think it would be useful to log the key being accessed for better tracking. 

For error handling, I’m implementing methods to log exceptions and execute callbacks with recovery. In `execute_with_recovery`, I want to maintain the requirement that results need to be arrays but ensure that the fallback is always returned as an array. 

Finally, I’m outlining new properties for tasks like `default_time_limit` and `time_buffer`, which will override the defaults in the base class, ensuring consistency and enhancing functionality.
thinking
**Updating time limits and log handling**

I’m considering setting the base `time_limit` property to a default value of 25. This helps tasks that don’t call the configure method still have a valid `time_limit`. However, if I set it to 0 initially, I’m worried it may require accessing a property value that hasn't been initialized yet. 

To simplify, I think the base `time_limit` can remain at 25 for consistency, and tasks can override as needed. It seems logical since tasks will generally call the configuration method anyway, so defaults should work well. 

I’ll also be removing unused methods related to time limits and progress, as I'm leveraging the base classes for functionality instead. When updating the logging for errors, I want to make sure the messages match existing formats, specifically the context formatting within the logs to maintain clarity in the outputs. The implementation will finalize in ensuring a standard structure across tasks for recovery execution and logging exceptions, which feels like a neat way to keep everything consistent.
thinking
**Running syntax checks and tests**

After making my modifications, the next step is to check the PHP syntax for the files I've changed by running `php -l`. Once that's done, I’ll proceed to run `npm run lint` and `npm test` according to the instructions. It’s important to note that there isn’t a “format” command included in the process. So, I'll make sure to update my plan steps to reflect these actions. Now, I'm ready to implement the patch!
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/AbstractScheduledTask.php
@@ -32,3 +32,3 @@
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
@@ -39,3 +39,3 @@
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
@@ -46,3 +46,3 @@
 	 */
-	protected string $description;
+	protected string $description = '';
 
@@ -63,2 +63,51 @@
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
@@ -110,2 +159,240 @@
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M includes/Scheduler/AbstractScheduledTask.php
file update:
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Updating tasks and patches**

I need to update methods and properties, and make sure there are no unused warnings. Next, I'll focus on adjusting the DatabaseCleanupTask and MediaScanTask accordingly. I plan to patch the DatabaseCleanupTask first by editing it to remove specific sections and add properties like default_time_limit, time_buffer, and progress_option_key. I'll start by looking at the top sections where the class properties are defined so I can effectively plan my patch.
exec
/bin/zsh -lc "sed -n '1,120p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
<?php
/**
 * Database Cleanup Task
 *
 * Scheduled task for database maintenance operations.
 *
 * @package WPAdminHealth\Database\Tasks
 */

namespace WPAdminHealth\Database\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\RevisionsManagerInterface;
use WPAdminHealth\Contracts\TransientsCleanerInterface;
use WPAdminHealth\Contracts\OrphanedCleanerInterface;
use WPAdminHealth\Contracts\TrashCleanerInterface;
use WPAdminHealth\Contracts\OptimizerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
file update:
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc "sed -n '120,220p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
	private TrashCleanerInterface $trash_cleaner;

	/**
	 * Database optimizer.
	 *
	 * @var OptimizerInterface
	 */
	private OptimizerInterface $optimizer;

	/**
	 * Start time of the current execution.
	 *
	 * @var float
	 */
	private float $start_time = 0.0;

	/**
	 * Time limit for the current execution in seconds.
	 *
	 * @var int
file update:
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Planning code adjustments**

It looks like I need to remove some private properties like `start_time` and `time_limit`, as well as the time limit assignment in the constructor. I’ll likely add new override properties for `default_time_limit`, `time_buffer`, and `progress_option_key`. Considering where to place them, I think after `enabled_option_key` works best for readability.

I’ll also need to set the values for `time_buffer` and `progress_option_key`. Additionally, I’ll remove several methods related to progress management. I'll locate those sections in the file and patch accordingly.
exec
/bin/zsh -lc "sed -n '340,620p' includes/Database/Tasks/DatabaseCleanupTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 38ms:
		}
		if (
			! empty( $settings['orphaned_cleanup_enabled'] )
			|| ! empty( $settings['cleanup_orphaned_metadata'] )
			|| ! empty( $options['clean_orphaned'] )
		) {
			$cleanup_tasks[] = 'orphaned';
		}

		$trash_retention_days = absint( $settings['auto_clean_trash_days'] ?? 0 );
		$spam_retention_days  = absint( $settings['auto_clean_spam_days'] ?? 0 );

		$trash_cleanup_enabled = (
			( ! empty( $settings['cleanup_trashed_posts'] ) || ! empty( $settings['cleanup_trashed_comments'] ) )
			&& $trash_retention_days > 0
		);

		$spam_cleanup_enabled = ( ! empty( $settings['cleanup_spam_comments'] ) && $spam_retention_days > 0 );

		if ( $spam_cleanup_enabled || ! empty( $options['clean_spam'] ) ) {
file update:
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -94,2 +94,23 @@
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
@@ -129,16 +150,2 @@
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
@@ -163,3 +170,2 @@
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
@@ -371,36 +377,2 @@
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
@@ -408,26 +380,2 @@
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
@@ -444,97 +392,12 @@
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M includes/Database/Tasks/DatabaseCleanupTask.php
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc "sed -n '1,220p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 47ms:
<?php
/**
 * Media Scan Task
 *
 * Scheduled task for media library scanning and maintenance.
 *
 * @package WPAdminHealth\Media\Tasks
 */

namespace WPAdminHealth\Media\Tasks;

use WPAdminHealth\Scheduler\AbstractScheduledTask;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\ScannerInterface;
use WPAdminHealth\Contracts\DuplicateDetectorInterface;
use WPAdminHealth\Contracts\LargeFilesInterface;
use WPAdminHealth\Contracts\AltTextCheckerInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc "sed -n '340,760p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
		);

		$result                    = $this->create_result( $scan_results['total_issues'], $scan_results['total_bytes'], empty( $subtask_errors ) );
		$result['was_interrupted'] = $was_interrupted;
		$result['errors']          = $subtask_errors;
		$result['elapsed_time']    = $elapsed_time;

		return $result;
	}

	/**
	 * Determine which scan tasks to run based on settings and options.
	 *
	 * @since 1.6.0
	 *
	 * @param array $settings Plugin settings.
	 * @param array $options  Task options.
	 * @return array List of task identifiers.
	 */
	private function determine_scan_tasks( array $settings, array $options ): array {
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Media/Tasks/MediaScanTask.php
@@ -114,2 +114,23 @@
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
@@ -147,16 +168,2 @@
 	private AltTextCheckerInterface $alt_text_checker;
-
-	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
 
@@ -183,3 +190,2 @@
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
@@ -378,48 +384,2 @@
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
@@ -510,75 +470,9 @@
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Execute a specific scan subtask.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param string $task     Task name.
-	 * @param array  $options  Task options.
-	 * @param array  $settings Plugin settings.
-	 * @return array Result with task-specific data.
-	 */
-	private function execute_subtask( string $task, array $options, array $settings ): array {
-		$result = array();
-
-		switch ( $task ) {
-			case 'summary':
-				$full_scan = $this->scanner->get_media_summary();
-				$result['summary'] = $full_scan;
-				$this->log( sprintf( 'Full scan completed. Total items: %d', $full_scan['total_count'] ?? 0 ) );
-				break;
-
-			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
-				$result['duplicates'] = $duplicates;
-				$result['count']      = count( $duplicates );
-				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
-				break;
-
-			case 'large_files':
-				$threshold_kb = $options['large_file_threshold_kb'] ?? ( $settings['large_file_threshold_kb'] ?? 1000 );
-				$large        = $this->large_files->find_large_files( $threshold_kb );
-				$total_bytes  = 0;
-
-				foreach ( $large as $file ) {
-					$total_bytes += $file['size'] ?? ( $file['current_size'] ?? 0 );
-				}
-
-				$result['large_files'] = $large;
-				$result['count']       = count( $large );
-				$result['total_bytes'] = $total_bytes;
-				$this->log( sprintf( 'Found %d large files', $result['count'] ) );
-				break;
-
-			case 'alt_text':
-				$limit       = $options['alt_text_limit'] ?? 100;
-				$missing_alt = $this->alt_text_checker->find_missing_alt_text( $limit );
-				$result['missing_alt'] = $missing_alt;
-				$result['count']       = count( $missing_alt );
-				$this->log( sprintf( 'Found %d images missing alt text', $result['count'] ) );
-				break;
-		}
-
-		return $result;
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
@@ -613,77 +507,2 @@
 		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M includes/Media/Tasks/MediaScanTask.php
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..2a67ae3f68aff867c85e2fd0655fd88b818e2dac
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -145,20 +166,6 @@
 	 * @var AltTextCheckerInterface
 	 */
 	private AltTextCheckerInterface $alt_text_checker;
-
-	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
 
 	/**
 	 * Constructor.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,79 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Execute a specific scan subtask.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param string $task     Task name.
-	 * @param array  $options  Task options.
-	 * @param array  $settings Plugin settings.
-	 * @return array Result with task-specific data.
-	 */
-	private function execute_subtask( string $task, array $options, array $settings ): array {
-		$result = array();
-
-		switch ( $task ) {
-			case 'summary':
-				$full_scan = $this->scanner->get_media_summary();
-				$result['summary'] = $full_scan;
-				$this->log( sprintf( 'Full scan completed. Total items: %d', $full_scan['total_count'] ?? 0 ) );
-				break;
-
-			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
-				$result['duplicates'] = $duplicates;
-				$result['count']      = count( $duplicates );
-				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
-				break;
-
-			case 'large_files':
-				$threshold_kb = $options['large_file_threshold_kb'] ?? ( $settings['large_file_threshold_kb'] ?? 1000 );
-				$large        = $this->large_files->find_large_files( $threshold_kb );
-				$total_bytes  = 0;
-
-				foreach ( $large as $file ) {
-					$total_bytes += $file['size'] ?? ( $file['current_size'] ?? 0 );
-				}
-
-				$result['large_files'] = $large;
-				$result['count']       = count( $large );
-				$result['total_bytes'] = $total_bytes;
-				$this->log( sprintf( 'Found %d large files', $result['count'] ) );
-				break;
-
-			case 'alt_text':
-				$limit       = $options['alt_text_limit'] ?? 100;
-				$missing_alt = $this->alt_text_checker->find_missing_alt_text( $limit );
-				$result['missing_alt'] = $missing_alt;
-				$result['count']       = count( $missing_alt );
-				$this->log( sprintf( 'Found %d images missing alt text', $result['count'] ) );
-				break;
-		}
-
-		return $result;
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -611,81 +505,6 @@
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
 		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..2a67ae3f68aff867c85e2fd0655fd88b818e2dac
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -145,20 +166,6 @@
 	 * @var AltTextCheckerInterface
 	 */
 	private AltTextCheckerInterface $alt_text_checker;
-
-	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
 
 	/**
 	 * Constructor.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,79 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Execute a specific scan subtask.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param string $task     Task name.
-	 * @param array  $options  Task options.
-	 * @param array  $settings Plugin settings.
-	 * @return array Result with task-specific data.
-	 */
-	private function execute_subtask( string $task, array $options, array $settings ): array {
-		$result = array();
-
-		switch ( $task ) {
-			case 'summary':
-				$full_scan = $this->scanner->get_media_summary();
-				$result['summary'] = $full_scan;
-				$this->log( sprintf( 'Full scan completed. Total items: %d', $full_scan['total_count'] ?? 0 ) );
-				break;
-
-			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
-				$result['duplicates'] = $duplicates;
-				$result['count']      = count( $duplicates );
-				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
-				break;
-
-			case 'large_files':
-				$threshold_kb = $options['large_file_threshold_kb'] ?? ( $settings['large_file_threshold_kb'] ?? 1000 );
-				$large        = $this->large_files->find_large_files( $threshold_kb );
-				$total_bytes  = 0;
-
-				foreach ( $large as $file ) {
-					$total_bytes += $file['size'] ?? ( $file['current_size'] ?? 0 );
-				}
-
-				$result['large_files'] = $large;
-				$result['count']       = count( $large );
-				$result['total_bytes'] = $total_bytes;
-				$this->log( sprintf( 'Found %d large files', $result['count'] ) );
-				break;
-
-			case 'alt_text':
-				$limit       = $options['alt_text_limit'] ?? 100;
-				$missing_alt = $this->alt_text_checker->find_missing_alt_text( $limit );
-				$result['missing_alt'] = $missing_alt;
-				$result['count']       = count( $missing_alt );
-				$this->log( sprintf( 'Found %d images missing alt text', $result['count'] ) );
-				break;
-		}
-
-		return $result;
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -611,81 +505,6 @@
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
 		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Inspecting subtask implementation**

I noticed that we removed the execute_subtask method unintentionally when we patched the output. It seems we need to re-add it right below the execute_subtask_with_recovery method. Implementing the same code as before should work. I’ll take a moment to carefully inspect the file around that area to confirm everything aligns properly. It's important to ensure we have the correct functionalities in place without overlooking any details.
exec
/bin/zsh -lc "rg -n \"execute_subtask\\(\" includes/Media/Tasks/MediaScanTask.php && sed -n '420,620p' includes/Media/Tasks/MediaScanTask.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 45ms:
473:				return $this->execute_subtask( $task, $options, $settings );
	 * Release the lock.
	 *
	 * @since 1.6.0
	 *
	 * @return bool True on success.
	 */
	private function release_lock(): bool {
		return delete_transient( self::LOCK_TRANSIENT );
	}

	/**
	 * Check if a scan is currently locked/running.
	 *
	 * @since 1.6.0
	 *
	 * @return bool True if a scan is running.
	 */
	public function is_scan_running(): bool {
		$lock = get_transient( self::LOCK_TRANSIENT );
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..2a67ae3f68aff867c85e2fd0655fd88b818e2dac
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -145,20 +166,6 @@
 	 * @var AltTextCheckerInterface
 	 */
 	private AltTextCheckerInterface $alt_text_checker;
-
-	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
 
 	/**
 	 * Constructor.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,79 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Execute a specific scan subtask.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param string $task     Task name.
-	 * @param array  $options  Task options.
-	 * @param array  $settings Plugin settings.
-	 * @return array Result with task-specific data.
-	 */
-	private function execute_subtask( string $task, array $options, array $settings ): array {
-		$result = array();
-
-		switch ( $task ) {
-			case 'summary':
-				$full_scan = $this->scanner->get_media_summary();
-				$result['summary'] = $full_scan;
-				$this->log( sprintf( 'Full scan completed. Total items: %d', $full_scan['total_count'] ?? 0 ) );
-				break;
-
-			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
-				$result['duplicates'] = $duplicates;
-				$result['count']      = count( $duplicates );
-				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
-				break;
-
-			case 'large_files':
-				$threshold_kb = $options['large_file_threshold_kb'] ?? ( $settings['large_file_threshold_kb'] ?? 1000 );
-				$large        = $this->large_files->find_large_files( $threshold_kb );
-				$total_bytes  = 0;
-
-				foreach ( $large as $file ) {
-					$total_bytes += $file['size'] ?? ( $file['current_size'] ?? 0 );
-				}
-
-				$result['large_files'] = $large;
-				$result['count']       = count( $large );
-				$result['total_bytes'] = $total_bytes;
-				$this->log( sprintf( 'Found %d large files', $result['count'] ) );
-				break;
-
-			case 'alt_text':
-				$limit       = $options['alt_text_limit'] ?? 100;
-				$missing_alt = $this->alt_text_checker->find_missing_alt_text( $limit );
-				$result['missing_alt'] = $missing_alt;
-				$result['count']       = count( $missing_alt );
-				$this->log( sprintf( 'Found %d images missing alt text', $result['count'] ) );
-				break;
-		}
-
-		return $result;
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -611,81 +505,6 @@
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
 		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Media/Tasks/MediaScanTask.php
@@ -480,2 +480,56 @@
 	/**
+	 * Execute a specific scan subtask.
+	 *
+	 * @since 1.6.0
+	 *
+	 * @param string $task     Task name.
+	 * @param array  $options  Task options.
+	 * @param array  $settings Plugin settings.
+	 * @return array Result with task-specific data.
+	 */
+	private function execute_subtask( string $task, array $options, array $settings ): array {
+		$result = array();
+
+		switch ( $task ) {
+			case 'summary':
+				$full_scan = $this->scanner->get_media_summary();
+				$result['summary'] = $full_scan;
+				$this->log( sprintf( 'Full scan completed. Total items: %d', $full_scan['total_count'] ?? 0 ) );
+				break;
+
+			case 'duplicates':
+				$duplicates = $this->duplicate_detector->find_duplicates();
+				$result['duplicates'] = $duplicates;
+				$result['count']      = count( $duplicates );
+				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
+				break;
+
+			case 'large_files':
+				$threshold_kb = $options['large_file_threshold_kb'] ?? ( $settings['large_file_threshold_kb'] ?? 1000 );
+				$large        = $this->large_files->find_large_files( $threshold_kb );
+				$total_bytes  = 0;
+
+				foreach ( $large as $file ) {
+					$total_bytes += $file['size'] ?? ( $file['current_size'] ?? 0 );
+				}
+
+				$result['large_files'] = $large;
+				$result['count']       = count( $large );
+				$result['total_bytes'] = $total_bytes;
+				$this->log( sprintf( 'Found %d large files', $result['count'] ) );
+				break;
+
+			case 'alt_text':
+				$limit       = $options['alt_text_limit'] ?? 100;
+				$missing_alt = $this->alt_text_checker->find_missing_alt_text( $limit );
+				$result['missing_alt'] = $missing_alt;
+				$result['count']       = count( $missing_alt );
+				$this->log( sprintf( 'Found %d images missing alt text', $result['count'] ) );
+				break;
+		}
+
+		return $result;
+	}
+
+	/**
 	 * Merge subtask results into the main scan results.
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M includes/Media/Tasks/MediaScanTask.php
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc 'rg -n "DEFAULT_BATCH_SIZE" includes/Media/Tasks/MediaScanTask.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 48ms:
56:	const DEFAULT_BATCH_SIZE = 100;
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..cd4965f0c8faedc1243440433547a0279c518d21
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,244 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		if ( '' !== $this->progress_option_key ) {
+			return $this->progress_option_key;
+		}
+
+		if ( '' === $this->task_id ) {
+			return '';
+		}
+
+		return 'wpha_' . $this->task_id . '_progress';
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.






thinking
**Evaluating code cleanliness**

I'm noticing that the constant DEFAULT_BATCH_SIZE is unused. It's probably okay, but it might get flagged by static analysis. I wonder if I should remove it since it was possibly intended for something. Keeping it could confuse others, but I prefer to maintain it for now, especially with the spec on incremental scanning. If I want a cleaner codebase, I could remove it and adjust the docblocks, though it’s not strictly necessary. I also need to ensure that DatabaseCleanupTask no longer defines get_progress since the base class provides it, even with visibility changes.
thinking
**Updating task methods**

I'm considering whether we need to update our plan, but I'll focus on ensuring that base method names don't conflict with other tasks or classes for now. I've added methods like load_progress, save_progress, and clear_progress in the base class. The DatabaseCleanupTask and MediaScanTask had private versions that I removed, which is good. 

Now, PerformanceCheckTask will inherit public methods from the base. Although the progress_option_key property defaults to an empty string, calling get_progress() on PerformanceCheckTask will try to get 'wpha_performance_check_progress', which may not exist. It will log a message if there's no saved progress, so I think it’s not a big issue.
thinking
**Clarifying progress handling**

I realized that load_progress relies on get_progress_option_key. Since the progress_option_key is empty, it will default to returning 'wpha_' followed by $task_id and '_progress', which isn't empty. This means that base methods effectively assume all tasks have progress by default. If external code sets the 'wpha_performance_check_progress', it could affect get_progress.

There's a question of whether tasks that don’t use progress should have this default option key. It could lead to stale options, but since both save_progress and clear_progress are protected, only tasks can call them. The public method reset_progress will still delete the 'wpha_performance_check_progress', which is fine. Also, has_pending_progress might return false for PerformanceCheckTask, so that seems good too!
thinking
**Considering progress handling design**

From an API perspective, all tasks now have progress methods and can interact with options, which seems acceptable. But I wonder if it might be better to modify the base class to disable progress unless the progress_option_key is set. That way, get_progress_option_key would return the specific key instead of a default pattern. 

Still, tasks that don’t set this property should return an empty string. Given that base methods are now public, I think avoiding potential side effects by default makes sense. However, the spec indicates the need for progress tracking, suggesting that the base should provide that flexibility but not enforce it. I’m leaning toward disabling progress by default, where progress methods become no-ops if progress_option_key is empty, but it’s essential to decide what’s best overall.
thinking
**Refining progress option handling**

I’m realizing that tasks like DatabaseCleanupTask don't match the default key pattern we set, while MediaScanTask does. For tasks that don't use progress, it's probably best not to create default keys. Adding progress methods could allow for watchers to call get_progress on any task and receive an empty response, but this might create unnecessary overhead from frequent get_option calls.

To align with our docblock, which states that leaving the key empty disables progress, we need to update get_progress_option_key to return an empty string if progress_option_key is empty. This change ensures that tasks without progress return empty, which is more consistent and respects our documentation. We can still provide a default pattern when the task explicitly sets a flag for enabling progress, but requiring the explicit key seems prudent overall. 

So, I'll implement changes to ensure get_progress_option_key only returns the specific progress_option_key, and I’ll also update the docblock accordingly. This way, tasks without progress methods will get an array response, avoiding any unnecessary get_option calls.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/AbstractScheduledTask.php
@@ -251,11 +251,3 @@
 	protected function get_progress_option_key(): string {
-		if ( '' !== $this->progress_option_key ) {
-			return $this->progress_option_key;
-		}
-
-		if ( '' === $this->task_id ) {
-			return '';
-		}
-
-		return 'wpha_' . $this->task_id . '_progress';
+		return $this->progress_option_key;
 	}
apply_patch(auto_approved=true) exited 0 in 48ms:
Success. Updated the following files:
M includes/Scheduler/AbstractScheduledTask.php
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..c322b8779eb01fa990449d59accf5399f3cd2533
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,236 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..c322b8779eb01fa990449d59accf5399f3cd2533
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,236 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$progress = $this->get_progress();
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.






thinking
**Evaluating progress handling**

I'm noticing that the base methods now treat an empty key as disabled, which aligns with the documentation. The tasks, like DatabaseCleanupTask and MediaScanTask, have set progress_option_key, which is good. I see that methods like get_progress will return an empty array if there's no progress, which leads to confusion. Should reset_progress return true when there's no progress key? Maybe it should, to prevent errors. I think adjusting it to return true when progress persistence is disabled might be the way to go.
thinking
**Clarifying progress behavior**

I'm realizing that tasks with progress call delete_option, which returns true if the option was deleted, and false if it wasn't. If there's no progress saved, reset might return false, and that could look like a failure. However, since tasks previously returned the delete_option result, I think we're good to keep that behavior. I need to ensure that load_progress uses get_progress_option_key, which now correctly returns an empty array for tasks without progress. Lastly, I should verify that is_time_limit_approaching uses the right time settings, especially since tasks will call the base method.
thinking
**Reviewing time limit settings**

I’m recognizing that tasks set their time_limit through configure_time_limit. The base method assigns time_limit using default values, but constructors no longer assign it, starting at 0. The configure_time_limit method sets time_limit to the minimum based on options, which is good. I see that tasks override the default to a constant of 25, which keeps things consistent. 

Additionally, the base method now accepts numeric strings for time limits, which is an improvement. Overall, the logic around time limits seems to align correctly, ensuring consistency across tasks.
thinking
**Examining time limit and progress**

I see that with max_execution_time set to 6 and a buffer of 3, the minimum will be 3, so that's fine. The time_limit would be 5 after calculations, which means is_time_limit_approaching uses this to create a threshold of 2 seconds, allowing 4 seconds of execution time remaining. We removed get_remaining_time from tasks, which is okay since the base has it. 

Now, for load_progress, DatabaseCleanupTask and MediaScanTask are set up correctly with their respective progress_option_keys, so that part is consistent. I noticed that we've shifted from using direct options to relying on load_progress, which logs "Resuming..." when there's progress, aligning smoothly with past behavior.
thinking
**Adjusting progress logging**

I'm realizing that the tasks originally had a simple way to check for progress without any logging, which was nice and quiet. Now, the base method for has_pending_progress calls get_progress, which logs "Resuming" if there's progress present. This could create unnecessary noise, especially since it's not heavily used elsewhere. However, if it’s being called by admin functions, that might be acceptable.

To reduce logging clutter, I could modify has_pending_progress to directly read the option value without logging. This approach could replicate the old behavior and keep things cleaner, so I'll patch that in accordingly. Reset_progress logging "Progress manually reset" seems fine too, so there’s no issue there.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Scheduler/AbstractScheduledTask.php
@@ -318,3 +318,8 @@
 	public function has_pending_progress(): bool {
-		$progress = $this->get_progress();
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
 		return ! empty( $progress );
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M includes/Scheduler/AbstractScheduledTask.php
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Searching for properties**

I'm looking to find the properties `$start_time` and `$time_limit` in other classes. My first thought is that there probably won't be any results, but it's worth checking to be sure. I want to make sure I gather all relevant information, so I’ll go ahead and conduct the search to see if anything comes up. Let's explore this together and check every option!
exec
/bin/zsh -lc "rg -n \"\\"'$start_time'"\\b|\\"'$time_limit'"\\b\" includes | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 59ms:

file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Researching regex matching**

I'm trying to understand why there are no matches. It seems that the dollar sign ($) could be a special character in the regex pattern. However, I’m thinking that `\b` may not work as expected. To troubleshoot this further, I’m planning to search specifically for 'start_time' and 'time_limit' to see if those terms yield any results. I’ll keep digging!
exec
/bin/zsh -lc 'rg -n "start_time" includes | head -n 50 && rg -n "time_limit" includes | head -n 50' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
includes/Media/Tasks/MediaScanTask.php:200:		$this->start_time = microtime( true );
includes/Media/Tasks/MediaScanTask.php:321:		$elapsed_time = microtime( true ) - $this->start_time;
includes/Performance/AjaxMonitor.php:69:	private ?float $request_start_time = null;
includes/Performance/AjaxMonitor.php:130:		$this->request_start_time   = microtime( true );
includes/Performance/AjaxMonitor.php:148:		if ( null === $this->request_start_time || null === $this->request_start_memory ) {
includes/Performance/AjaxMonitor.php:153:		$execution_time = ( microtime( true ) - $this->request_start_time ) * 1000; // Convert to milliseconds.
includes/Performance/AjaxMonitor.php:258:		$since = $this->get_period_start_time( $period );
includes/Performance/AjaxMonitor.php:329:		$since = $this->get_period_start_time( $period );
includes/Performance/AjaxMonitor.php:381:		$since = $this->get_period_start_time( $period );
includes/Performance/AjaxMonitor.php:429:		$since = $this->get_period_start_time( $period );
includes/Performance/AjaxMonitor.php:552:	private function get_period_start_time( $period ) {
includes/Scheduler/AbstractScheduledTask.php:70:	protected float $start_time = 0.0;
includes/Scheduler/AbstractScheduledTask.php:168:		$this->start_time = microtime( true );
includes/Scheduler/AbstractScheduledTask.php:224:		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
includes/Scheduler/AbstractScheduledTask.php:228:		$elapsed = microtime( true ) - $this->start_time;
includes/Scheduler/AbstractScheduledTask.php:238:		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
includes/Scheduler/AbstractScheduledTask.php:242:		$elapsed = microtime( true ) - $this->start_time;
includes/Database/Tasks/DatabaseCleanupTask.php:180:		$this->start_time = microtime( true );
includes/Database/Tasks/DatabaseCleanupTask.php:293:		$elapsed_time = microtime( true ) - $this->start_time;
includes/Media/Tasks/MediaScanTask.php:119:	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc 'php -l includes/Scheduler/AbstractScheduledTask.php && php -l includes/Database/Tasks/DatabaseCleanupTask.php && php -l includes/Media/Tasks/MediaScanTask.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 182ms:
No syntax errors detected in includes/Scheduler/AbstractScheduledTask.php
No syntax errors detected in includes/Database/Tasks/DatabaseCleanupTask.php
No syntax errors detected in includes/Media/Tasks/MediaScanTask.php
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc 'npm run lint' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 2.16s:

> wp-admin-health-suite@1.0.0 lint
> eslint assets/js --ext .js,.jsx


/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/admin.js
    7:1  warning  Missing JSDoc @param "window" type    jsdoc/require-param-type
    8:1  warning  Missing JSDoc @param "$" type         jsdoc/require-param-type
  276:1  warning  Missing JSDoc @param "message" type   jsdoc/require-param-type
  277:1  warning  Missing JSDoc @param "duration" type  jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/charts.js
  7:1  warning  Missing JSDoc @param "window" type  jsdoc/require-param-type
  8:1  warning  Missing JSDoc @param "$" type       jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/HealthScoreCircle.jsx
  31:30  warning  'score' is missing in props validation    react/prop-types
  31:41  warning  'grade' is missing in props validation    react/prop-types
  31:54  warning  'loading' is missing in props validation  react/prop-types
  57:1   warning  Missing JSDoc @param "timestamp" type     jsdoc/require-param-type
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
I see that the linting process passed with an exit code of 0, which is great! Although there are some warnings, it seems like everything is generally fine. Now, it looks like the next step is to run the npm test. I guess I’ll do that to make sure everything is working as expected. Fingers crossed there are no issues there! Let's hope for smooth sailing ahead!
exec
/bin/zsh -lc 'npm test' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.62s:

> wp-admin-health-suite@1.0.0 test
> jest --passWithNoTests

PASS assets/js/components/QuickActions.test.jsx
PASS assets/js/components/ActivityTimeline.test.jsx
  ● Console

    console.error
      Warning: An update to ActivityTimeline inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at ActivityTimeline (/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/ActivityTimeline.jsx:108:46)
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Updating project steps**

I’m planning to call update_plan to mark step 3 as completed, step 4 as in progress, and step 5 as pending. After that, I’ll call update_plan again to move step 4 to completed and step 5 to in progress. Finally, I’ll mark step 5 as completed later. It’s great to note that step 3, "Implement required changes," and step 4, "Run lint and tests," are done, so now I can focus on step 5.
Plan update
  ✓ Read spec and handoff
  ✓ Inspect existing code paths
  ✓ Implement required changes
  → Run lint and tests
  • Summarize and hand off
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

Plan update
  ✓ Read spec and handoff
  ✓ Inspect existing code paths
  ✓ Implement required changes
  ✓ Run lint and tests
  → Summarize and hand off
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Summarizing updates**

I’m at the final step of summarizing everything. I need to consider if any documents or tests require updates. I think I should check the differences to ensure that the changes are both correct and minimal. To do this, I’ll run a git diff command. This feels like an important task to make sure everything is in order before moving forward!
exec
/bin/zsh -lc "git diff --stat && echo '---' && git diff" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 88ms:
 .t2/state.json                                  |   5 +-
 includes/Database/Tasks/DatabaseCleanupTask.php | 195 +++-------------
 includes/Media/Tasks/MediaScanTask.php          | 185 +++------------
 includes/Scheduler/AbstractScheduledTask.php    | 290 +++++++++++++++++++++++-
 4 files changed, 348 insertions(+), 327 deletions(-)
---
diff --git a/.t2/state.json b/.t2/state.json
index bdc762f..4f81d52 100644
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -44,7 +44,8 @@
     "Q07-04",
     "Q07-05",
     "Q07-06",
-    "Q07-07"
+    "Q07-07",
+    "Q08-01"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc 'cat .t2/state.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:
{
  "completed_task_ids": [
    "Q01-01",
    "Q01-02",
    "Q01-03",
    "Q01-04",
    "Q01-05",
    "Q02-01",
    "Q02-02",
    "Q02-03",
    "Q02-04",
    "Q02-05",
    "Q02-06",
    "Q02-07",
    "Q02-08",
    "Q02-09",
    "Q03-01",
    "Q03-02",
    "Q03-03",
    "Q03-04",
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.



thinking
**Considering updates and file states**

Since we're implementing Q08-02, it might make sense to update the file to reflect that as completed and adjust the updated_at timestamp. The user hasn't mentioned it, but the tasks system could expect such an update. Our final response should indicate completion, which suggests we could track it in this file. While it could lead to some confusion if the file's purpose varies, keeping it updated seems beneficial. I think I’ll lean towards updating it to include Q08-02.
thinking
**Updating task states**

Since we're focusing on task Q08-02, it seems fitting to add it to the completed_task_ids in .t2/state.json. Keeping it partially updated with only Q08-01 would feel inconsistent. We should incorporate Q08-02 to reflect our progress, and it would be good to update the timestamp to the current time as well. I wonder if the tasks list should specifically include completed tasks, but adding Q08-02 now aligns with our goals. So, I'll make those updates accordingly!
exec
/bin/zsh -lc 'date -u +"%Y-%m-%dT%H:%M:%S.%6NZ"' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
2026-01-17T09:16:27.6NZ
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

exec
/bin/zsh -lc 'node -e "console.log(new Date().toISOString())"' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 111ms:
2026-01-17T09:16:35.311Z
file update:
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Patching JSON file**

I need to use the timestamp to update the `.t2/state.json` file. I'll be adding "Q08-02" at the end and ensuring that the `updated_at` field is current. Keeping the JSON formatting intact is crucial so the file remains valid. It seems like a straightforward patching task. However, I should double-check to make sure the syntax and structure are correct when I apply the changes.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/.t2/state.json
@@ -47,3 +47,4 @@
     "Q07-07",
-    "Q08-01"
+    "Q08-01",
+    "Q08-02"
   ],
@@ -86,3 +87,3 @@
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T08:59:45.958246Z"
+  "updated_at": "2026-01-17T09:16:35.311Z"
 }
apply_patch(auto_approved=true) exited 0 in 52ms:
Success. Updated the following files:
M .t2/state.json
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4f81d52fcc6de3c8d5f9c97d75a0aaeaa373437a..54ffd72b00243351c670d90e5203ef2b66c244be
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -45,7 +45,8 @@
     "Q07-05",
     "Q07-06",
     "Q07-07",
-    "Q08-01"
+    "Q08-01",
+    "Q08-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -84,5 +85,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T08:59:45.958246Z"
+  "updated_at": "2026-01-17T09:16:35.311Z"
 }
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4f81d52fcc6de3c8d5f9c97d75a0aaeaa373437a..54ffd72b00243351c670d90e5203ef2b66c244be
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -45,7 +45,8 @@
     "Q07-05",
     "Q07-06",
     "Q07-07",
-    "Q08-01"
+    "Q08-01",
+    "Q08-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -84,5 +85,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T08:59:45.958246Z"
+  "updated_at": "2026-01-17T09:16:35.311Z"
 }
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Checking file modifications**

I see that the state file includes Q08-02, which is good. The git diff tells me about those modifications, and that's great! Now, I need to make sure that there aren't any other unintended changes in the files. I'll run git diff --stat again to double-check and ensure everything looks as it should. It's always better to be thorough, right? That way, I can catch anything unexpected!
exec
/bin/zsh -lc 'git diff --stat' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 79ms:
 .t2/state.json                                  |   6 +-
 includes/Database/Tasks/DatabaseCleanupTask.php | 195 +++-------------
 includes/Media/Tasks/MediaScanTask.php          | 185 +++------------
 includes/Scheduler/AbstractScheduledTask.php    | 290 +++++++++++++++++++++++-
 4 files changed, 349 insertions(+), 327 deletions(-)
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4f81d52fcc6de3c8d5f9c97d75a0aaeaa373437a..54ffd72b00243351c670d90e5203ef2b66c244be
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -45,7 +45,8 @@
     "Q07-05",
     "Q07-06",
     "Q07-07",
-    "Q08-01"
+    "Q08-01",
+    "Q08-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -84,5 +85,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T08:59:45.958246Z"
+  "updated_at": "2026-01-17T09:16:35.311Z"
 }
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.


thinking
**Updating final step**

I think I should include the exact commands we've already run to keep everything consistent. I also want to note that running `npm run lint` gives us warnings but no errors, and while Jest passes, it shows some console errors. That’s okay, though! Now, I need to remember to call `update_plan` to mark this final step as completed. Let’s make sure everything is in order before we wrap this up!
Plan update
  ✓ Read spec and handoff
  ✓ Inspect existing code paths
  ✓ Implement required changes
  ✓ Run lint and tests
  ✓ Summarize and hand off
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4f81d52fcc6de3c8d5f9c97d75a0aaeaa373437a..54ffd72b00243351c670d90e5203ef2b66c244be
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -45,7 +45,8 @@
     "Q07-05",
     "Q07-06",
     "Q07-07",
-    "Q08-01"
+    "Q08-01",
+    "Q08-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -84,5 +85,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T08:59:45.958246Z"
+  "updated_at": "2026-01-17T09:16:35.311Z"
 }
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

codex
**Status:** DONE

**Summary of changes**
- Added long-running task helpers to `includes/Scheduler/AbstractScheduledTask.php` (timeout setup/checks, progress load/save/clear, standardized exception logging + `execute_with_recovery()`).
- Refactored `includes/Database/Tasks/DatabaseCleanupTask.php` and `includes/Media/Tasks/MediaScanTask.php` to use the shared base implementations (removes duplicated timeout/progress/error-recovery code).
- Marked Q08-02 as completed in `.t2/state.json`.

**How to verify**
- `npm run lint`
- `npm test`

**Risks / follow-ups**
- Behavioral change: `time_limit` overrides now accept digit strings (e.g. `"25"`) in addition to ints; should be low-risk.
- No PHP test coverage here; if you want, I can add minimal PHP unit/smoke checks around the new base helpers.
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4f81d52fcc6de3c8d5f9c97d75a0aaeaa373437a..54ffd72b00243351c670d90e5203ef2b66c244be
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -45,7 +45,8 @@
     "Q07-05",
     "Q07-06",
     "Q07-07",
-    "Q08-01"
+    "Q08-01",
+    "Q08-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -84,5 +85,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T08:59:45.958246Z"
+  "updated_at": "2026-01-17T09:16:35.311Z"
 }
diff --git a/includes/Database/Tasks/DatabaseCleanupTask.php b/includes/Database/Tasks/DatabaseCleanupTask.php
index 9d07a4f09eb1372d71d08b7439e5d7a5487d2286..62ab74d3be64eb17144f0382261e9e4038375b8b
--- a/includes/Database/Tasks/DatabaseCleanupTask.php
+++ b/includes/Database/Tasks/DatabaseCleanupTask.php
@@ -92,6 +92,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_db_cleanup';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Revisions manager.
 	 *
 	 * @var RevisionsManagerInterface
@@ -127,20 +148,6 @@
 	private OptimizerInterface $optimizer;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param RevisionsManagerInterface  $revisions_manager  Revisions manager.
@@ -161,7 +168,6 @@
 		$this->orphaned_cleaner   = $orphaned_cleaner;
 		$this->trash_cleaner      = $trash_cleaner;
 		$this->optimizer          = $optimizer;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -369,67 +375,9 @@
 		}
 
 		return $cleanup_tasks;
-	}
-
-	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
 	}
 
 	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
-	 * Get the remaining time in seconds.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return float Remaining time in seconds.
-	 */
-	private function get_remaining_time(): float {
-		$elapsed = microtime( true ) - $this->start_time;
-		return max( 0, $this->time_limit - $elapsed - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Execute a subtask with error recovery.
 	 *
 	 * Wraps subtask execution in a try-catch block to prevent individual
@@ -442,101 +390,16 @@
 	 * @return array Result with 'items', 'bytes', and optionally 'error' keys.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options ): array {
-		try {
-			return $this->execute_subtask( $task, $options );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
+		return $this->execute_with_recovery(
+			function () use ( $task, $options ): array {
+				return $this->execute_subtask( $task, $options );
+			},
+			array(
 				'items' => 0,
 				'bytes' => 0,
-				'error' => $e->getMessage(),
-			);
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
-		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.5.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
+			),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
diff --git a/includes/Media/Tasks/MediaScanTask.php b/includes/Media/Tasks/MediaScanTask.php
index df393a86fa69d4adb3db6405f29adcf1f05d4f18..093882fdd2940e432ff57f2613278fc101a42b1d
--- a/includes/Media/Tasks/MediaScanTask.php
+++ b/includes/Media/Tasks/MediaScanTask.php
@@ -112,6 +112,27 @@
 	protected string $enabled_option_key = 'enable_scheduled_media_scan';
 
 	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = self::DEFAULT_TIME_LIMIT;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = self::TIME_BUFFER;
+
+	/**
+	 * {@inheritdoc}
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = self::PROGRESS_OPTION_KEY;
+
+	/**
 	 * Database connection.
 	 *
 	 * @var ConnectionInterface
@@ -147,20 +168,6 @@
 	private AltTextCheckerInterface $alt_text_checker;
 
 	/**
-	 * Start time of the current execution.
-	 *
-	 * @var float
-	 */
-	private float $start_time = 0.0;
-
-	/**
-	 * Time limit for the current execution in seconds.
-	 *
-	 * @var int
-	 */
-	private int $time_limit;
-
-	/**
 	 * Constructor.
 	 *
 	 * @param ConnectionInterface        $connection         Database connection.
@@ -181,7 +188,6 @@
 		$this->duplicate_detector = $duplicate_detector;
 		$this->large_files        = $large_files;
 		$this->alt_text_checker   = $alt_text_checker;
-		$this->time_limit         = self::DEFAULT_TIME_LIMIT;
 	}
 
 	/**
@@ -376,52 +382,6 @@
 	}
 
 	/**
-	 * Configure the time limit based on PHP settings and options.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $options Task options.
-	 * @return void
-	 */
-	private function configure_time_limit( array $options ): void {
-		// Allow overriding via options (useful for manual runs or testing).
-		if ( isset( $options['time_limit'] ) && is_int( $options['time_limit'] ) ) {
-			$this->time_limit = $options['time_limit'];
-			return;
-		}
-
-		// Try to determine the PHP max_execution_time.
-		$max_execution_time = (int) ini_get( 'max_execution_time' );
-
-		// If max_execution_time is 0 (unlimited) or not set, use our default.
-		if ( $max_execution_time <= 0 ) {
-			$this->time_limit = self::DEFAULT_TIME_LIMIT;
-			return;
-		}
-
-		// Use the smaller of PHP's limit (minus buffer) or our default.
-		$this->time_limit = min(
-			$max_execution_time - self::TIME_BUFFER,
-			self::DEFAULT_TIME_LIMIT
-		);
-
-		// Ensure we have at least some time to work.
-		$this->time_limit = max( $this->time_limit, 5 );
-	}
-
-	/**
-	 * Check if the time limit is approaching.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if we should stop processing.
-	 */
-	private function is_time_limit_approaching(): bool {
-		$elapsed = microtime( true ) - $this->start_time;
-		return $elapsed >= ( $this->time_limit - self::TIME_BUFFER );
-	}
-
-	/**
 	 * Acquire a lock to prevent concurrent scans.
 	 *
 	 * @since 1.6.0
@@ -508,24 +468,13 @@
 	 * @return array Result with task-specific data and optionally 'error' key.
 	 */
 	private function execute_subtask_with_recovery( string $task, array $options, array $settings ): array {
-		try {
-			return $this->execute_subtask( $task, $options, $settings );
-		} catch ( \Throwable $e ) {
-			$this->log(
-				sprintf(
-					'Exception in subtask %s: %s in %s:%d',
-					$task,
-					$e->getMessage(),
-					$e->getFile(),
-					$e->getLine()
-				),
-				'error'
-			);
-
-			return array(
-				'error' => $e->getMessage(),
-			);
-		}
+		return $this->execute_with_recovery(
+			function () use ( $task, $options, $settings ): array {
+				return $this->execute_subtask( $task, $options, $settings );
+			},
+			array(),
+			sprintf( 'subtask %s', $task )
+		);
 	}
 
 	/**
@@ -549,8 +498,7 @@
 				break;
 
 			case 'duplicates':
-				$batch_size  = $options['batch_size'] ?? self::DEFAULT_BATCH_SIZE;
-				$duplicates  = $this->duplicate_detector->find_duplicates();
+				$duplicates = $this->duplicate_detector->find_duplicates();
 				$result['duplicates'] = $duplicates;
 				$result['count']      = count( $duplicates );
 				$this->log( sprintf( 'Found %d duplicate files', $result['count'] ) );
@@ -610,82 +558,7 @@
 				$scan_results['missing_alt']    = $result['missing_alt'] ?? array();
 				$scan_results['total_issues']  += $result['count'] ?? 0;
 				break;
-		}
-	}
-
-	/**
-	 * Load saved progress from a previous interrupted run.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Progress data or empty array.
-	 */
-	private function load_progress(): array {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-
-		if ( ! empty( $progress ) && is_array( $progress ) ) {
-			$this->log( 'Resuming from saved progress' );
 		}
-
-		return is_array( $progress ) ? $progress : array();
-	}
-
-	/**
-	 * Save progress for later continuation.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @param array $progress Progress data to save.
-	 * @return bool True on success, false on failure.
-	 */
-	private function save_progress( array $progress ): bool {
-		return update_option( self::PROGRESS_OPTION_KEY, $progress, false );
-	}
-
-	/**
-	 * Clear saved progress.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success, false on failure.
-	 */
-	private function clear_progress(): bool {
-		return delete_option( self::PROGRESS_OPTION_KEY );
-	}
-
-	/**
-	 * Get the current progress for external monitoring.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return array Current progress data.
-	 */
-	public function get_progress(): array {
-		return $this->load_progress();
-	}
-
-	/**
-	 * Check if a previous run was interrupted and needs resuming.
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True if there's saved progress to resume.
-	 */
-	public function has_pending_progress(): bool {
-		$progress = get_option( self::PROGRESS_OPTION_KEY, array() );
-		return ! empty( $progress );
-	}
-
-	/**
-	 * Force clear any saved progress (useful for admin reset).
-	 *
-	 * @since 1.6.0
-	 *
-	 * @return bool True on success.
-	 */
-	public function reset_progress(): bool {
-		$this->log( 'Progress manually reset' );
-		return $this->clear_progress();
 	}
 
 	/**
diff --git a/includes/Scheduler/AbstractScheduledTask.php b/includes/Scheduler/AbstractScheduledTask.php
index 5efca43a1d807c2a3c2c92d8f3b5d04a9290acbc..f111e5dded126065eab42b5bc72e160902f66f4e
--- a/includes/Scheduler/AbstractScheduledTask.php
+++ b/includes/Scheduler/AbstractScheduledTask.php
@@ -30,21 +30,21 @@
 	 *
 	 * @var string
 	 */
-	protected string $task_id;
+	protected string $task_id = '';
 
 	/**
 	 * Task name.
 	 *
 	 * @var string
 	 */
-	protected string $task_name;
+	protected string $task_name = '';
 
 	/**
 	 * Task description.
 	 *
 	 * @var string
 	 */
-	protected string $description;
+	protected string $description = '';
 
 	/**
 	 * Default frequency.
@@ -61,6 +61,55 @@
 	protected string $enabled_option_key = '';
 
 	/**
+	 * Start time of the current execution.
+	 *
+	 * Used by long-running tasks for timeout management.
+	 *
+	 * @var float
+	 */
+	protected float $start_time = 0.0;
+
+	/**
+	 * Time limit for the current execution in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $time_limit = 0;
+
+	/**
+	 * Default time limit in seconds for long-running tasks.
+	 *
+	 * @var int
+	 */
+	protected int $default_time_limit = 25;
+
+	/**
+	 * Safety buffer in seconds to stop before hitting the time limit.
+	 *
+	 * Used both for deriving an effective time limit from PHP max_execution_time
+	 * and for deciding when to stop processing.
+	 *
+	 * @var int
+	 */
+	protected int $time_buffer = 3;
+
+	/**
+	 * Minimum effective time limit in seconds.
+	 *
+	 * @var int
+	 */
+	protected int $minimum_time_limit = 5;
+
+	/**
+	 * Option key for persisting task progress.
+	 *
+	 * Leave empty to disable progress persistence.
+	 *
+	 * @var string
+	 */
+	protected string $progress_option_key = '';
+
+	/**
 	 * {@inheritdoc}
 	 */
 	public function get_task_id(): string {
@@ -108,6 +157,241 @@
 	}
 
 	/**
+	 * Initialize execution context for long-running tasks.
+	 *
+	 * Sets the start time and configures the time limit.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function init_execution_context( array $options = array() ): void {
+		$this->start_time = microtime( true );
+		$this->configure_time_limit( $options );
+	}
+
+	/**
+	 * Configure the time limit based on PHP settings and options.
+	 *
+	 * Supports an optional `time_limit` override in `$options` for manual runs/tests.
+	 *
+	 * @param array $options Task options.
+	 * @return void
+	 */
+	protected function configure_time_limit( array $options = array() ): void {
+		// Allow overriding via options (useful for manual runs or testing).
+		if ( array_key_exists( 'time_limit', $options ) ) {
+			$raw_time_limit = $options['time_limit'];
+
+			if ( is_int( $raw_time_limit ) && $raw_time_limit > 0 ) {
+				$this->time_limit = $raw_time_limit;
+				return;
+			}
+
+			if ( is_string( $raw_time_limit ) && ctype_digit( $raw_time_limit ) ) {
+				$time_limit = (int) $raw_time_limit;
+				if ( $time_limit > 0 ) {
+					$this->time_limit = $time_limit;
+					return;
+				}
+			}
+		}
+
+		// Try to determine the PHP max_execution_time.
+		$max_execution_time = (int) ini_get( 'max_execution_time' );
+
+		// If max_execution_time is 0 (unlimited) or not set, use our default.
+		if ( $max_execution_time <= 0 ) {
+			$this->time_limit = max( $this->default_time_limit, $this->minimum_time_limit );
+			return;
+		}
+
+		// Use the smaller of PHP's limit (minus buffer) or our default.
+		$this->time_limit = min(
+			$max_execution_time - $this->time_buffer,
+			$this->default_time_limit
+		);
+
+		// Ensure we have at least some time to work.
+		$this->time_limit = max( $this->time_limit, $this->minimum_time_limit );
+	}
+
+	/**
+	 * Check if the time limit is approaching.
+	 *
+	 * @return bool True if we should stop processing.
+	 */
+	protected function is_time_limit_approaching(): bool {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return false;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return $elapsed >= ( $this->time_limit - $this->time_buffer );
+	}
+
+	/**
+	 * Get the remaining time in seconds.
+	 *
+	 * @return float Remaining time in seconds.
+	 */
+	protected function get_remaining_time(): float {
+		if ( $this->start_time <= 0.0 || $this->time_limit <= 0 ) {
+			return 0.0;
+		}
+
+		$elapsed = microtime( true ) - $this->start_time;
+		return max( 0, $this->time_limit - $elapsed - $this->time_buffer );
+	}
+
+	/**
+	 * Get the option key used for persisting task progress.
+	 *
+	 * @return string Progress option key or empty string when disabled.
+	 */
+	protected function get_progress_option_key(): string {
+		return $this->progress_option_key;
+	}
+
+	/**
+	 * Load saved progress from a previous interrupted run.
+	 *
+	 * @return array Progress data or empty array.
+	 */
+	protected function load_progress(): array {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return array();
+		}
+
+		$progress = get_option( $option_key, array() );
+
+		if ( ! empty( $progress ) && is_array( $progress ) ) {
+			$this->log( 'Resuming from saved progress' );
+		}
+
+		return is_array( $progress ) ? $progress : array();
+	}
+
+	/**
+	 * Save progress for later continuation.
+	 *
+	 * @param array $progress Progress data to save.
+	 * @return bool True on success, false on failure.
+	 */
+	protected function save_progress( array $progress ): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return update_option( $option_key, $progress, false );
+	}
+
+	/**
+	 * Clear saved progress.
+	 *
+	 * @return bool True on success, false on failure.
+	 */
+	protected function clear_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		return delete_option( $option_key );
+	}
+
+	/**
+	 * Get the current progress for external monitoring.
+	 *
+	 * @return array Current progress data.
+	 */
+	public function get_progress(): array {
+		return $this->load_progress();
+	}
+
+	/**
+	 * Check if a previous run was interrupted and needs resuming.
+	 *
+	 * @return bool True if there's saved progress to resume.
+	 */
+	public function has_pending_progress(): bool {
+		$option_key = $this->get_progress_option_key();
+		if ( '' === $option_key ) {
+			return false;
+		}
+
+		$progress = get_option( $option_key, array() );
+		return ! empty( $progress );
+	}
+
+	/**
+	 * Force clear any saved progress (useful for admin reset).
+	 *
+	 * @return bool True on success.
+	 */
+	public function reset_progress(): bool {
+		$this->log( 'Progress manually reset' );
+		return $this->clear_progress();
+	}
+
+	/**
+	 * Execute a callback with error recovery.
+	 *
+	 * @param callable $callback Callback to execute.
+	 * @param array    $fallback Fallback result returned on exception.
+	 * @param string   $context  Optional context for logging (e.g., "subtask revisions").
+	 * @return array Callback result, or fallback with an added 'error' key.
+	 */
+	protected function execute_with_recovery( callable $callback, array $fallback, string $context = '' ): array {
+		try {
+			$result = $callback();
+			return is_array( $result ) ? $result : $fallback;
+		} catch ( \Throwable $e ) {
+			$this->log_exception( $e, $context );
+
+			if ( ! array_key_exists( 'error', $fallback ) ) {
+				$fallback['error'] = $e->getMessage();
+			}
+
+			return $fallback;
+		}
+	}
+
+	/**
+	 * Log an exception in a consistent format.
+	 *
+	 * @param \Throwable $exception Exception instance.
+	 * @param string     $context   Optional context string.
+	 * @return void
+	 */
+	protected function log_exception( \Throwable $exception, string $context = '' ): void {
+		if ( '' === $context ) {
+			$this->log(
+				sprintf(
+					'Exception: %s in %s:%d',
+					$exception->getMessage(),
+					$exception->getFile(),
+					$exception->getLine()
+				),
+				'error'
+			);
+			return;
+		}
+
+		$this->log(
+			sprintf(
+				'Exception in %s: %s in %s:%d',
+				$context,
+				$exception->getMessage(),
+				$exception->getFile(),
+				$exception->getLine()
+			),
+			'error'
+		);
+	}
+
+	/**
 	 * Create a standard result array.
 	 *
 	 * @param int  $items_cleaned Number of items cleaned.

tokens used
286,120
