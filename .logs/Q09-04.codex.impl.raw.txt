Status: DONE

Summary of changes:
- Updated `includes/Integrations/Acf.php` to detect ACF media usage across `image`, `file`, and especially `gallery` fields (serialized arrays + JSON arrays/objects), including nested Repeater/Group/Flexible Content sub-fields by filtering to ACF media fields via the `_field_name` → `field_...` references.
- Cached ACF media field-key discovery to avoid repeatedly parsing field groups.
- Added standalone coverage: enhanced `tests/bootstrap-standalone.php` stubs and added `tests/unit-standalone/Integration/AcfIntegrationTest.php` to verify nested field-key extraction + gallery detection + labeled context.

How to verify:
- `npm run lint`
- `npm test`

Risks / follow-ups:
- `check_acf_image_usage()` intentionally uses broad LIKE patterns (including serialized `i:<id>;`) to avoid false negatives; this can yield false positives for small IDs that appear as serialized array indexes, which is safer for “unused media” deletion but may under-report unused media in edge cases.

OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite
model: gpt-5.2
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: xhigh
reasoning summaries: auto
session id: 019bcb8c-2401-7c81-9687-4a9d6f37a606
--------
user
You are implementing task Q09-04 in this git repository.

1) Read the spec: .plans/Q09-04.md
2) Read handoff/context: .t2/handoff/Q09-04.md

Implement the spec fully.

Verification commands (run if non-empty):
- format: 
- lint: npm run lint
- test: npm test

In your final response, include:
- Status: DONE or NEEDS-REVIEW
- Summary of changes
- How to verify (exact commands)
- Risks / follow-ups

mcp startup: no servers
exec
/bin/zsh -lc 'ls -la' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
total 2208
drwxr-xr-x   55 ahmedyounis  staff    1760 Jan 16 09:09 .
drwxr-xr-x   43 ahmedyounis  staff    1376 Jan 11 22:56 ..
-rw-------@   1 ahmedyounis  staff     189 Jan  7 14:37 .babelrc
-rw-r--r--@   1 ahmedyounis  staff    1286 Jan  8 22:57 .eslintrc.json
drwxr-xr-x   14 ahmedyounis  staff     448 Jan 17 02:41 .git
drwxr-xr-x@   3 ahmedyounis  staff      96 Jan 14 06:48 .github
-rw-------@   1 ahmedyounis  staff     346 Jan  8 22:53 .gitignore
drwxr-xr-x@   4 ahmedyounis  staff     128 Jan  7 17:43 .husky
drwxr-xr-x@  10 ahmedyounis  staff     320 Jan 16 23:08 .idea
drwxr-xr-x@ 406 ahmedyounis  staff   12992 Jan 17 02:41 .logs
-rw-r--r--@   1 ahmedyounis  staff   28892 Jan 16 22:58 .phpunit.result.cache
drwxr-xr-x@ 136 ahmedyounis  staff    4352 Jan 17 02:41 .plans
-rw-r--r--@   1 ahmedyounis  staff     119 Jan  7 17:43 .prettierignore
-rw-r--r--@   1 ahmedyounis  staff     409 Jan  8 22:57 .prettierrc.json
drwx------@   3 ahmedyounis  staff      96 Jan  7 14:59 .scripts
drwxr-xr-x@   6 ahmedyounis  staff     192 Jan 16 06:56 .t2
-rw-r--r--@   1 ahmedyounis  staff    9207 Jan  8 22:57 ACCESSIBILITY.md
drwxr-xr-x@   4 ahmedyounis  staff     128 Jan  9 00:36 admin
drwxr-xr-x@   6 ahmedyounis  staff     192 Jan  7 10:29 assets

thinking
I'm considering that I need to read AGENTS.md since the user gave root instructions about it. There might be an actual file, but it looks like they’ve also provided the content for me. I want to be sure to obey their guidelines. I’ll check out the plans in .plans/Q09-04.md and .t2/handoff/Q09-04.md to see what they contain and how to proceed. There's a lot to unpack here!
exec
/bin/zsh -lc "sed -n '1,200p' .plans/Q09-04.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
# Q09-04 — ACF Integration Review

Review includes/integrations/Acf.php for ACF field media detection across image, gallery, file, and flexible content fields. Verify Repeater and Group field support.
exec
/bin/zsh -lc "sed -n '200,400p' .plans/Q09-04.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:


thinking
**Reviewing ACF integration**

I'm looking into the ACF field media detection across various field types, including image, gallery, file, and flexible content. It seems there’s a potential bug related to detecting media within repeater or group fields. This means I’ll need to review the integration code and make some adjustments. After that, I'll check the handoff file for more details to ensure everything is in order. Let's keep this organized!
exec
/bin/zsh -lc "sed -n '1,200p' .t2/handoff/Q09-04.md" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 72ms:
# Handoff: Q09-04

Created: 2026-01-17T10:41:57.735648Z

Spec: .plans/Q09-04.md
exec
/bin/zsh -lc "sed -n '1,200p' includes/integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
<?php
/**
 * Advanced Custom Fields (ACF) Integration Class
 *
 * Provides ACF-specific media reference detection for image, gallery, and file fields.
 * Handles repeater and flexible content fields with nested images.
 * Only loads when ACF is active.
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth\Integrations;

use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\CacheInterface;
use WPAdminHealth\Contracts\MediaAwareIntegrationInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
exec
/bin/zsh -lc "sed -n '200,400p' includes/integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
	 * Recursively processes fields to find all media-type fields,
	 * including those nested in repeaters, flexible content, and groups.
	 *
	 * @since 1.0.0
	 *
	 * @param array<array{type?: string, key?: string, sub_fields?: array, layouts?: array}> $fields Array of ACF fields.
	 * @return array<string> Array of media field keys.
	 */
	private function extract_media_fields( array $fields ): array {
		$media_fields = array();

		foreach ( $fields as $field ) {
			// Check if this field is a media type.
			if ( isset( $field['type'] ) && in_array( $field['type'], self::MEDIA_FIELD_TYPES, true ) ) {
				$media_fields[] = $field['key'];
			}

			// Check for nested fields in repeater, flexible content, or group.
			if ( isset( $field['type'] ) && in_array( $field['type'], self::NESTED_FIELD_TYPES, true ) ) {
				$sub_fields = array();
exec
/bin/zsh -lc "sed -n '400,600p' includes/integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
	private function search_acf_data_structure( $data, int $attachment_id ): bool {
		// Direct ID match.
		if ( is_numeric( $data ) && absint( $data ) === absint( $attachment_id ) ) {
			return true;
		}

		if ( ! is_array( $data ) ) {
			return false;
		}

		// Check for ACF image object format (has 'id' or 'ID' key).
		if ( isset( $data['id'] ) && absint( $data['id'] ) === absint( $attachment_id ) ) {
			return true;
		}

		if ( isset( $data['ID'] ) && absint( $data['ID'] ) === absint( $attachment_id ) ) {
			return true;
		}

		// Recursively search array values.
exec
/bin/zsh -lc "sed -n '600,800p' includes/integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:

		return $post && 'attachment' === $post->post_type;
	}

	/**
	 * Check if an attachment is used by ACF fields.
	 *
	 * @since 1.1.0
	 *
	 * @param int $attachment_id The attachment ID.
	 * @return bool True if the attachment is used in ACF fields.
	 */
	public function is_attachment_used( int $attachment_id ): bool {
		return $this->check_acf_image_usage( false, $attachment_id );
	}

	/**
	 * Get all attachment IDs used in ACF fields.
	 *
	 * Scans ACF field data for image/gallery/file references using batch processing.
exec
/bin/zsh -lc "sed -n '800,1000p' includes/integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:

		if ( isset( $data['ID'] ) && is_numeric( $data['ID'] ) ) {
			$ids[] = absint( $data['ID'] );
		}

		// Recursively search array values.
		foreach ( $data as $value ) {
			$ids = array_merge( $ids, $this->collect_ids_from_acf_structure( $value ) );
		}

		return $ids;
	}

	/**
	 * Get the context description for an ACF field usage.
	 *
	 * @since 1.1.0
	 *
	 * @param string $meta_key      The meta key.
	 * @param mixed  $meta_value    The meta value.

thinking
**Reviewing integration specs**

I need to focus on detecting across images, galleries, files, and flexible content, which might not need new features apart from gallery detection. I’ll take a closer look at the tests and integration patterns. Searching for ACF integration usage feels like the right move, so I’ll run a search for "check_acf_image_usage" and similar queries to see what’s out there. It seems like a straightforward process!
exec
/bin/zsh -lc 'rg -n "class ACF|check_acf_image_usage|get_used_attachments|get_attachment_usage|get_media_field_keys" includes/integrations/Acf.php includes -S' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 74ms:
includes/integrations/Acf.php:28:class ACF extends AbstractIntegration implements MediaAwareIntegrationInterface {
includes/integrations/Acf.php:135:		$this->add_filter( 'wpha_media_is_attachment_used', array( $this, 'check_acf_image_usage' ), 10, 2 );
includes/integrations/Acf.php:175:	public function get_media_field_keys(): array {
includes/integrations/Acf.php:260:	public function check_acf_image_usage( bool $is_used, int $attachment_id ): bool {
includes/integrations/Acf.php:448:		$media_fields = $this->get_media_field_keys();
includes/integrations/Acf.php:613:		return $this->check_acf_image_usage( false, $attachment_id );
includes/integrations/Acf.php:626:	public function get_used_attachments( int $batch_size = 1000 ): array {
includes/integrations/Acf.php:674:			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
includes/integrations/Acf.php:689:	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
includes/Media/Scanner.php:972:	public function get_attachment_usage( int $attachment_id ): array {
includes/Contracts/ScannerInterface.php:99:	public function get_attachment_usage( int $attachment_id ): array;
includes/Contracts/MediaAwareIntegrationInterface.php:44:	public function get_used_attachments(): array;
includes/Contracts/MediaAwareIntegrationInterface.php:56:	public function get_attachment_usage( int $attachment_id ): array;
includes/Integrations/Elementor.php:660:	public function get_used_attachments( int $batch_size = 50 ): array {
includes/Integrations/Elementor.php:704:			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
includes/Integrations/Elementor.php:719:	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
includes/Integrations/Multilingual.php:793:	public function get_used_attachments(): array {
includes/Integrations/Multilingual.php:841:	public function get_attachment_usage( int $attachment_id ): array {
includes/Integrations/WooCommerce.php:801:	public function get_used_attachments(): array {
includes/Integrations/WooCommerce.php:849:	public function get_attachment_usage( int $attachment_id ): array {
exec
/bin/zsh -lc "ls -la includes/Integrations | sed -n '1,200p'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
total 288
drwxr-xr-x@  9 ahmedyounis  staff    288 Jan  9 00:44 .
drwxr-xr-x@ 28 ahmedyounis  staff    896 Jan 16 22:08 ..
-rw-------@  1 ahmedyounis  staff  11503 Jan  9 00:44 AbstractIntegration.php
-rw-r--r--@  1 ahmedyounis  staff  23212 Jan 14 06:39 Acf.php
-rw-r--r--@  1 ahmedyounis  staff  35314 Jan 17 02:40 Elementor.php
-rw-r--r--@  1 ahmedyounis  staff     28 Jan  7 17:43 index.php
-rw-------@  1 ahmedyounis  staff  15652 Jan 17 01:55 IntegrationManager.php
-rw-r--r--@  1 ahmedyounis  staff  24455 Jan  8 09:31 Multilingual.php
-rw-r--r--@  1 ahmedyounis  staff  25914 Jan 17 02:10 WooCommerce.php

thinking
**Checking file references**

I’ve noticed that there’s an inconsistency with "includes/Integrations/Acf.php" (capital "I") versus "includes/integrations/Acf.php" (lowercase "i"). It seems like I opened "includes/integrations/Acf.php" before. I should verify if this file is indeed a duplicate. Hmm, it might be helpful to list the contents of the "includes/integrations" directory to clarify what’s there. Let's proceed with that to figure things out!
exec
/bin/zsh -lc "ls -la includes/integrations | sed -n '1,200p'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
total 288
drwxr-xr-x@  9 ahmedyounis  staff    288 Jan  9 00:44 .
drwxr-xr-x@ 28 ahmedyounis  staff    896 Jan 16 22:08 ..
-rw-------@  1 ahmedyounis  staff  11503 Jan  9 00:44 AbstractIntegration.php
-rw-r--r--@  1 ahmedyounis  staff  23212 Jan 14 06:39 Acf.php
-rw-r--r--@  1 ahmedyounis  staff  35314 Jan 17 02:40 Elementor.php
-rw-r--r--@  1 ahmedyounis  staff     28 Jan  7 17:43 index.php
-rw-------@  1 ahmedyounis  staff  15652 Jan 17 01:55 IntegrationManager.php
-rw-r--r--@  1 ahmedyounis  staff  24455 Jan  8 09:31 Multilingual.php
-rw-r--r--@  1 ahmedyounis  staff  25914 Jan 17 02:10 WooCommerce.php

thinking
**Examining directory paths and integration patterns**

It seems that includes/integrations and includes/Integrations are treated the same on macOS since the filesystem is case-insensitive. This means the spec referencing includes/integrations/Acf.php should be fine. I need to implement improvements, so I'll look at other integrations to spot any patterns. For instance, the Elementor integration might handle scanning meta values. I'll inspect includes/Integrations/Elementor.php and others to find patterns for including IDs in arrays and checking relevant methods like get_used_attachments.
exec
/bin/zsh -lc "sed -n '600,820p' includes/Integrations/Elementor.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:

	/**
	 * Get Elementor version.
	 *
	 * @since 1.0.0
	 * @deprecated 1.1.0 Use get_current_version() instead.
	 *
	 * @return string Elementor version or empty string if not active.
	 */
	public function get_elementor_version(): string {
		return $this->get_current_version() ?? '';
	}

	/**
	 * Clear Elementor cache programmatically.
	 *
	 * @since 1.0.0
	 *
	 * @return bool True on success, false on failure.
	 */

thinking
I'm thinking about the Elementor integration and a function called build_attachment_like_patterns_strict, which might be useful for patterns. I wonder if we can reuse this function for ACF (Advanced Custom Fields)? To confirm this, I'll need to search for that function and gather more information on its capabilities. This will help me understand how it fits into what we're trying to do. Let's dive in!
exec
/bin/zsh -lc 'rg -n "build_attachment_like_patterns_strict" -S includes/Integrations/Elementor.php includes/Integrations/Acf.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 72ms:
includes/Integrations/Elementor.php:342:		$like_patterns     = $this->build_attachment_like_patterns_strict( $attachment_id );
includes/Integrations/Elementor.php:724:		$like_patterns          = $this->build_attachment_like_patterns_strict( $attachment_id );
includes/Integrations/Elementor.php:1001:	private function build_attachment_like_patterns_strict( int $attachment_id ): array {
exec
/bin/zsh -lc "sed -n '980,1060p' includes/Integrations/Elementor.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
				$decoded = $this->maybe_decode_nested_string( $value );
				if ( is_array( $decoded ) ) {
					$contexts = array_merge( $contexts, $this->find_contexts_in_structure( $decoded, $attachment_id, $widget_type ) );
				}
			}
		}

		return array_unique( $contexts );
	}

	/**
	 * Build LIKE patterns to locate an attachment ID in Elementor meta blobs.
	 *
	 * Elementor data can be stored as JSON, serialized PHP arrays (page settings),
	 * and other formats depending on Elementor version and feature usage.
	 *
	 * @since 1.1.0
	 *
	 * @param int $attachment_id Attachment ID.
	 * @return array<string> LIKE patterns.

thinking
**Exploring caching methods**

I'm thinking about implementing the check_acf_image_usage function. First, if ACF functions exist for retrieving field groups, I can access media field keys. However, I don't want to call acf_get_field_groups with each check due to performance concerns. I could consider caching instead. There's a CacheInterface included, so I’ll take a look at the AbstractIntegration to understand what caching methods are available. It seems like a good direction to explore!
exec
/bin/zsh -lc "sed -n '1,220p' includes/Integrations/AbstractIntegration.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
<?php
/**
 * Abstract Integration Base Class
 *
 * Base class for all third-party plugin integrations.
 *
 * @package WPAdminHealth\Integrations
 */

namespace WPAdminHealth\Integrations;

use WPAdminHealth\Contracts\IntegrationInterface;
use WPAdminHealth\Contracts\ConnectionInterface;
use WPAdminHealth\Contracts\CacheInterface;
use WPAdminHealth\Database\WpdbConnection;
use WPAdminHealth\Cache\CacheFactory;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
exec
/bin/zsh -lc "sed -n '220,480p' includes/Integrations/AbstractIntegration.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:

	/**
	 * Add a filter hook with tracking.
	 *
	 * @since 1.1.0
	 *
	 * @param string   $tag      The filter hook name.
	 * @param callable $callback The callback function.
	 * @param int      $priority Optional. Priority. Default 10.
	 * @param int      $args     Optional. Number of arguments. Default 1.
	 * @return void
	 */
	protected function add_filter( string $tag, callable $callback, int $priority = 10, int $args = 1 ): void {
		add_filter( $tag, $callback, $priority, $args );

		$this->registered_hooks[] = array(
			'type'     => 'filter',
			'tag'      => $tag,
			'callback' => $callback,
			'priority' => $priority,






thinking
**Evaluating ACF detection**

I need to ensure that if `acf_get_field_groups` is missing, we can still fall back to old detection methods. I see that `get_current_version` utilizes ACF_VERSION/ACF_PRO_VERSION constants, while `is_available` checks for the existence of the ACF class or functions. My implementation plan involves updating `check_acf_image_usage` patterns to include serialized integer values. To avoid false positives, I'll restrict the query to meta_keys that relate to ACF media fields. Then I'll define an algorithm for checking ACF image usage.
thinking
**Considering ACF clone fields**

I think I need to think about ACF's clone field type, which can include nested fields. The spec mentions reviewing image, gallery, file, flexible content, repeater, and group, but it doesn't cover clones. If there are no matches, I may fall back to the current broad query with direct matches and patterns. I'll build SQL to find relevant meta rows, filtering out unwanted post statuses and matching attachment IDs using specific patterns. I need to be careful with serialized patterns to ensure accuracy!
thinking
**Evaluating media field patterns**

I can use `LIKE '%:"123";%'` for a safe boundary with quotes and semicolons. For JSON arrays, they may be stored in ACF, so I might need patterns for `[` as well. However, if ACF returns serialized arrays for media fields like images or files, that may differ from JSON. It’s unclear if JSON patterns are necessary, but I see they’re used for objects with id/ID keys in the code. 

In gallery fields, the meta value could be a serialized array of numeric IDs, stored either as integers (`i:123;`) or strings (`s:3:"123";`). This is something I should keep in mind!
thinking
**Clarifying WordPress storage types**

I believe WordPress might store integers as strings, but also sometimes as `i`. I should cover both possibilities. For JSON arrays, if they’re stored as `["123","456"]`, I can consider including patterns for those as well, even if it might not happen.

When it comes to ACF fields for images or files, I think they primarily return the attachment ID, with the return format determining the output. For instance, the format can be set to an array, URL, or ID. I suspect that ACF stores the attachment ID in the database, especially for galleries, which likely store an array of IDs. So, using direct matches and serialized array patterns should suffice.
thinking
**Refining ACF detection processes**

I’m considering that when you set the return format for an image field to an array, the database may still store the ID, which means I might need to use the underscore for meta. ACF likely uses field key mapping, so the value is probably still the ID. The existing code with `direct_match` should work for this.

For repeater fields, it seems ACF stores subfield values as separate meta rows and might not store serialized arrays. This raises questions about querying for serialized "id";i patterns. I need to align with the spec for detecting media across various ACF field types like images, galleries, and files. I’ll work on improving `get_used_attachments` to focus on scanning ACF media fields specifically!
thinking
**Improving ACF media detection**

I see that gallery serialized arrays of IDs might be collected since `collect_ids_from_acf_structure` recurses through numeric values. It seems that if the gallery's meta value is a serialized array, it should return an array of IDs as expected. However, I need to ensure that I include all serialized arrays, especially those that don't contain "id" in the current query.

For `get_used_attachments`, I should also consider attachments in ACF option fields, which are stored in the `wp_options` table. Currently, the integration only scans postmeta, missing these options. 

I must be careful to avoid picking up internal ACF meta rows by properly using joins and filtering out rows like `_field_name`. It's essential to verify that methods like `check_acf_image_usage`, `get_used_attachments`, and `get_attachment_usage` comprehensively support gallery arrays and nested fields. This might help prevent false positives from unrelated meta keys while ensuring validation of attachment IDs across ACF media fields. 

Finally, I need to inspect the media scanner's usage to ensure all relevant patterns are being handled effectively!
exec
/bin/zsh -lc "sed -n '1,120p' includes/Contracts/MediaAwareIntegrationInterface.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
<?php
/**
 * Media Aware Integration Interface
 *
 * Contract for integrations that can detect media usage.
 *
 * @package WPAdminHealth\Contracts
 */

namespace WPAdminHealth\Contracts;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Interface MediaAwareIntegrationInterface
 *
 * Extends IntegrationInterface for integrations that can detect

thinking
**Inspecting media scanner functions**

I’m thinking the media scanner likely makes use of something like is_attachment_used. I need to dive into the Scanner functions, particularly focusing on how they relate to integration usage. It seems like a good idea to search within the Scanner, so I can understand its implementation better. Doing this could help clarify how everything connects and enables smoother operation. Let’s see what I can find!
exec
/bin/zsh -lc "rg -n \"get_used_attachments\\(|is_attachment_used\\(|wpha_media_is_attachment_used\" includes/Media/Scanner.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 71ms:
348:				if ( ! $this->is_attachment_used( $attachment_id ) ) {
499:			if ( ! $this->is_attachment_used( $attachment_id ) ) {
519:		return $this->is_attachment_used( $attachment_id );
531:	private function is_attachment_used( $attachment_id ): bool {
623:		$is_used = (bool) apply_filters( 'wpha_media_is_attachment_used', false, absint( $attachment_id ) );
887:			if ( ! $this->is_attachment_used( $attachment_id ) ) {
exec
/bin/zsh -lc "sed -n '500,700p' includes/Media/Scanner.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
				$unused[] = $attachment_id;
			}

			// Update progress periodically.
			$this->update_progress( $processed, $total_count );
		}

		return $unused;
	}

	/**
	 * Check if a specific attachment is in use.
	 *
	 * @since 1.1.0
	 *
	 * @param int $attachment_id Attachment ID.
	 * @return bool True if in use, false otherwise.
	 */
	public function is_attachment_in_use( int $attachment_id ): bool {
		return $this->is_attachment_used( $attachment_id );





thinking
**Evaluating ACF integration for attachments**

I see that the core scanner already checks postmeta for attachment IDs and paths, but it misses serialized arrays of IDs. That's where the ACF integration's filter comes in to handle these complex values, like gallery arrays. The check_acf_image_usage function is only used if the core checks don't find any usage. Since gallery fields saved as serialized arrays are overlooked, I need to implement a fix to ensure we detect these arrays and also potentially flexible content stored as serialized data.
thinking
**Clarifying ACF storage methods**

I’m realizing that ACF uses multiple meta rows instead of just one serialized entry. Flexible content might be stored as a serialized array of layouts, and for the flexible content field, the meta_key could represent the number of rows. It makes sense to think of it that way. So, the field can store either a number or a serialized list of layout names. While attachments in flexible fields might be included in a serialized array, it seems unlikely since the subfield values are stored separately.
thinking
**Ensuring flexible content support**

I realize there's a need to ensure that `get_media_field_keys` is equipped to handle flexible content. It does cover this, but usage detection scans postmeta values across all meta keys, not specifically field keys. It might pick up attachments in flexible content subfields since they store direct IDs or serialized arrays. Our improved method using joins should still catch those. I’ll also keep an eye on `check_acf_image_usage` patterns for JSON. Lastly, I need to update `get_attachment_usage` to capture gallery arrays of IDs since it currently misses those usage locations.
thinking
**Refining query patterns for detection**

I realize that the query needs to include patterns to match serialized array values, like `%i:ID;%` and `%:"ID";%`, and possibly JSON arrays. It makes sense to limit the query to ACF media fields by joining to field key meta rows, which should reduce false positives. I need to implement this improvement for `get_attachment_usage` too, along with enhanced detection for gallery arrays and nested fields. Also, in the `get_acf_field_context` method, there's a mistake with retrieving field key meta for post ID 0, which doesn’t exist. They need to query the underscore meta for the relevant post instead.
thinking
**Reevaluating context retrieval and attachment handling**

I noticed that while they have `$meta_key` and `$meta_value`, they lack `post_id` in the context of the method. This means they can’t properly query the underscore meta since it mistakenly uses object_id 0. Fixing the field label retrieval is crucial, and even though it's not specifically mentioned in the spec, addressing the context could help with verifying repeater and group support. 

We should modify the function to accept `post_id` and adjust how we call `get_metadata` to ensure accurate results without disrupting existing functionality. Finally, I need to implement SQL queries carefully with placeholder counts, ensuring proper preparation in the connection interface.
exec
/bin/zsh -lc "sed -n '1,200p' includes/Database/WpdbConnection.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 62ms:
<?php
/**
 * WPDB Connection Implementation
 *
 * Database connection using WordPress WPDB.
 *
 * @package WPAdminHealth\Database
 */

namespace WPAdminHealth\Database;

use WPAdminHealth\Contracts\ConnectionInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class WpdbConnection

thinking
**Updating tests and documentation**

I need to update the docblocks for clarity. It looks like I’m dealing with a WordPress plugin that uses both PHP and JS. There are tests located in the tests directory, and I see that it’s employing Jest for the JS portion and PHPUnit for PHP. I’ll have to check the test structure to ensure everything is in order. Let's make sure the tests are running smoothly!
exec
/bin/zsh -lc "find tests -maxdepth 2 -type f | sed -n '1,200p'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
tests/Mocks/MockExclusions.php
tests/Mocks/MockConnection.php
tests/unit/SampleTest.php
tests/unit/MediaScannerTest.php
tests/unit/DatabaseAnalyzerTest.php
tests/unit/LargeFilesTest.php
tests/integration/RestApiTest.php
tests/bootstrap-standalone.php
tests/bootstrap.php
tests/README.md
tests/factories/CommentFactory.php
tests/factories/PostFactory.php
tests/factories/AttachmentFactory.php
tests/StandaloneTestCase.php
tests/TestCase.php
tests/IntegrationTest.php

thinking
**Searching for ACF tests**

I know there are PHP tests that we have. We also need to incorporate tests for ACF integration specifically. I’m wondering if there are any existing integration tests in place for other functions. It makes sense to check those out first to see how they’re structured. So, I’ll go ahead and search for ACF tests to ensure we have everything covered properly!
exec
/bin/zsh -lc "rg -n \"Acf|ACF\\b|Advanced Custom Fields\" tests includes -S" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 77ms:
includes/Media/Scanner.php:572:		// Check in postmeta (for galleries, ACF fields, etc.).
includes/Media/Scanner.php:612:		 * Allows plugin integrations (e.g., WooCommerce, ACF, Elementor) to add
includes/Media/ReferenceFinder.php:75:		// Search in post meta (galleries, ACF fields, etc.).
includes/Media/ReferenceFinder.php:95:		// Search for ACF fields.
includes/Media/ReferenceFinder.php:609:	 * Search for ACF (Advanced Custom Fields) references.
includes/Media/ReferenceFinder.php:611:	 * ACF stores attachment IDs in various formats:
includes/Media/ReferenceFinder.php:618:	 * This method searches broadly first, then verifies ACF field ownership.
includes/Media/ReferenceFinder.php:621:	 * @return array Array of references found in ACF fields.
includes/Media/ReferenceFinder.php:630:		// ACF stores attachment IDs as plain integers or in serialized/JSON arrays.
includes/Media/ReferenceFinder.php:634:		// JSON patterns for ACF 6.x+ which may use JSON.
includes/Media/ReferenceFinder.php:641:		// since some ACF subfields may have unusual naming).
includes/Media/ReferenceFinder.php:687:			// Check if this is an ACF field by looking for the field key reference.
includes/Media/ReferenceFinder.php:691:			// Also check for ACF sub-fields (repeater fields store as field_name_0_subfield).
includes/Media/ReferenceFinder.php:693:				// Check if this looks like an ACF repeater/flexible content sub-field.
includes/Media/ReferenceFinder.php:750:					'context' => 'ACF field "' . $meta_key . '" in ' . $post->post_type . ': ' . $post->post_title,
includes/Media/ReferenceFinder.php:762:	 * Media can be used in user profiles (avatars, custom profile fields, ACF user fields).
tests/unit/MediaScannerTest.php:268:	 * Test unused media detection with postmeta (ACF, galleries)
tests/unit/MediaScannerTest.php:274:		// Create an attachment and add to postmeta (simulating ACF or gallery)
includes/Integrations/Acf.php:3: * Advanced Custom Fields (ACF) Integration Class
includes/Integrations/Acf.php:5: * Provides ACF-specific media reference detection for image, gallery, and file fields.

thinking
**Inspecting reference files**

I’m looking into a file named ReferenceFinder.php, which seems to implement ACF references scanning. I'm wondering if there might be duplicates present. I think it's a good idea to inspect this file to identify patterns; maybe I can reuse some of the logic it has. It sounds like diving into the ACF section could yield some useful insights. I’ll proceed by exploring that file further.
exec
/bin/zsh -lc "sed -n '560,780p' includes/Media/ReferenceFinder.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
			if ( null === $query ) {
				continue;
			}

			$results = $this->connection->get_results( $query );

			foreach ( $results as $result ) {
				// Verify by checking for exact ID patterns.
				$data = $result->meta_value;
				$found = false;

				// Check serialized integer pattern.
				if ( preg_match( '/i:' . preg_quote( $id_str, '/' ) . ';/', $data ) ) {
					$found = true;
				}
				// Check serialized string pattern.
				if ( ! $found && preg_match( '/s:\d+:"' . preg_quote( $id_str, '/' ) . '";/', $data ) ) {
					$found = true;
				}
				// Check JSON patterns.
exec
/bin/zsh -lc "sed -n '920,1040p' includes/Media/Scanner.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 52ms:
	 * @param int $threshold_kb Size threshold in kilobytes.
	 * @return array<int, array{id: int, size: int, file: string}> Large file data.
	 */
	public function scan_large_media( int $threshold_kb = 1000 ): array {
		// Convert KB to MB for the existing method.
		$threshold_mb = $threshold_kb / 1024;
		$large_files = $this->find_large_files( $threshold_mb );

		// Transform to match interface return type.
		$result = array();
		foreach ( $large_files as $file ) {
			$result[] = array(
				'id'   => (int) $file['id'],
				'size' => (int) $file['size'],
				'file' => $file['path'],
			);
		}

		return $result;
	}
exec
/bin/zsh -lc "sed -n '1040,1180p' includes/Media/Scanner.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 65ms:
				);
			}
		}

		return $usages;
	}

	/**
	 * Get a summary of the media library.
	 *
	 * @since 1.1.0
	 *
	 * @return array{
	 *     total_count: int,
	 *     total_size: int,
	 *     unused_count: int,
	 *     unused_size: int,
	 *     duplicate_count: int,
	 *     large_count: int
	 * } Media summary statistics.

thinking
**Investigating attachment usage**

I see that the scanner's get_attachment_usage function doesn't use integrations. That makes me think that integration's get_attachment_usage might be employed in other areas, like a new user interface or API. So, I need to search for where integrations are being used. I'll gather some information about integration usage to better understand how it all connects. This could really help clarify things!
exec
/bin/zsh -lc "rg -n \"get_attachment_usage\\(\" includes | head" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
includes/Media/Scanner.php:972:	public function get_attachment_usage( int $attachment_id ): array {
includes/Integrations/Elementor.php:719:	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
includes/Integrations/Multilingual.php:841:	public function get_attachment_usage( int $attachment_id ): array {
includes/Contracts/MediaAwareIntegrationInterface.php:56:	public function get_attachment_usage( int $attachment_id ): array;
includes/Integrations/Acf.php:689:	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
includes/Contracts/ScannerInterface.php:99:	public function get_attachment_usage( int $attachment_id ): array;
includes/Integrations/WooCommerce.php:849:	public function get_attachment_usage( int $attachment_id ): array {

thinking
**Examining attachment usage**

I'm noticing that the ScannerInterface has a method for getting attachment usage, but it returns an array of type/id/title. Meanwhile, the integration's method returns an array of post_id, post_title, and context. That seems inconsistent. I wonder if the integration's usage is separate, or if there's another class for the API that details usage with integrations. It might be helpful to look into the usage of `MediaAwareIntegrationInterface` to clarify this.
exec
/bin/zsh -lc "rg -n \"MediaAwareIntegrationInterface|get_used_attachments\\(\" includes | head -n 50" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
includes/Integrations/Elementor.php:15:use WPAdminHealth\Contracts\MediaAwareIntegrationInterface;
includes/Integrations/Elementor.php:27:class Elementor extends AbstractIntegration implements MediaAwareIntegrationInterface {
includes/Integrations/Elementor.php:660:	public function get_used_attachments( int $batch_size = 50 ): array {
includes/Integrations/WooCommerce.php:15:use WPAdminHealth\Contracts\MediaAwareIntegrationInterface;
includes/Integrations/WooCommerce.php:27:class WooCommerce extends AbstractIntegration implements MediaAwareIntegrationInterface {
includes/Integrations/WooCommerce.php:801:	public function get_used_attachments(): array {
includes/Integrations/Multilingual.php:18:use WPAdminHealth\Contracts\MediaAwareIntegrationInterface;
includes/Integrations/Multilingual.php:30:class Multilingual extends AbstractIntegration implements MediaAwareIntegrationInterface {
includes/Integrations/Multilingual.php:793:	public function get_used_attachments(): array {
includes/Integrations/Acf.php:16:use WPAdminHealth\Contracts\MediaAwareIntegrationInterface;
includes/Integrations/Acf.php:28:class ACF extends AbstractIntegration implements MediaAwareIntegrationInterface {
includes/Integrations/Acf.php:626:	public function get_used_attachments( int $batch_size = 1000 ): array {
includes/Contracts/MediaAwareIntegrationInterface.php:18: * Interface MediaAwareIntegrationInterface
includes/Contracts/MediaAwareIntegrationInterface.php:25:interface MediaAwareIntegrationInterface extends IntegrationInterface {
includes/Contracts/MediaAwareIntegrationInterface.php:44:	public function get_used_attachments(): array;


thinking
**Improving integration methods**

I see that there are currently unused integration methods, but I still think we should fix them. It seems there's a reference finder for creating reference lists that’s not using integrations. The "ACF Integration Review" spec suggests looking at improving performance or accuracy for ACF integration. I’ll plan to update the functions to check ACF image usage, get used attachments, handle attachment usage, and adjust field context. We definitely need to ensure everything works smoothly!
thinking
**Planning to add tests**

I want to include unit tests using MockConnection. It seems there's a MockConnection available in tests/Mocks, so I’ll check that out to understand how to properly test the SQL queries. Crafting unit tests should help ensure everything runs smoothly, and it feels essential to get this right to avoid any future hiccups. I'll investigate how the MockConnection functions to effectively write those tests!
exec
/bin/zsh -lc "sed -n '1,220p' tests/Mocks/MockConnection.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 64ms:
<?php
/**
 * Mock Database Connection for Unit Testing
 *
 * Provides a testable implementation of ConnectionInterface
 * that doesn't require an actual database connection.
 *
 * @package WPAdminHealth\Tests\Mocks
 */

namespace WPAdminHealth\Tests\Mocks;

use WPAdminHealth\Contracts\ConnectionInterface;

/**
 * Mock database connection for testing.
 *
 * Records all queries made and allows setting up expected results.
 */
class MockConnection implements ConnectionInterface {
exec
/bin/zsh -lc "sed -n '220,440p' tests/Mocks/MockConnection.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
	/**
	 * {@inheritdoc}
	 */
	public function prepare( string $query, ...$args ): ?string {
		if ( empty( $args ) ) {
			return $query;
		}

		// If args is a single array, unpack it (matches WPDB_Connection behavior).
		if ( 1 === count( $args ) && is_array( $args[0] ) ) {
			$args = $args[0];
		}

		// Simple placeholder replacement for testing.
		$prepared = $query;

		foreach ( $args as $arg ) {
			if ( is_int( $arg ) ) {
				$prepared = preg_replace( '/%d/', (string) $arg, $prepared, 1 );
			} elseif ( is_float( $arg ) ) {

thinking
**Inspecting unit tests**

I'm considering MockConnection, which is designed for unit tests. It uses pattern matching to return expected results and lets us set patterns with SQL wildcard semantics. It records queries, helping us verify that our method generates the right query patterns.

However, I wonder if actual detection testing may require a real WordPress environment. But unit tests could potentially utilize mocked WordPress functions, so I need to look into the tests bootstrap process and check files like tests/TestCase.php for insights.
exec
/bin/zsh -lc "sed -n '1,200p' tests/TestCase.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
<?php
/**
 * Base test case for WP Admin Health Suite
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth\Tests;

use WP_UnitTestCase;
use Yoast\PHPUnitPolyfills\Polyfills\AssertionRenames;

/**
 * Base test case class that all plugin tests should extend
 */
abstract class TestCase extends WP_UnitTestCase {
	use AssertionRenames;

	/**
	 * Set up test environment before each test









thinking
**Considering WordPress testing options**

I'm looking at WordPress unit tests, specifically WP_UnitTestCase. It seems that the ACF plugin might not be loaded in the test environment, but we could simulate ACF functions like `acf_get_field_groups` by defining them in our test file. Since functions are global, we could define them if they don’t exist. However, if they’re missing in the WP test environment, we’ll need to create a temporary definition for testing purposes.
thinking
**Evaluating WordPress test strategies**

In WordPress unit tests, the real database is accessible, and integration methods use ConnectionInterface. I could use MockConnection to avoid the database, but using the actual `$wpdb` in a test database might be more direct. While MockConnection makes it easier to test, we'd need to run queries with `connection->get_var`; we can set expected results based on query patterns. To ensure accuracy, I might want to check helper functions like `is_attachment_in_acf_value`, even though they’re private and hard to test directly. I’ll consider using reflection or changing them to protected for easier access.
thinking
**Planning attachment testing strategy**

I can still test the private methods by using public ones like `get_used_attachments`, `check_acf_image_usage`, and `get_attachment_usage`. Since `check_acf_image_usage` uses `get_var`, I can set the expected result in MockConnection and assert it returns true. For gallery detection, I'll set expected results based on patterns like `i:123;`. It might be simpler to use a join to select candidate meta values for ACF media fields and then parse them in PHP, ensuring detection in any format. But I want to balance efficiency with accuracy!
thinking
**Designing query patterns for ACF**

I’m considering how to efficiently query candidate rows using joins and specific patterns. We should keep the patterns minimal but accurate, like checking if `meta_value` equals `id` or uses `LIKE` to match various formats, including those for serialized arrays. The known patterns like `i:id;` and `s:N:"id";` will help us detect gallery fields correctly. However, I need to consider potential JSON formats for ACF 6, which may require extra patterns to accommodate changes. Let's stay flexible with our approach!
thinking
**Refining ACF integration checks**

It seems that ACF 6 might be using JSON for data storage, so I need to implement patterns to handle that, including array formats. For my queries, I can start with minimal patterns for precision and handle serialized arrays effectively. It looks like the current direct match checks in `check_acf_image_usage` might be redundant since the core already handles it. I think I can simplify this function to focus solely on patterns for serialized or JSON structures, which may improve performance by reducing unnecessary checks. I'll also add array patterns for better coverage!
thinking
**Crafting precise patterns for ACF data**

I need patterns that accurately identify serialized integers and strings for ACF data, like `%i:123;%` for integers and `%:"123";%` for strings. For JSON, I'll implement patterns for both object and array formats, making sure to handle whitespace. A challenge arises since serialized arrays might have keys where `i:123;` could match both keys and values, leading to potential false positives. To avoid confusion, I should create patterns that ensure matches refer exclusively to values rather than keys, perhaps using regex like `;i:[0-9]+;i:123;` to differentiate those contexts properly. This is a nuanced process!
thinking
**Refining ACF pattern matching**

I'm considering how to refine the regex pattern `i:[0-9]+;i:123;`. It could potentially match a key of 123, resulting in false positives when it's actually a key and not a value. In serialized arrays, keys and values both end with a semicolon, making differentiation tricky. I realize I need a pattern that ensures 123 is a value, followed by something indicating the end of the value, like `i:<nextkey>;` or `}`. I’ll also need to ensure that my approach with SQL queries accurately identifies meta_values without causing confusion with array indices. This process is getting a bit tangled; I need to simplify while maintaining accuracy!
thinking
**Improving ACF integration**

I realize that my integration can be better by actually unserializing and verifying with existing methods like `is_attachment_in_acf_value` and `search_acf_data_structure`. Relying just on patterns risks false positives, especially with key indices. For `check_acf_image_usage`, I should modify it to leverage these functions for validation. Using SQL, I'll limit the number of rows fetched to optimize performance while ensuring I don’t miss anything crucial by checking as few rows as possible. 

I also need to enhance JSON handling to decode arrays properly, which is vital for accurate data processing. This should resolve key-index collisions and ensure reliable results in ACF gallery fields.
thinking
**Planning ACF integration improvements**

Next, for `get_used_attachments`, I want to modify it to select relevant `meta_value` and potentially `meta_key` from a joined table, focusing on media field keys. This will help filter numeric strings and serialized arrays more effectively.

I need to ensure the join excludes trash entries from the posts table. I’ll create a helper method for building the SQL query for ACF media meta rows.

I also want to keep an eye on the case sensitivity of class names and ensure everything is consistent. After making these adjustments, I’ll set up a plan to implement improvements and run necessary tests.
Plan update
  → Review current ACF integration logic
  • Implement improved media detection
  • Add/adjust automated tests
  • Run lint and test suites

thinking
**Considering caching strategies**

I’m weighing whether to call `acf_get_field_groups` repeatedly or utilize caching to enhance efficiency. I think using `check_acf_image_usage` could result in frequent calls that might not warrant constant computation. Caching seems like a beneficial solution, so I’ll explore `CacheInterface` and `CacheFactory`. They probably have straightforward implementations, and I just want to ensure that I’m using the best method for efficiency and performance moving forward. Let's check them out!
exec
/bin/zsh -lc "sed -n '1,220p' includes/Cache/CacheFactory.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
<?php
/**
 * Cache Factory
 *
 * Factory for creating cache instances.
 *
 * @package WPAdminHealth\Cache
 */

namespace WPAdminHealth\Cache;

use WPAdminHealth\Contracts\CacheInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class CacheFactory
exec
/bin/zsh -lc "sed -n '1,200p' includes/Cache/MemoryCache.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
<?php
/**
 * Memory Cache Implementation
 *
 * In-memory cache implementation for testing.
 *
 * @package WPAdminHealth\Cache
 */

namespace WPAdminHealth\Cache;

use WPAdminHealth\Contracts\CacheInterface;

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	die;
}

/**
 * Class MemoryCache











thinking
**Implementing caching and queries**

Alright, caching in the `get_media_field_keys` function is a good idea! Next up, I need to tackle implementing the join query. It seems like the `connection->get_prefix` method returns the necessary prefix. I wonder if I can utilize the `get_postmeta_table` function too? It feels like those are the right steps to take to ensure everything works smoothly. Alright, let’s see how it all fits together!
thinking
**Refining table prefixes**

So, the existing code uses `$prefix` for interpolating `{$prefix}postmeta` and `{$prefix}posts`. That seems fine, but I wonder if we should switch to using `connection->get_postmeta_table` and `connection->get_posts_table` for consistency, especially since ACF integration uses the prefix directly. However, utilizing those functions also gives us the actual table name, which is cooler. I think adopting `$postmeta_table = $this->connection->get_postmeta_table();` approach will make our queries more robust without rewriting the whole thing. Now, we also need to implement caching for field keys to avoid repeated calls to `acf_get_field_groups`.
thinking
**Updating media field keys**

I can call `get_media_field_keys`, but I need to update it to include caching by using `remember`. This method is also called by `get_field_statistics`, which is fine. Here's the implementation:

```php
public function get_media_field_keys(): array {
    if ( ! function_exists(...) ) return array();
    return $this->remember( 'media_field_keys', function() {
        ...
        return array_values( array_unique( $media_fields ) );
    }, 300 );
}
```

I should be cautious, though; `remember` uses the cache key with integration ID, and this method might be used before `integration get_id`, which is something to consider. As for private helper methods, I might not need `get_media_field_keys_cached` if caching is done directly in `get_media_field_keys`. However, I will create `get_acf_media_meta_values` to return meta values efficiently for specific needs like `get_attachment_usage` and `check_acf_image_usage`, allowing me to build the necessary queries.
thinking
**Designing a query builder**

I'm looking to design a generic query builder for retrieving `meta_values` based on `media_field_keys` and a specific attachment ID. The SQL query would look something like this:

```sql
SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
FROM postmeta pm
INNER JOIN postmeta fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
INNER JOIN posts p ON pm.post_id = p.ID
WHERE p.post_status NOT IN ('trash','auto-draft')
AND fk.meta_value IN (<field_key_placeholders>)
AND (
    pm.meta_value = %s OR pm.meta_value LIKE %s OR ...
)
LIMIT %d
```

The use of `CONCAT` in SQL for joining could impact performance since it might not be index-friendly. Still, there's a possibility that using `fk.meta_key = CONCAT('_', pm.meta_key)` could allow index usage on `meta_key`. It's a bit complicated, but the alternative ensures proper mapping. Let's keep refining this!
thinking
**Constructing image usage checks**

I need to consider the lengths of `meta_key` and ensure we don't match those starting with `_`, which would represent field key rows. To refine my query, I should add a clause like `pm.meta_key NOT LIKE '\_%'`. 

For matching, I’m thinking of patterns for direct matches, numeric matches, and serialized patterns like `%i:123;%`. I'll build an array of these patterns, ensuring that we use `esc_like` for proper escaping. But the bracket `[` is not special in MySQL LIKE, so I don’t need to stress about escaping it.

In the `check_acf_image_usage` function, I plan to run a query for `postmeta` rows and integrate this logic. The limit of 25 seems reasonable, but I might want to increase it to 50 to reduce false negatives. However, I need to be careful about performance and the risk of missing true matches with many IDs in keys. Let's see how this plays out!
thinking
**Addressing potential false positives**

When the attachment ID is small, like 12, it could lead to many galleries having that ID appearing as a key, creating false candidates in our meta values. To avoid this, I’m thinking of using more precise patterns. A serialized integer pattern might not differentiate between keys and values effectively, so instead, relying on serialized string patterns might be better.

Values in WordPress postmeta are likely stored as strings, especially when using ACF. To minimize false positives, I could increase the limit from 25 to 200. However, having a larger limit may slow down the operations, especially when processing multiple attachments simultaneously. 

We might also consider utilizing SQL REGEXP for more accurate matching patterns and ensure that the ID appears strictly as a value. This approach should help in distinguishing between keys and values more reliably, thus reducing the risk of false positives. There’s a lot to balance here, but it’s important to get it right!
thinking
**Avoiding false positives**

If an attachment ID is small, I need to recognize that it can lead to many galleries containing that ID as a key, which could create false positives. To mitigate this, I might risk false negatives but strive for accuracy in detecting actual usage. While some false positives may be acceptable for unused media cleanup, the goal is to minimize them.

To improve detection, I should expand SQL patterns to include both serialized integers and strings, while remaining aware of potential key collisions. I suspect that ACF likely stores IDs as strings, so I could focus on string patterns and parse only when using integer patterns to avoid mistakes.

However, confirming this with typical WordPress serialization practices is essential since they preserve types during storage. In the end, striking a balance between avoiding false negatives and managing false positives effectively prevails.
thinking
**Deciding on serialization handling**

It seems safe to assume that values are stored as strings, so using the pattern `:"123";` should work. However, there might be integers involved in the serialization that I need to handle. Therefore, I should use SQL patterns for both string serialization and JSON arrays. 

For integer serialization like `i:123;`, I think a more specific integer pattern may help reduce key collisions, but parsing verification is still the most reliable approach due to performance concerns. I have a couple of options: either stick with current efficient queries expanding the patterns but accepting some false positives or switch to a slower join method and parse each result. 

After weighing performance and accuracy, it looks like a single query returning up to 20 candidate meta_values for checking attachment usage could be a better approach. Additionally, I'll want to ensure I accurately scan ACF media fields while remaining mindful of missing underscore meta rows due to manual modifications. A fallback should be included just in case!
thinking
**Implementing ACF modifications**

I need to ensure that the repeaters and groups support is working since we're using meta_key underscores for each subfield. Now, I'll also focus on fixing the JSON decode functionality. Additionally, the `get_used_attachments` function might need to consider that some meta_values could be serialized in `wp_postmeta.meta_value`, so I'll plan to parse those as well. 

I'll modify the patch in `includes/Integrations/Acf.php`. It includes adjustments to the `check_acf_image_usage` method, where I'll implement a more structured query to check image usage while being cautious with placeholders and query structure. I also need to create and implement the `build_acf_like_patterns` function to generate SQL wildcard patterns efficiently for different types of serialized data. Let's ensure everything is robust while limiting unnecessary complexity!
thinking
**Refining number patterns for JSON**

I'll include patterns for numbers that allow for optional spaces after commas or before brackets since JSON allows for that. For example, I can include patterns like `%[`, `%[,`, and `%`, as well as variations for spaces. However, I'll need to ensure I use `esc_like` on the entire token string to avoid errors with characters like brackets. 

Using `i:123;` might cause false positives due to key collisions, so we need to be cautious. To manage this, we can design queries that first check more specific patterns like `:"123";` and only fall back to `i:123;` patterns if necessary. This dual approach can help to reduce false returns while still identifying true matches effectively. I'll also need to reconsider limits in my queries, increasing them to avoid missing important results.
thinking
**Improving attachment usage queries**

I think increasing the fetch limit for usage locations could help, maybe to five times the limit, and then filtering to get actual matches. For `check_acf_image_usage`, we can fetch more candidates if needed. The current `get_attachment_usage` query patterns don't include certain necessary patterns like `i:` or `:"`, so I'll update those to ensure that gallery arrays are captured. 

To avoid collisions, I’ll implement a method for generating patterns and ensure to handle decoding JSON arrays correctly. There’s also the need to correct certain calls, especially when using get_post_meta, which will improve functionality. Lastly, I need to create unit tests for the new integration behavior to ensure everything works smoothly!
exec
/bin/zsh -lc "rg -n \"Integrations\\\\|new .*Integration\" tests/unit -S" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 75ms:


thinking
I'm thinking about inspecting the tests in the MediaScannerTest directory to see if it utilizes MockConnection or something similar. It seems like a good idea to check for any tests that might be relevant to my goals. I'm curious about how these tests are structured and whether they provide useful insights. Let's dive in and see what information I can uncover from that inspection!
exec
/bin/zsh -lc "sed -n '1,220p' tests/unit/MediaScannerTest.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * Tests for Media Scanner Class
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth\Tests;

use WPAdminHealth\Media\Scanner;
use WPAdminHealth\Media\Exclusions;
use WPAdminHealth\Media\SafeDelete;

/**
 * Test cases for Media Scanner functionality
 */
class MediaScannerTest extends TestCase {

	/**
	 * Scanner instance





thinking
**Evaluating serialization and integration**

I'm considering how when serialized, integers stay as integers, while the update_post_meta function might handle serialization differently. It does seem that update_post_meta serializes arrays automatically, but I need to think about what type of values are being passed. If I pass an array as an integer, it could lead to key collisions, but our parser should find the value. I need to ensure our integration handles integer checks and that our queries use the right patterns to avoid conflicts. Testing will be key here!
thinking
**Considering the database setup**

I plan to use a real database by default, which should work fine. The query will run against a test database that includes postmeta and posts, so it should be able to find the needed data. I need to remember that our join query uses CONCAT and ensure that post_status isn't in the trash. Also, I'm checking if check_acf_image_usage is called with is_used set to false, and we could call integration->is_attachment_used($attachment_id) for validation. Lastly, I'll need to test support for flexible content and possibly create some meta values for the repeater subfield.
thinking
**Planning meta field updates**

I’m going to create an update_post_meta with the key 'repeater_0_gallery' and a value that could be either a serialized array or maybe an integer. The value for _repeater_0_gallery will match the field key. I’ll make sure that our acf_get_fields stub includes this field key as a gallery. I don't think we need to extract the repeater field group since get_media_field_keys can utilize field group definitions. So, I’ll define the structure for nested fields and create tests to ensure that get_media_field_keys extracts these nested media field keys correctly.
thinking
**Designing stub functions for testing**

I need to set up acf_get_field_groups and acf_get_fields to return a fields array, so I'll stub those functions accordingly. I also want to make sure that caching doesn’t interfere with my tests, which means I'll clear the cache as needed. Since PHP doesn’t allow redefinition, I’ll create stubs that can return dynamic results using global variables like $wpha_test_acf_field_groups and $wpha_test_acf_fields. These will allow adjustments per test, and I’ll define these globals in the setup phase. Lastly, I may also consider testing get_acf_field_context for label usage.
thinking
**Implementing global variables and tests**

I’m setting up a global variable for acf_get_fields that maps group keys to a fields array. For testing, I plan to create post meta including a repeater gallery and group fields. This means I'll use meta_keys like 'repeater_0_gallery' with values like $attachment_id. It's important to ensure our get_media_field_keys function only relies on field definitions, so it doesn’t depend on specific meta_key names.

I also want to verify that check_acf_image_usage returns true for existing attachment_ids and test for false negatives by ensuring that attachments not referenced return false. It seems crucial to manage how tests may inadvertently interfere with meta patterns, so I'll keep that in mind when implementing these features. Now, I'll need to tidy up the code in the appropriate files.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Integrations/Acf.php
@@ -179,17 +179,23 @@
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
@@ -264,15 +270,43 @@
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
@@ -280,24 +314,47 @@
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
@@ -305,37 +362,70 @@
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
@@ -371,7 +461,10 @@
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
@@ -626,3 +719,4 @@
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
@@ -633,10 +727,76 @@
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
@@ -673,3 +833,3 @@
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
@@ -689,36 +849,43 @@
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
@@ -726,3 +893,3 @@
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
@@ -733,2 +900,6 @@
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
@@ -740,2 +911,36 @@
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
@@ -763,7 +968,10 @@
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
@@ -822,3 +1030,3 @@
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
@@ -826,3 +1034,3 @@
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M includes/Integrations/Acf.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Reviewing integration logic**

I need to confirm that the big patch we made has no syntax errors and that the new methods are correctly implemented with braces. So, step 1, which involves reviewing the current ACF integration logic, might be done now, but I still need to ensure everything compiles properly. I'll adjust the status of the plans accordingly, marking step 1 as completed and moving step 2 into progress.
Plan update
  ✓ Review current ACF integration logic
  → Implement improved media detection
  • Add/adjust automated tests
  • Run lint and test suites
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Fixing detection issues**

I’m currently working on improving detection methods. We’ve made some changes, but I need to verify everything and maybe fix some issues. I should re-open the relevant parts of the code to ensure the new methods are correctly inserted and not causing any duplicates or style problems. I'm considering running a PHP syntax check or tests later to catch anything. I want to ensure there are no double function names, so I'll search for check_acf_image_usage_legacy and open the sections around those methods.
exec
/bin/zsh -lc 'php -l includes/Integrations/Acf.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 111ms:
No syntax errors detected in includes/Integrations/Acf.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Evaluating cache options**

I can use CacheFactory::create_memory_cache or set_instance, but it seems easiest to instantiate the integration with a new MemoryCache injection in tests. The AbstractIntegration constructor lets me pass CacheInterface. I'll remember that the caches compute media_field_keys, and if updates are needed, I might clear the cache with integration->clear_cache. It's protected, but creating a new integration instance should work. Also, I'll check the plugin version in wp-admin-health-suite.php, as I’m curious if adding `@since 1.1.1` is appropriate.
exec
/bin/zsh -lc 'rg -n "Version" wp-admin-health-suite.php includes -S | head' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 80ms:
wp-admin-health-suite.php:6: * Version: 1.0.0
includes/Assets.php:295:	 * @return string Version string.
includes/REST/Performance/PluginProfilerController.php:140:			if ( $plugin_file && isset( $all_plugins[ $plugin_file ]['Version'] ) ) {
includes/REST/Performance/PluginProfilerController.php:141:				$version = (string) $all_plugins[ $plugin_file ]['Version'];
includes/REST/PerformanceController.php:382:				'version'     => $plugin['Version'],
includes/Performance/CacheChecker.php:899:		if ( class_exists( 'ObjectCachePro\\Plugin' ) || defined( 'RedisCachePro\\Version' ) ) {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "sed -n '1,40p' wp-admin-health-suite.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
<?php
/**
 * Plugin Name: WP Admin Health Suite
 * Plugin URI: https://github.com/yourusername/wp-admin-health-suite
 * Description: A comprehensive suite for monitoring and maintaining WordPress admin health and performance.
 * Version: 1.0.0
 * Author: Your Name
 * Author URI: https://yourwebsite.com
 * License: GPL v2 or later
 * License URI: https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain: wp-admin-health-suite
 * Domain Path: /languages
 * Requires at least: 6.0
 * Requires PHP: 7.4
 *
 * @package WPAdminHealth
 */

namespace WPAdminHealth;

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "rg -n \"get_acf_field_context\\(\" includes/Integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
894:				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
1031:	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Ensuring modifications compile**

I need to make sure our code changes compiled properly, and running `php -l` indicates they did! Now, I’m thinking that we won't fully implement improved detection until we test everything and possibly tweak some details. It feels like a good idea to review the new methods for style and comments. I’ll open the relevant section of the ACF file to check that everything’s in order and not overly complicated.
exec
/bin/zsh -lc "sed -n '150,380p' includes/Integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
	/**
	 * Get all ACF field groups.
	 *
	 * @since 1.0.0
	 *
	 * @return array<array{key: string, title: string}> Array of field groups.
	 */
	public function get_field_groups(): array {
		if ( ! function_exists( 'acf_get_field_groups' ) ) {
			return array();
		}

		return acf_get_field_groups();
	}

	/**
	 * Get all media fields from ACF field groups.
	 *
	 * Parses field groups and returns all fields that can contain media.
	 * Handles nested fields in repeaters, flexible content, and groups.
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "sed -n '380,520p' includes/Integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
	 * Patterns are intentionally broad and should be paired with
	 * {@see is_attachment_in_acf_value()} for verification.
	 *
	 * @since 1.1.1
	 *
	 * @param int $attachment_id Attachment ID.
	 * @return array<string> LIKE patterns.
	 */
	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
		$id      = (string) absint( $attachment_id );
		$escaped = $this->connection->esc_like( $id );

		$patterns = array();

		// Serialized:
		// - Integers: i:123;
		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "sed -n '600,880p' includes/Integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:

				if ( ! empty( $sub_fields ) ) {
					$this->count_field_types( $sub_fields, $field_types );
				}
			}
		}
	}

	/**
	 * Get posts using ACF fields.
	 *
	 * @since 1.0.0
	 *
	 * @param int $limit Maximum number of posts to return.
	 * @return array<int> Array of post IDs using ACF fields.
	 */
	public function get_posts_with_acf_fields( int $limit = 100 ): array {
		$prefix = $this->connection->get_prefix();

		$results = $this->connection->get_col(
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "sed -n '880,1060p' includes/Integrations/Acf.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 66ms:
					LIMIT %d",
					...array_merge(
						$media_field_keys,
						array( $attachment_id_str ),
						$like_patterns,
						array( $query_limit )
					)
				),
				'OBJECT'
			);
		}

		foreach ( $results as $result ) {
			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );

				$usages[] = array(
					'post_id'    => absint( $result->post_id ),
					'post_title' => $result->post_title,
					'context'    => $context,
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc 'cat package.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 72ms:
{
  "name": "wp-admin-health-suite",
  "version": "1.0.0",
  "description": "A comprehensive suite for monitoring and maintaining WordPress admin health and performance",
  "scripts": {
    "build": "webpack --mode production",
    "build:dev": "webpack --mode development",
    "watch": "webpack --mode development --watch",
    "dev": "webpack serve --mode development --open",
    "lint": "eslint assets/js --ext .js,.jsx",
    "lint:fix": "eslint assets/js --ext .js,.jsx --fix",
    "format": "prettier --write \"**/*.{js,jsx,json,css,scss,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,json,css,scss,md}\"",
    "test": "jest --passWithNoTests",
    "prepare": "husky"
  },
  "keywords": [
    "wordpress",
    "plugin",
    "health",
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Evaluating testing process**

I see that we have JS tests and linting, but our changes are focused on PHP, which means running `npm test` won't actually cover those. It's clear that I should run PHP unit tests even though it's not explicitly requested. Hmm, I'm not sure if there's a phpunit command available, but maybe I can run composer commands. I'll check the `composer.json` scripts for guidance. While it's beneficial to run relevant tests, I need to consider the time it might take.
exec
/bin/zsh -lc 'cat composer.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
{
  "name": "wp-admin-health/suite",
  "description": "A comprehensive suite for monitoring and maintaining WordPress admin health and performance",
  "type": "wordpress-plugin",
  "license": "GPL-2.0-or-later",
  "version": "1.0.0",
  "require": {
    "php": ">=7.4",
    "composer/installers": "^1.0 || ^2.0"
  },
  "require-dev": {
    "dealerdirect/phpcodesniffer-composer-installer": "^1.2",
    "phpcompatibility/phpcompatibility-wp": "^2.1",
    "phpdocumentor/phpdocumentor": "^3.0",
    "phpstan/extension-installer": "^1.4",
    "phpstan/phpstan": "^2.1",
    "phpunit/phpunit": "^9.5",
    "squizlabs/php_codesniffer": "^3.13",
    "szepeviktor/phpstan-wordpress": "^2.0",
    "wp-coding-standards/wpcs": "^3.3",
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Evaluating WordPress tests**

I need to check if composer.lock includes WordPress. It might be there. But hold on—WordPress unit tests actually require the WordPress core and testing library. This repository might have standalone tests using Brain Monkey, but I’m not certain. I see there's a phpunit-standalone.xml file. Also, tests/StandaloneTestCase.php might set up the WordPress environment. Let's take a closer look at tests/bootstrap-standalone.php to confirm.
exec
/bin/zsh -lc "sed -n '1,200p' tests/bootstrap-standalone.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * PHPUnit bootstrap file for standalone unit tests (no WordPress required)
 *
 * @package WPAdminHealth\Tests
 */

// Define test environment constants.
define( 'WP_ADMIN_HEALTH_TESTS_DIR', __DIR__ );
define( 'ABSPATH', dirname( __DIR__ ) . '/' );

// WordPress function stubs for standalone tests.
if ( ! function_exists( '__' ) ) {
	/**
	 * Translation stub - returns the string as-is.
	 *
	 * @param string $text   Text to translate.
	 * @param string $domain Text domain (unused).
	 * @return string
	 */
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Looking into standalone tests**

I’m noticing that there are stubs for WP functions designed for standalone tests, which means they can operate without needing WordPress itself. There’s this `phpunit-standalone.xml` file that seems to play a role here, possibly executed by the composer script `test:standalone`. I’m thinking it might involve tests located in `tests/unit-standalone`. I’ll need to look further into that to confirm everything!
exec
/bin/zsh -lc 'cat phpunit-standalone.xml' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
<?xml version="1.0" encoding="UTF-8"?>
<phpunit
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/9.5/phpunit.xsd"
	bootstrap="tests/bootstrap-standalone.php"
	backupGlobals="false"
	colors="true"
	convertErrorsToExceptions="true"
	convertNoticesToExceptions="true"
	convertWarningsToExceptions="true"
	stopOnFailure="false"
	verbose="true">
	<testsuites>
		<testsuite name="WP Admin Health Suite Standalone Tests">
			<directory>tests/unit-standalone</directory>
		</testsuite>
	</testsuites>
	<coverage processUncoveredFiles="true">
		<include>
			<directory suffix=".php">includes</directory>
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Listing directory contents**

I need to check the contents of the standalone tests in the tests/unit-standalone directory. This will give me insight into what tests are present there. I'll ensure to follow the proper procedures for listing files and make sure I'm not missing anything significant. It's important to get a clear picture of what tests are available, so I can proceed appropriately based on that information. Let’s see what's in that directory!
exec
/bin/zsh -lc "find tests/unit-standalone -type f | sed -n '1,200p'" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
tests/unit-standalone/Mocks/MockConnectionTest.php
tests/unit-standalone/Settings/SettingsRegistryTest.php
tests/unit-standalone/Cache/CacheTest.php
tests/unit-standalone/Integration/ContainerCacheIntegrationTest.php
tests/unit-standalone/Container/ContainerTest.php
tests/unit-standalone/Container/ServiceProviderTest.php
tests/unit-standalone/Media/AltTextCheckerTest.php
tests/unit-standalone/Media/SafeDeleteTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Evaluating test scripts**

Standalone tests likely run with composer test:standalone, not with npm test. The default composer test script invokes phpunit, which probably isn't standalone and may require WordPress. However, the test:standalone script utilizes a standalone configuration. Since our changes relate to ACF integration that uses WordPress functions like maybe_unserialize, the standalone bootstrap might stub some WordPress functions like absint. I'm curious if it stubs maybe_unserialize or get_post_meta. I’ll need to search for the maybe_unserialize stub in bootstrap-standalone.
exec
/bin/zsh -lc 'rg -n "function maybe_unserialize" -n tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 52ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc 'rg -n "maybe_unserialize" tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 69ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );





thinking
**Evaluating testing strategies**

Actually, the instructions mainly mention npm lint/test, but I want to implement tests for our changes, possibly in standalone tests since those can run with composer test:standalone in this environment. I think adding tests for the ACF integration's pattern builder and JSON decoding makes sense, using MockConnection and stubs. We might not need full DB join queries for standalone tests, but we can test internal functions like extract_attachment_ids_from_acf_value, focusing on public methods.
thinking
**Analyzing testing with MockConnection**

The process also involves using connection methods like get_col, while noting that MockConnection's prepare is pretty simplistic. Since my tests are standalone, I could set up MockConnection to return meta_values for query patterns, ensuring the output includes expected IDs, which tests the logic of scanning even if it doesn't involve an actual database. Interestingly, get_used_attachments uses a posts table join and ordering, but MockConnection only matches patterns, so I can set expected results and return meta_values accordingly.
thinking
**Preparing for attachment tests**

In the new get_used_attachments, I’m calling `$this->connection->prepare($query, ...array_merge($media_field_keys, array($batch_size, $offset)))`. MockConnection's prepare replaces placeholders like `%s` with `'field_x'`. I can use wildcards for matching query patterns, but it may be easier to use `$mock->set_default_result([...])`. However, since it applies to all unmatched queries, I should set expected results for specific queries like those containing "FROM wp_postmeta pm." Though it could also trigger ACF functions, I think asserting that queries use JOIN with CONCAT would work, making it possible to add tests to the standalone suite.
thinking
**Planning unit tests for ACF integration**

I think the easiest way forward is to create tests in the tests/unit-standalone directory specifically for testing `get_media_field_keys`. This function recursively includes nested structures like repeater, group, and flexible content without needing full WP functions—just `function_exists('acf_get_field_groups')`, which I can stub. It also uses a caching method with CacheInterface, so I’ll integrate MemoryCache. I need to ensure these tests include the ACF integration class file. I should check the tests/unit-standalone files to confirm how classes are included, particularly looking at something like ContainerCacheIntegrationTest.php.
exec
/bin/zsh -lc "sed -n '1,200p' tests/unit-standalone/Integration/ContainerCacheIntegrationTest.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * Container + Cache Integration Tests (Standalone)
 *
 * Tests for integration between the DI container and cache abstraction.
 *
 * @package WPAdminHealth\Tests\UnitStandalone\Integration
 */

namespace WPAdminHealth\Tests\UnitStandalone\Integration;

use WPAdminHealth\Container\Container;
use WPAdminHealth\Contracts\CacheInterface;
use WPAdminHealth\Cache\MemoryCache;
use WPAdminHealth\Cache\NullCache;
use WPAdminHealth\Tests\StandaloneTestCase;

/**
 * Test service that uses cache.
 */
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Inspecting test structures**

I'm considering that standalone tests seem to extend from StandaloneTestCase. I want to understand how that works and what it entails. It looks like inspecting the structure of these tests is essential. I guess it's about seeing how they function within that framework and what specific features or methods they provide. I should look into the details to really grasp their purpose and effectiveness in testing. Let's see what I uncover!
exec
/bin/zsh -lc "sed -n '1,160p' tests/StandaloneTestCase.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
<?php
/**
 * Standalone Test Case for unit tests not requiring WordPress
 *
 * @package WPAdminHealth\Tests
 */

namespace WPAdminHealth\Tests;

use PHPUnit\Framework\TestCase;

/**
 * Base test case class for standalone unit tests.
 *
 * Use this for testing components that don't depend on WordPress functions.
 */
abstract class StandaloneTestCase extends TestCase {

	/**
	 * Set up test environment before each test.
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Inspecting Test Case Structure**

I noticed that StandaloneTestCase extends TestCase from a specific namespace, but it also uses PHPUnit\Framework\TestCase in a different way. It actually includes it at the top without extending it, which feels a bit unusual. This means TestCase must extend WP_UnitTestCase, which requires WordPress, and that seems odd to me. I wonder if they’re aliasing WP_UnitTestCase in the standalone bootstrap. I think it would be helpful to inspect tests/bootstrap-standalone further to check this out.
exec
/bin/zsh -lc 'rg -n "class WP_UnitTestCase" -n tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 69ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc 'rg -n "WP_UnitTestCase" tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 67ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Investigating standalone tests**

I’m pondering how standalone tests operate without the WP_UnitTestCase class being defined. It seems like they might not utilize tests/TestCase.php. Then I think, StandaloneTestCase extends TestCase, which might not be loaded. But wait, composer autoload-dev includes folders and class mappings. So when running standalone tests, they likely rely on autoload for their inclusions. I should check the bootstrap-standalone to see if it loads the composer autoload and defines a WP_UnitTestCase stub there.
exec
/bin/zsh -lc 'tail -n 60 tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
	 * @param int $min Minimum value.
	 * @param int $max Maximum value.
	 * @return int Random number.
	 */
	function wp_rand( $min = 0, $max = 0 ) {
		if ( 0 === $max ) {
			$max = mt_getrandmax();
		}
		return mt_rand( $min, $max );
	}
}

// Composer autoloader.
require_once dirname( __DIR__ ) . '/vendor/autoload.php';

// Register test namespace autoloader for Mocks and other test classes.
spl_autoload_register(
	function ( $class ) {
		$prefix = 'WPAdminHealth\\Tests\\';
		$len    = strlen( $prefix );
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Investigating standalone tests**

I’m wondering how standalone tests actually run. There’s a possibility they might not be running, or maybe they're broken. Could the tasks be to fix them? I think I should run `composer test:standalone` later to check. But then again, maybe they have a stub `WP_UnitTestCase` class defined in `bootstrap-standalone`. I might not have read the full file, so I'll search for "class WP_" in `bootstrap-standalone`. Time to dive into that!
exec
/bin/zsh -lc "rg -n \"class\\s+WP_\" tests/bootstrap-standalone.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
788:	class WP_Error {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
I'm noticing that the focus is on defining the class WP_Error, and it seems there could be more classes involved. I'll explore the surrounding area to gather additional context and details. By searching in that region, I hope to uncover more about the structure and relationships of these classes, which could be really helpful in understanding the broader implications. Let’s keep digging into it!
exec
/bin/zsh -lc "sed -n '700,860p' tests/bootstrap-standalone.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
	 * Multisite check stub.
	 *
	 * @return bool Always false for testing.
	 */
	function is_multisite() {
		return false;
	}
}

if ( ! function_exists( 'get_current_blog_id' ) ) {
	/**
	 * Get current blog ID stub.
	 *
	 * @return int Always 1.
	 */
	function get_current_blog_id() {
		return 1;
	}
}

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc 'rg -n "WP_UnitTestCase" tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 67ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );




thinking
**Evaluating test environments**

I’m thinking that using `composer test:standalone` is easy and might be better for this environment, but the instructions for verification didn't mention it. Still, adding tests here seems good. We need to ensure our ACF integration code isn’t reliant on WP functions that aren’t stubbed in standalone tests. 

The `includes/Integrations/Acf.php` file checks if `ABSPATH` is defined, which is handled in the standalone setup. Still, ACF methods use many WP functions, and some of them might not be stubbed.
thinking
**Testing build patterns**

I’m considering that it might be easiest to test the build patterns and JSON decode behavior by invoking `is_attachment_used`. This function calls `check_acf_image_usage`, which uses a connection and might invoke `maybe_unserialize`, so we’ll need to create stubs. 

Alternatively, I could focus on testing `get_media_field_keys` recursion without involving `maybe_unserialize`. However, the spec requires checking across galleries, and using stubs for `check_acf_image_usage` with serialized arrays makes sense. By injecting `MockConnection`, we can set expected results for returning serialized meta values.
thinking
**Examining MockConnection behavior**

I’m thinking about how `MockConnection` handles placeholder substitution with the `prepare` method. It does manage `...$args` with arrays by unwrapping them if there’s one argument, but I realize we’re actually passing variable arguments, which is fine. 

However, we need to set the expected result for that query string. I notice that `set_expected_result` in `MockConnection` supports pattern matching with `%%` wildcards and `__`, possibly converting SQL-like patterns to regex. I can check its `find_result` method to confirm this behavior.
exec
/bin/zsh -lc 'rg -n "function find_result" -n tests/Mocks/MockConnection.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
470:	private function find_result( string $query ) {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "sed -n '440,560p' tests/Mocks/MockConnection.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 61ms:
			return 'NULL';
		}
		if ( is_bool( $value ) ) {
			return $value ? '1' : '0';
		}
		if ( is_string( $value ) ) {
			return "'" . addslashes( $value ) . "'";
		}
		return (string) $value;
	}

	/**
	 * Record a query.
	 *
	 * @param string $query Query string.
	 * @return void
	 */
	private function record_query( string $query ): void {
		$this->queries[] = array(
			'query' => $query,
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );







thinking
**Clarifying class and file names**

Okay, so the class name is `ACF`, and the file name is Acf, which is a bit confusing since they don’t match perfectly in terms of case. I’ll make sure to import correctly based on this distinction. Then I’ll call the methods associated with the ACF class to move forward. It’s a small detail, but I want to get it right!
thinking
**Implementing media field tests**

I've noticed that `get_media_field_keys` uses the `remember` function, which in turn uses `$this->cache->remember`. That’s all good! I think I need to stub the `get_post` method since it's likely used in `validate_attachment_id`, but it's not essential right now. 

Now, I need to implement tests, starting with checking that `get_media_field_keys` extracts nested media field keys correctly. I'll set up some global arrays for the test and then call `$integration->get_media_field_keys()` to assert equality. Ordering might not matter, so I'll sort and compare.
thinking
**Setting up integration tests**

Since `get_media_field_keys` uses caching, I need to either create a new integration instance for each test or reset the cache. I’ll opt for creating a new integration and MemoryCache for each test. I'll also make sure that the function stubs utilize the global definitions for consistency. 

Next, I need to test `check_acf_image_usage` to detect attachments in a serialized gallery array. I'll set up the same field definitions to include `field_gallery`, and prepare a MockConnection for the main query. The expected results must align with our query patterns regarding placeholders. I’ll ensure we return an array containing serialized data, like `serialize(array(123))`.
thinking
**Preparing standalone tests**

In my standalone tests, I see that `absint` is used to parse `meta_value`, while `is_attachment_in_acf_value` will likely unserialize and search for it. I’ll create an attachment ID of 123. For serialization, I can use PHP's `serialize(array(123, 456))`, which will yield `i:0;i:123;...`.

My `build_acf_attachment_like_patterns` includes the `i:123;` pattern, and that’s useful since the query's LIKE patterns will encompass that. However, it seems the expected result pattern needs to align perfectly with the produced query string; otherwise, it returns an empty array, which could lead back to legacy errors. I'll ensure to wrap field keys with wildcards for better matching in `MockConnection`.
thinking
**Designing expected result patterns**

Let's create the expected result pattern as `'%%FROM wp_postmeta pm%%fk.meta_value IN (%%)%%LIMIT 50'`. The pattern matches using `%%` as a wildcard, including parentheses to ensure it fits the entire string. I’ll set the expected result in the mock connection and include leading and trailing wildcards to account for whitespace and any potential text after "LIMIT 50". 

Next, I’m preparing to test `get_used_attachments`, which returns an array of `meta_values`. The query should effectively select and extract only relevant IDs, like ‘123’ and serialized arrays. Since the `get_used_attachments` method does batching via `ORDER BY`, I’ll ensure that my patterns align accordingly. 

For testing `get_attachment_usage`, I’ll need to use a mock connection that returns an array of objects with properties like `post_id`, ensuring I track calls to `get_post_meta` accurately. I'll set up global mappings to streamline the process, making sure I validate retrieved `post_id` aligns with expectations.
thinking
**Setting up integration tests for attachment usage**

The `get_attachment_usage` function in my integration will call `get_media_field_keys` and utilize ACF functions to return the field gallery and build the query. I need to set the expected result to return an array with an object that has `post_id` 42, `meta_key` as 'my_gallery', and a serialized array for `meta_value` containing 123 along with `post_title` as 'Test Post'.

The query will likely have a limit of 50 since I’m calling `get_attachment_usage($id, 10)`. I want to ensure the expected result pattern matches the query string with wildcards for dynamic pieces, such as `"%%SELECT pm.post_id%%FROM wp_postmeta pm%%LIMIT 50%%"`. 

Additionally, I’ll stub functions like `acf_get_field_groups`, `acf_get_fields`, and `acf_get_field` to facilitate testing. I'll define these global function stubs outside any namespace at the start of my test file, and then declare my namespace afterward. This way, I can ensure everything aligns correctly for my standalone tests. I need to check existing test files for how they manage global function stubs, ensuring I'm following the right approach.
exec
/bin/zsh -lc "rg -n \"namespace \\{\" tests/unit-standalone | head" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 74ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );



thinking
**Evaluating function stubs**

I need to be cautious because bootstrap-standalone is used by all standalone tests. Adding new stubs could cause conflicts if some tests already define them or depend on their absence. It seems relatively safe if we check with `if ( ! function_exists(...) )` before defining, which is a common pattern. I think I should update bootstrap-standalone.php to add stubs for functions like maybe_unserialize and get_post_meta, ensuring they’re available globally without overstepping into unrelated bugs.
thinking
**Reviewing stub files**

I think it’s a good idea to check the phpunit-standalone.xml file to see if it uses a bootstrap file that defines many stubs. Maybe I can append our needed stubs there since it’s a shared file within the scope of changes. However, it might be even better to patch bootstrap-standalone.php with minimal stubs like maybe_unserialize and get_post_meta. I need to verify if get_post_meta is already stubbed by searching in bootstrap-standalone. It looks crucial for our ACF integration tests!
exec
/bin/zsh -lc 'rg -n "function get_post_meta" tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
1012:	function get_post_meta( $post_id, $key = '', $single = false ) {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );


thinking
**Inspecting stubs**

Alright! It seems like the `get_post_meta` function is already stubbed. That’s a relief! Now, I’ll take a closer look at that stub to see how it’s set up. I want to make sure that everything works correctly from here on out. Let's clarify what parameters it accepts and what output I can expect — understanding this will help guide my next steps smoothly!
exec
/bin/zsh -lc "sed -n '980,1050p' tests/bootstrap-standalone.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
	 *
	 * @param int  $attachment_id Attachment ID.
	 * @param bool $unfiltered    Whether to apply filters.
	 * @return string|false File path or false.
	 */
	function get_attached_file( $attachment_id, $unfiltered = false ) {
		return false;
	}
}

if ( ! function_exists( 'wp_get_attachment_metadata' ) ) {
	/**
	 * Get attachment metadata stub.
	 *
	 * @param int  $attachment_id Attachment ID.
	 * @param bool $unfiltered    Whether to apply filters.
	 * @return array|false Attachment metadata or false.
	 */
	function wp_get_attachment_metadata( $attachment_id, $unfiltered = false ) {
		return false;
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );



thinking
**Evaluating get_post_meta**

I notice that the `get_post_meta` function currently returns an empty string for single instances and an empty array otherwise, which doesn't work for our test. I can't redefine the function since it's already in the bootstrap, but I could modify the stub to check a global variable. This might affect other tests, so we have to be careful. I could also avoid using the stub for testing label context, but ideally, I want to test the bug fix and context.
thinking
**Updating stubs cautiously**

I realize that if I change the `get_post_meta` stub in `bootstrap-standalone.php`, it could impact global variables if set inadvertently. But then again, I think we can update the stub to check a global map: if the variable exists, it will return that value; otherwise, it defaults. I'm also wondering about the `maybe_unserialize` stub — maybe there’s something we can do there? I’ll get started by searching for it.
exec
/bin/zsh -lc 'rg -n "function maybe_unserialize" tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 73ms:

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );

exec
/bin/zsh -lc "rg -n \"function get_post\\(\" tests/bootstrap-standalone.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
971:	function get_post( $post_id = null, $output = 'OBJECT', $filter = 'raw' ) {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );






thinking
**Evaluating function stubs**

I’m thinking that if something returns false, it’s okay, but I need to consider how to adjust `get_post_meta` to use a global map. Since `check_acf_image_usage` uses `maybe_unserialize`, and that’s a WordPress function which might be missing in a standalone environment, it's necessary to add a stub in the bootstrap for our tests. I’ll make sure that the stub for `maybe_unserialize` doesn’t cause any conflicts with existing WordPress installations, implementing it only if it doesn’t exist.
thinking
**Defining ACF stubs**

I think it's okay to define the `acf_get_field_groups` function in the test file with a check for `function_exists`. However, since the namespace in the test file isn't global, I need to ensure there's a global namespace block. I could also consider patching the bootstrap-standalone to include these ACF stubs, but that might pollute the global space. I realize that `function_exists` checks for global functions, so defining it inside a namespaced block won't satisfy the function check in the ACF integration. It needs to reference the global function directly.
thinking
**Defining global function stubs**

I need to ensure that the global function `acf_get_field_groups` is defined correctly because a namespaced function wouldn’t work unless it’s in a global namespace block. So, I can either patch the bootstrap-standalone with global variables for test control or define it directly in the test file. Each approach is valid, but I should keep in mind that functions defined in a test file persist across the entire test suite. Next, I plan to modify the bootstrap-standalone to implement `maybe_unserialize` and an improved `get_post_meta`, making sure to follow the style guidelines carefully.
thinking
**Modifying get_post_meta stub**

I’m thinking about replacing the body of the `get_post_meta` stub. I’ll create a simple function where it checks for the `$map` and returns the value if it exists; otherwise, it will return defaults. I noticed that the tests will call `get_post_meta($post_id, '_my_gallery', true)`, and I plan to set the map value as 'field_gallery' (a string). So, if the `$key` exists in the map for the specified `post_id`, it should work smoothly without complications.
thinking
**Implementing stubs for serialization**

The `get_post_meta` stub should return the string if `$single` is true, which is good. Now, for the `maybe_unserialize` stub, I plan to implement it right after the main stub, along with other functions. The implementation logic is straightforward: it checks if the data is a string, trims it, and attempts to unserialize it. If it fails, the original data is returned. I realize I might not need `maybe_serialize`, but for now, I’ll focus on setting the global `wpha_test_post_meta` for the tests, patching `bootstrap-standalone.php` as needed.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/tests/bootstrap-standalone.php
@@ -1012,2 +1012,10 @@
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
@@ -1016,2 +1024,33 @@
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M tests/bootstrap-standalone.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.


thinking
**Checking PHP syntax**

I need to make sure that the syntax is okay after adding the maybe_unserialize stub and enhancing get_post_meta. My plan is to run a PHP linting command, specifically `php -l`, to check for any syntax errors in the bootstrap-standalone. It’s important to catch any issues early, so I'm going to move on that right away and confirm everything looks good!
exec
/bin/zsh -lc 'php -l tests/bootstrap-standalone.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 90ms:
No syntax errors detected in tests/bootstrap-standalone.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.

file update
A /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/tests/unit-standalone/Integration/AcfIntegrationTest.php
<?php
/**
 * ACF Integration Tests (Standalone)
 *
 * @package WPAdminHealth\Tests\UnitStandalone\Integration
 */

namespace {
	// Minimal ACF function stubs for standalone testing.
	if ( ! function_exists( 'acf_get_field_groups' ) ) {
		function acf_get_field_groups() {
			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
		}
	}

	if ( ! function_exists( 'acf_get_fields' ) ) {
		function acf_get_fields( $field_group_key ) {
			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
			}
			return array();
		}
	}

	if ( ! function_exists( 'acf_get_field' ) ) {
		function acf_get_field( $field_key ) {
			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
			}
			return false;
		}
	}

	if ( ! defined( 'ACF_VERSION' ) ) {
		define( 'ACF_VERSION', '6.0.0' );
	}
}

namespace WPAdminHealth\Tests\UnitStandalone\Integration;

use WPAdminHealth\Cache\MemoryCache;
use WPAdminHealth\Integrations\ACF;
use WPAdminHealth\Tests\Mocks\MockConnection;
use WPAdminHealth\Tests\StandaloneTestCase;

class AcfIntegrationTest extends StandaloneTestCase {

	private function set_acf_field_definitions(): void {
		$GLOBALS['wpha_test_acf_field_groups'] = array(
			array(
				'key'   => 'group_1',
				'title' => 'Test Group',
			),
		);

		$GLOBALS['wpha_test_acf_fields'] = array(
			'group_1' => array(
				array(
					'type'       => 'repeater',
					'key'        => 'field_repeater',
					'sub_fields' => array(
						array(
							'type' => 'gallery',
							'key'  => 'field_gallery',
						),
					),
				),
				array(
					'type'       => 'group',
					'key'        => 'field_group',
					'sub_fields' => array(
						array(
							'type' => 'file',
							'key'  => 'field_file',
						),
					),
				),
				array(
					'type'    => 'flexible_content',
					'key'     => 'field_flex',
					'layouts' => array(
						array(
							'sub_fields' => array(
								array(
									'type' => 'image',
									'key'  => 'field_flex_image',
								),
							),
						),
					),
				),
			),
		);

		$GLOBALS['wpha_test_acf_field_map'] = array(
			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
		);
	}

	public function test_get_media_field_keys_includes_nested_fields(): void {
		$this->set_acf_field_definitions();

		$integration = new ACF( new MockConnection(), new MemoryCache() );
		$keys        = $integration->get_media_field_keys();
		sort( $keys );

		$this->assertEquals(
			array( 'field_file', 'field_flex_image', 'field_gallery' ),
			$keys
		);
	}

	public function test_check_acf_image_usage_detects_gallery_ids(): void {
		$this->set_acf_field_definitions();

		$connection = new MockConnection();
		$connection->set_default_result( array() );

		$attachment_id = 123;
		$meta_value    = serialize( array( $attachment_id, 456 ) );

		$connection->set_expected_result(
			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
			array( $meta_value )
		);

		$integration = new ACF( $connection, new MemoryCache() );

		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
	}

	public function test_get_used_attachments_scans_acf_media_fields(): void {
		$this->set_acf_field_definitions();

		$connection = new MockConnection();
		$connection->set_default_result( array() );

		$results = array(
			serialize( array( 123, 456 ) ), // gallery field.
			'789', // direct ID field.
			'[123,999]', // JSON array.
		);

		$connection->set_expected_result(
			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
			$results
		);

		$integration = new ACF( $connection, new MemoryCache() );

		$ids = $integration->get_used_attachments( 10 );
		sort( $ids );

		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
	}

	public function test_get_attachment_usage_includes_field_label_context(): void {
		$this->set_acf_field_definitions();

		$post_id  = 42;
		$meta_key = 'my_gallery';

		$GLOBALS['wpha_test_post_meta'] = array(
			$post_id => array(
				'_' . $meta_key => 'field_gallery',
			),
		);

		$connection = new MockConnection();
		$connection->set_default_result( array() );

		$attachment_id = 123;

		$row             = new \stdClass();
		$row->post_id    = $post_id;
		$row->meta_key   = $meta_key;
		$row->meta_value = serialize( array( $attachment_id ) );
		$row->post_title = 'Test Post';

		$connection->set_expected_result(
			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
			array( $row )
		);

		$integration = new ACF( $connection, new MemoryCache() );
		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );

		$this->assertCount( 1, $usages );
		$this->assertEquals( $post_id, $usages[0]['post_id'] );
		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
	}
}

apply_patch(auto_approved=true) exited 0 in 63ms:
Success. Updated the following files:
A tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8b2c1e5927dd9254fc3856d5ec86ac7579ebe9f1
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration;
+
+use WPAdminHealth\Cache\MemoryCache;
+use WPAdminHealth\Integrations\ACF;
+use WPAdminHealth\Tests\Mocks\MockConnection;
+use WPAdminHealth\Tests\StandaloneTestCase;
+
+class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+}
+

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8b2c1e5927dd9254fc3856d5ec86ac7579ebe9f1
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration;
+
+use WPAdminHealth\Cache\MemoryCache;
+use WPAdminHealth\Integrations\ACF;
+use WPAdminHealth\Tests\Mocks\MockConnection;
+use WPAdminHealth\Tests\StandaloneTestCase;
+
+class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+}
+


thinking
**Verifying test file syntax**

I see we've added a file with a global namespace block, which is a good step. Now, I need to focus on the next plan, which is step 3: adding or adjusting automated tests. We're ready to get started, even though we’ve already done some work in this area. Before moving forward, I'll check the test file syntax by running a PHP lint command to ensure everything is in order. Let's see how that goes!
exec
/bin/zsh -lc 'php -l tests/unit-standalone/Integration/AcfIntegrationTest.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 255 in 110ms:

Fatal error: Cannot mix bracketed namespace declarations with unbracketed namespace declarations in tests/unit-standalone/Integration/AcfIntegrationTest.php on line 39
Errors parsing tests/unit-standalone/Integration/AcfIntegrationTest.php
PHP Fatal error:  Cannot mix bracketed namespace declarations with unbracketed namespace declarations in tests/unit-standalone/Integration/AcfIntegrationTest.php on line 39
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..8b2c1e5927dd9254fc3856d5ec86ac7579ebe9f1
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration;
+
+use WPAdminHealth\Cache\MemoryCache;
+use WPAdminHealth\Integrations\ACF;
+use WPAdminHealth\Tests\Mocks\MockConnection;
+use WPAdminHealth\Tests\StandaloneTestCase;
+
+class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+}
+

file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -38,10 +38,10 @@
 
-namespace WPAdminHealth\Tests\UnitStandalone\Integration;
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
 
-use WPAdminHealth\Cache\MemoryCache;
-use WPAdminHealth\Integrations\ACF;
-use WPAdminHealth\Tests\Mocks\MockConnection;
-use WPAdminHealth\Tests\StandaloneTestCase;
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
 
-class AcfIntegrationTest extends StandaloneTestCase {
+	class AcfIntegrationTest extends StandaloneTestCase {
 
@@ -194,3 +194,3 @@
 	}
+	}
 }
-
apply_patch(auto_approved=true) exited 0 in 61ms:
Success. Updated the following files:
M tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'php -l tests/unit-standalone/Integration/AcfIntegrationTest.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 108ms:
No syntax errors detected in tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}



thinking
**Updating project steps**

Okay, so I’m thinking about updating step 3 of the plan, but step 2 is still in progress, and we might not be done with it until tests pass. Actually, step 3 should be pending until we complete step 2. Maybe we should focus on finishing step 2 and running tests, and until then, step 3 will stay on hold. It seems like we need to finalize everything with step 2 first before moving ahead with step 3.
thinking
**Finalizing project steps**

It seems clear to me that step 2 should be marked as completed and step 3 can now be set to in progress. I think detection is fully implemented, so that gives me confidence to move forward. I’ll just go ahead and update the plan to reflect these changes: step 2 completed and step 3 in progress. Alright, let’s get this done!
Plan update
  ✓ Review current ACF integration logic
  ✓ Implement improved media detection
  → Add/adjust automated tests
  • Run lint and test suites
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}


thinking
**Running Tests for Validation**

I need to make sure that the tests compile properly and adjust anything if they fail. I think I will run `composer test:standalone` or at least the phpunit with standalone config to validate everything. While the verification commands didn't include this step, it’s important for quality checks. This might take a bit of time, but that's okay. I'll ensure we run these tests soon, even though I'm wondering if composer is installed; it should be there!
exec
/bin/zsh -lc 'composer test:standalone' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 1 in 292ms:
PHPUnit 9.6.31 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.16
Configuration: phpunit-standalone.xml

...............................................................  63 / 243 ( 25%)
.....................................................FFF....... 126 / 243 ( 51%)
............................................................... 189 / 243 ( 77%)
......................................................          243 / 243 (100%)

Time: 00:00.018, Memory: 10.00 MB

There were 3 failures:

1) WPAdminHealth\Tests\UnitStandalone\Integration\AcfIntegrationTest::test_check_acf_image_usage_detects_gallery_ids
Failed asserting that false is true.

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/tests/unit-standalone/Integration/AcfIntegrationTest.php:131

2) WPAdminHealth\Tests\UnitStandalone\Integration\AcfIntegrationTest::test_get_used_attachments_scans_acf_media_fields
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}






thinking
**Evaluating query issues**

I'm considering if the query string is using table names correctly, like the postmeta table. It looks like we're using 'wp_postmeta.' This seems fine, but I wonder if the query's backticks are causing issues. Maybe the prepare method changes strings in a way we didn't account for? Despite wildcards being present, our pattern matching might still be off. If `check_acf_image_usage` doesn’t return results, it likely means the query output was empty, so we should inspect the executed query in the test.
thinking
**Adjusting query tests**

I'm trying to find the easiest way to modify tests to check the query log, but it’s failing. Maybe I could reproduce this issue by running a small PHP snippet using integration and MockConnection to output the last query. I could use `php -r` in the shell, or I might fetch queries directly from `connection->get_queries` in the test. It’s crucial to define ABSPATH if I run outside PHPUnit, but it seems better to adjust expected result patterns to be more flexible for now. I really want to match the query properly!
thinking
**Inspecting query string**

I'm looking closely at the exact query string produced in `check_acf_image_usage`. After using `MockConnection`, placeholders like `'field_gallery'` and `'123'` are replaced. My field definitions include three keys: 'field_gallery', 'field_file', and 'field_flex_image'. I think the order of these keys matters, as they process fields like gallery first, which adds 'field_gallery' first.

Then we have `build_acf_attachment_like_patterns` creating various patterns, and I want to ensure our expected result pattern matches the entire query string even if it includes additional `INNER JOIN` clauses. I hope it all aligns!
thinking
**Analyzing newline issues**

I'm considering if the `MockConnection`'s prepare method preserves newlines. It seems it doesn’t remove them, but I realize that pattern matching uses regex where `.` doesn’t match newlines by default. Even though `.*` should match newlines, in this case, it's run without the 's' flag, which means it won't. This is critical because the query string has newlines. My patterns with `%%` won't match across those newline boundaries, so I'll need to adjust the patterns to work within single lines!
thinking
**Crafting regex patterns**

I’m looking at the pattern `'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%'` and realizing that it tries to match text that includes newlines, which `.*` doesn’t cover. So I definitely need to create patterns that work across newlines. Modifying `MockConnection` to add the 's' flag for regex might be complicated. Alternatively, I could set the expected result to directly include the query string, but that could be messy. I think the best route is to use single-line strings for queries to simplify pattern matching instead. I want to inspect how existing tests handle this!
exec
/bin/zsh -lc "rg -n \"set_expected_result\\(\" tests/unit-standalone | head -n 60" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 70ms:
tests/unit-standalone/Media/SafeDeleteTest.php:155:		$this->connection->set_expected_result(
tests/unit-standalone/Media/SafeDeleteTest.php:174:		$this->connection->set_expected_result(
tests/unit-standalone/Media/SafeDeleteTest.php:213:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:66:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:92:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:100:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:121:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:127:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:133:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:310:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:334:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:338:		$this->connection->set_expected_result(
tests/unit-standalone/Media/AltTextCheckerTest.php:342:		$this->connection->set_expected_result(
tests/unit-standalone/Integration/AcfIntegrationTest.php:124:		$connection->set_expected_result(
tests/unit-standalone/Integration/AcfIntegrationTest.php:146:		$connection->set_expected_result(
tests/unit-standalone/Integration/AcfIntegrationTest.php:182:		$connection->set_expected_result(
tests/unit-standalone/Mocks/MockConnectionTest.php:97:		$this->connection->set_expected_result( 'SELECT COUNT(*) FROM posts', 42 );
tests/unit-standalone/Mocks/MockConnectionTest.php:109:		$this->connection->set_expected_result( 'SELECT * FROM posts', $expected_data );
tests/unit-standalone/Mocks/MockConnectionTest.php:197:		$this->connection->set_expected_result( 'SELECT ID FROM posts', array( 1, 2, 3 ) );
tests/unit-standalone/Mocks/MockConnectionTest.php:248:		$this->connection->set_expected_result( 'SELECT 1', 1 );
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}


thinking
**Investigating patterns in tests**

I'm thinking about examining some patterns in other tests to understand how they manage newlines. For example, I wonder if the AltTextCheckerTest sets specific queries that include newlines. It seems like a good idea to open one and take a closer look to see how it's structured. Understanding the handling of newlines could really help clarify things for me!
exec
/bin/zsh -lc "sed -n '40,110p' tests/unit-standalone/Media/AltTextCheckerTest.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 69ms:
	 * @var AltTextChecker
	 */
	private AltTextChecker $checker;

	/**
	 * Set up test environment.
	 */
	protected function setup_test_environment(): void {
		$this->connection = new MockConnection();
		$this->exclusions = new MockExclusions();
		$this->checker    = new AltTextChecker( $this->connection, $this->exclusions );
	}

	/**
	 * Clean up test environment.
	 */
	protected function cleanup_test_environment(): void {
		$this->connection->reset();
		$this->exclusions->reset();
	}
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..eb29474ee734703a8927b2c5f0bc168241658ba4
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,196 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+	private function set_acf_field_definitions(): void {
+		$GLOBALS['wpha_test_acf_field_groups'] = array(
+			array(
+				'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
+			array( $meta_value )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_expected_result(
+			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
+			$results
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+		$connection->set_default_result( array() );
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_expected_result(
+			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
+			array( $row )
+		);
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+	}
+	}
+}






thinking
**Considering pattern creation**

I realize we can create a pattern that uses `%%` per line along with explicit newlines so each wildcard matches only within its line. However, the exact indentation is uncertain. I can copy from the code since the query string already includes newlines and tabs because of indentation. We can replicate it closely, except for placeholder substitutions. Yet, our wildcard `.*` cannot cross newlines, so I need to ensure each `%%` segment only includes characters within the same line. That's key for our pattern!
thinking
**Refining the query string pattern**

I’m looking at the example where our query string starts with a SELECT statement. After preparing, the IN clause will have quotes and commas, which affects our wildcard pattern. The current pattern `'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%'` fails because of the newline between "pm" and "fk.meta_value." I realize I should use a pattern that accounts for newlines and tabs, like `"%%FROM wp_postmeta pm\n\t\t\tINNER JOIN wp_postmeta fk%%"`. This should make the wildcards work without needing to match newlines!
thinking
**Capturing the query string**

I'm considering how the query string is built with double quotes and indentations from the file. I can maybe use `var_export` to view the actual string, but it’s not straightforward. Instead, I think I can capture the query string by replicating it in tests. I could call `integration->check_acf_image_usage` with a `MockConnection` that records the query, then check `connection->get_last_query`. However, I realize the expected result needs to be set before the call. So, maybe I just set `default_result` to `meta_values` and bypass the pattern matching to return true!
thinking
**Evaluating default_result implications**

I'm considering setting `default_result` to `array($meta_value)`, but I realize this could make any `get_col` call return that value, including unintended ones. This might lead the method to return true even without matching the pattern. I also notice that `default_result` is used for other query calls, but `check_acf_image_usage` calls `get_media_field_keys` with no DB involved. While this could simplify testing, it wouldn't effectively verify the query filter. Other tests could call `get_used_attachments` multiple times, leading to potential loops. So, we must ensure the method uses the new join logic, and we can check this by inspecting the query log afterward.
thinking
**Planning test adjustments**

I think `check_acf_image_usage` might run a join query and then parse the results. For the `get_used_attachments` test, I can set `default_result` to results array and call `get_used_attachments` with a batch size of maybe 10. This should run the query, and `get_col` will return results to parse and return IDs. We’ll assert that the query includes the join with `fk`.

For the `get_attachment_usage` test, I intend to set `default_result` to `array($row)` and call `get_attachment_usage($attachment_id,1)`. It’s crucial to ensure we're validating that the context includes the label and that the query contains the necessary joins. I also need to clear `global wpha_test_post_meta` after tests to avoid affecting others. It makes sense to implement a cleanup method in the test class to unset global variables and prevent leaks. Lastly, since we used `serialize()`, we can patch the tests accordingly.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -47,6 +47,13 @@
 
-	private function set_acf_field_definitions(): void {
-		$GLOBALS['wpha_test_acf_field_groups'] = array(
-			array(
-				'key'   => 'group_1',
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
 				'title' => 'Test Group',
@@ -118,3 +125,2 @@
 		$connection = new MockConnection();
-		$connection->set_default_result( array() );
 
@@ -123,6 +129,3 @@
 
-		$connection->set_expected_result(
-			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 50%%',
-			array( $meta_value )
-		);
+		$connection->set_default_result( array( $meta_value ) );
 
@@ -131,2 +134,6 @@
 		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
 	}
@@ -137,3 +144,2 @@
 		$connection = new MockConnection();
-		$connection->set_default_result( array() );
 
@@ -145,6 +151,3 @@
 
-		$connection->set_expected_result(
-			'%%FROM wp_postmeta pm%%fk.meta_value IN%%LIMIT 10 OFFSET 0%%',
-			$results
-		);
+		$connection->set_default_result( $results );
 
@@ -156,2 +159,6 @@
 		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
 	}
@@ -171,3 +178,2 @@
 		$connection = new MockConnection();
-		$connection->set_default_result( array() );
 
@@ -181,6 +187,3 @@
 
-		$connection->set_expected_result(
-			'%%SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title%%FROM wp_postmeta pm%%LIMIT 5%%',
-			array( $row )
-		);
+		$connection->set_default_result( array( $row ) );
 
@@ -193,2 +196,6 @@
 		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
 	}
apply_patch(auto_approved=true) exited 0 in 65ms:
Success. Updated the following files:
M tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'php -l tests/unit-standalone/Integration/AcfIntegrationTest.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 105ms:
No syntax errors detected in tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'composer test:standalone' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 272ms:
PHPUnit 9.6.31 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.16
Configuration: phpunit-standalone.xml

...............................................................  63 / 243 ( 25%)
............................................................... 126 / 243 ( 51%)
............................................................... 189 / 243 ( 77%)
......................................................          243 / 243 (100%)

Time: 00:00.017, Memory: 10.00 MB

OK (243 tests, 603 assertions)
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Updating test progress**

I’m happy that the standalone tests passed! Now, I'm working on step 3, where we added tests and ran composer test:standalone, even though that wasn't specifically requested. That’s alright, though! It looks like I could finish step 3 now. I’ll update the plan to mark step 3 as completed and move on to step 4, which involves running lint and npm test. Time to make those updates!
Plan update
  ✓ Review current ACF integration logic
  ✓ Implement improved media detection
  ✓ Add/adjust automated tests
  → Run lint and test suites
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Executing verification commands**

I'm preparing to run the specified verification commands. The format is set to none. First, I’ll execute `npm run lint` to check for any code style issues. After that, I’ll move on to `npm test` to ensure everything works as expected. Since the package already has `node_modules` installed, I can run these commands directly from the repository root. Let’s get started and see how it goes!
exec
/bin/zsh -lc 'npm run lint' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.46s:

> wp-admin-health-suite@1.0.0 lint
> eslint assets/js --ext .js,.jsx


/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/admin.js
    7:1  warning  Missing JSDoc @param "window" type    jsdoc/require-param-type
    8:1  warning  Missing JSDoc @param "$" type         jsdoc/require-param-type
  276:1  warning  Missing JSDoc @param "message" type   jsdoc/require-param-type
  277:1  warning  Missing JSDoc @param "duration" type  jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/charts.js
  7:1  warning  Missing JSDoc @param "window" type  jsdoc/require-param-type
  8:1  warning  Missing JSDoc @param "$" type       jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/HealthScoreCircle.jsx
  31:30  warning  'score' is missing in props validation    react/prop-types
  31:41  warning  'grade' is missing in props validation    react/prop-types
  31:54  warning  'loading' is missing in props validation  react/prop-types
  57:1   warning  Missing JSDoc @param "timestamp" type     jsdoc/require-param-type
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Running tests**

I see that the lint command succeeded, which is good, even though there were some warnings. Now it's time to move on to the next step and run `npm test`, which will execute the Jest testing framework. I'm eager to see how the tests go and if everything works smoothly! It feels a bit tense, but hopefully, I won't run into any issues. Let's do this!
exec
/bin/zsh -lc 'npm test' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.16s:

> wp-admin-health-suite@1.0.0 test
> jest --passWithNoTests

PASS assets/js/components/QuickActions.test.jsx
PASS assets/js/components/ActivityTimeline.test.jsx
  ● Console

    console.error
      Warning: An update to ActivityTimeline inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at ActivityTimeline (/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/ActivityTimeline.jsx:108:46)
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Updating plan progress**

I’m happy to see that the npm test passed, even if there were some console warnings. So now I’m moving on to plan step 4. We've completed the linting and testing, and it's good to note that before marking step 4 as complete. I’ll go ahead and update the plan to reflect this progress. It's crucial to keep everything organized and well-documented as I go along!
Plan update
  ✓ Review current ACF integration logic
  ✓ Implement improved media detection
  ✓ Add/adjust automated tests
  ✓ Run lint and test suites
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}







thinking
**Reviewing ACF implementation**

I need to confirm that we've fully implemented the spec regarding ACF field media detection across various fields. I should revisit the points: we improved gallery detection, added JSON array decode, and verified nested field keys extraction. We also need to confirm support for Group and Repeater fields. Additionally, check_acf_image_usage uses get_media_field_keys, which seems fine. However, there may be edge cases with ACF gallery values stored as serialized arrays that I need to address.
thinking
**Analyzing gallery meta_value serialization**

If a gallery's meta_value is a serialized array of integers, like `i:0;i:123;`, our pattern will match with `i:123;`. However, this could lead to issues where the array index 123 is mistaken as a key, impacting our candidate selection. Although we've implemented parsing and verification for safety, having a limit of 50 could still result in false negatives due to false positives. We also consider joining restricted media fields and fall back to a legacy scan with a limit of 200, which might carry the same risk. Maybe we should redesign the query to avoid limiting too much?
thinking
**Avoiding false negatives in queries**

If the attachment_id is 12 and there are several galleries with more than 12 images, both queries might return meta_values without actually matching. Given the limit of 50, there's a risk of picking up false positives, leading to potential false negatives when none of the selected values align. We could fall back to a legacy query with a 200 limit, but that might yield the same issue. To tackle this, we might reduce false positives by excluding the `i:<id>;` pattern and relying on `:"<id>";` for serialized strings. However, if values are stored as integers, we might miss them, although they might typically be strings. Not entirely sure, though!
thinking
**Optimizing query limits**

I could consider increasing the LIMIT significantly, maybe to 1000, to minimize the chance of missing matches. However, that could strain the system per attachment check. Instead, when checking usage for a specific attachment ID, it might be better to search for patterns in serialized arrays more precisely. Using a `REGEXP` in SQL could help ensure we're matching values and not keys. Although there’s a risk of still matching key occurrences, we can mitigate false negatives by prioritizing likely true matches in the ordered results.
thinking
**Improving attachment checks**

I’m thinking about using `ORDER BY` with a CASE statement to prioritize certain patterns in the query results, but that seems complex. Instead, I could avoid relying on LIMIT and implement a loop that utilizes `SELECT pm.meta_id, pm.meta_value` with offsets. This way, I would either find a match or reach a maximum number of iterations, thus preventing false negatives. However, balancing performance and efficiency is crucial, especially with high volumes of attachments, and I'm considering caching results from get_used_attachments to minimize repeated database queries. It could help streamline the checks while still providing accurate results, and maybe even allow for handling larger data volumes effectively, although managing memory for extensive lists is something to keep in mind. The ultimate goal is to prevent false negatives while maintaining performance, and a more adaptable query could be beneficial here.
thinking
**Evaluating query structure**

I'm looking at our `check_acf_image_usage` join query, which uses patterns involving JSON and serialized arrays. The pattern `i:12;` can be ambiguous because it might match a key index as well as a value. Without a specified order, MySQL defaults to returning the first 50 matching rows, which could lead to missing actual matches if there are many false positives. To create a more deterministic output and improve the chances of including real matches, I think we should add `ORDER BY pm.meta_id` and possibly increase the limit to 500, although I worry about the load since this method could be called thousands of times. I’ll also look into how other integrations, like Elementor, handle this to compare approaches.
exec
/bin/zsh -lc 'rg -n "function check_elementor_image_usage" -n includes/Integrations/Elementor.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
332:	public function check_elementor_image_usage( bool $is_used, int $attachment_id ): bool {
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc "sed -n '332,420p' includes/Integrations/Elementor.php" in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
	public function check_elementor_image_usage( bool $is_used, int $attachment_id ): bool {
		if ( $is_used ) {
			return $is_used;
		}

		$prefix     = $this->connection->get_prefix();

		// Search for the attachment ID pattern in Elementor builder/page-settings data.
		$meta_keys_placeholders = implode( ',', array_fill( 0, count( self::ELEMENTOR_META_KEYS ), '%s' ) );

		$like_patterns     = $this->build_attachment_like_patterns_strict( $attachment_id );
		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );

		// Use LIKE pre-filtering to avoid loading all Elementor data for every attachment.
		// We still verify via parsing to prevent false positives.
		$query = "SELECT pm.meta_value
			FROM {$prefix}postmeta pm
			INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
			WHERE pm.meta_key IN ($meta_keys_placeholders)
			AND p.post_status NOT IN ('trash', 'auto-draft')
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..2135a393ff5052e6b9dec37fdd7fd9268940d797
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,82 +268,166 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
+		}
+
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 50";
+
+		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
+				$query,
+				...$args
 			)
 		);
 
-		if ( $direct_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT pm.meta_value
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 200";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
+		$results = $this->connection->get_col(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
-			return true;
+		foreach ( $results as $meta_value ) {
+			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
+				return true;
+			}
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
-			)
-		);
+		return false;
+	}
+
+	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
 
-		return (bool) $json_match;
+		return array_values( array_unique( $patterns ) );
 	}
 
 	/**
@@ -369,11 +459,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,21 +717,88 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
 		$batches        = 0;
 		$results_count  = 0;
 
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +831,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +847,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +909,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +966,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1028,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}










thinking
**Evaluating attachment usage checks**

I’m thinking about how we need to determine used attachments while scanning thousands because false negatives could lead to deleting attachments mistakenly, which is definitely not good. It’s better to be cautious and err on the side of false positives rather than taking risks with false negatives. So, our method might need adjusting to avoid these risks. I wonder if checking patterns in SQL and limiting results could help mitigate this concern. Safety first!
thinking
**Refining the deletion tool**

I’m considering the deletion tool and how our current integration might create false negatives due to limited results when parsing. For instance, if there are multiple meta_values for an ID but not all of them are captured, we could end up mistakenly deleting something still in use. That would be bad! So, we need to adjust our checks. Maybe returning true if a value exists without parsing could help, but I’m worried about key collisions. A compromise might be necessary to detect usage effectively!
thinking
**Considering safety in ID checks**

I’m thinking about using a safe approach with specific patterns like `:"id";` and `i:id;` in SQL, ensuring we can return true if a match is found. This prevents false negatives since we're limiting the results. However, key collisions could lead to false positives, especially for smaller IDs, which makes detecting unused attachments more difficult. I wonder if our core scanner already checks for direct meta_value matches. Ultimately, I'd rather be conservative and risk false positives than accidentally delete something still in use. Safety first!
thinking
**Exploring attachment usage methods**

I’ve implemented the get_used_attachments method to accurately compute used attachments without false positives, but the scanner core isn't currently using it. I wonder if we could alter the scanner to utilize it via the integration's is_attachment_used. 

Instead, I’m considering having check_acf_image_usage return true on ambiguous SQL matches rather than relying on parsing, even as we still keep parsing for context.

For safe patterns like `:"id";`, we can query with LIMIT 1, while for ambiguous patterns, we may need to be cautious about possible false positives. Let's see how to adjust!
thinking
**Assessing attachment detection methods**

I’m looking into how to avoid false negatives when checking for used attachments. To do this, I might return true on ambiguous SQL matches. I’m considering simplifying the check_acf_image_usage to rely less on parsing and focus on patterns, especially for serialized strings. However, I recognize that ignoring certain patterns could lead to false positives.

I wonder if we should use the get_used_attachments function to compute used IDs and cache them for efficiency. It could be heavy, but ultimately safer than risking deletion of used attachments. Let’s find the best balance!
thinking
**Refining attachment usage checks**

I’m considering how to avoid false negatives in check_acf_image_usage by using the get_var function. I think it would be best to just return true if any matching meta_value patterns are found, without parsing. This approach maintains efficiency while allowing us to handle various stored formats, including JSON arrays.

However, I’m a bit concerned about potential false positives from key collisions if I include certain patterns, but I believe it might be acceptable in the name of safety. To further improve accuracy, a dual-phase approach could help, where I first check for safe patterns and then parse ambiguous ones if necessary. Let’s move forward with refining this process!
thinking
**Addressing attachment usage checks**

I'm thinking about how to improve our attachment usage checks, especially regarding the get_var response and ensuring accurate patterns in our query. I realize we need to adjust our patterns and might want to filter out any internal fields.

However, this introduces potential issues with false negatives due to limits in our current checks. I think increasing the limit or even making changes to how we handle serialized integers might help. By focusing on string patterns, we could potentially avoid matching keys and enhance overall safety while minimizing risks of errors. Let's explore these adjustments!
thinking
**Refining attachment usage checks**

I'm reassessing how we handle attachment usage checks. If values are stored as integers, we might not find matches due to key collisions. To mitigate this, I'm thinking of adjusting pattern requirements for serialized integers, ensuring that `i:id;` is strictly followed by certain delimiters. 

I also realize we could implement batched scanning, but that could be expensive. It seems safer to just return true on any match without parsing, even if it risks false positives. Ultimately, I'm planning to update the `check_acf_image_usage` method for efficiency and accuracy in usage checks while keeping the legacy adjustments in mind.
thinking
**Adjusting query checks**

I'm preparing to call `prepare` and `get_var`, with `MockConnection` set to return a default result of '1'. However, there’s a concern that the check method might erroneously return true for any attachment ID, which isn't desirable. I want to ensure we're using the right joins and patterns.

It seems simpler to set an expected result pattern, even if it's difficult with multi-line queries. I can focus on checking the query string to confirm it utilizes the join path properly. I'll proceed with the modifications to the ACF integration to reflect these changes.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/includes/Integrations/Acf.php
@@ -293,3 +293,3 @@
 
-		$query = "SELECT pm.meta_value
+		$query = "SELECT 1
 			FROM {$postmeta_table} pm
@@ -303,7 +303,6 @@
 			)
-			LIMIT 50";
+			LIMIT 1";
 
-		$args = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
-
-		$results = $this->connection->get_col(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
@@ -314,6 +313,4 @@
 
-		foreach ( $results as $meta_value ) {
-			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
-				return true;
-			}
+		if ( $match ) {
+			return true;
 		}
@@ -344,3 +341,3 @@
 
-		$query = "SELECT pm.meta_value
+		$query = "SELECT 1
 			FROM {$postmeta_table} pm
@@ -352,6 +349,6 @@
 			)
-			LIMIT 200";
+			LIMIT 1";
 
-		$args    = array_merge( array( $attachment_id_str ), $like_patterns );
-		$results = $this->connection->get_col(
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
@@ -362,9 +359,3 @@
 
-		foreach ( $results as $meta_value ) {
-			if ( $this->is_attachment_in_acf_value( $meta_value, $attachment_id ) ) {
-				return true;
-			}
-		}
-
-		return false;
+		return (bool) $match;
 	}
apply_patch(auto_approved=true) exited 0 in 62ms:
Success. Updated the following files:
M includes/Integrations/Acf.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'php -l includes/Integrations/Acf.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 101ms:
No syntax errors detected in includes/Integrations/Acf.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..58a7402b298635ebd69de71018e1efdaaaff218d
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$meta_value    = serialize( array( $attachment_id, 456 ) );
+
+		$connection->set_default_result( array( $meta_value ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -127,5 +127,3 @@
 		$attachment_id = 123;
-		$meta_value    = serialize( array( $attachment_id, 456 ) );
-
-		$connection->set_default_result( array( $meta_value ) );
+		$connection->set_default_result( '1' );
 
@@ -137,3 +135,5 @@
 		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
 		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
 	}
apply_patch(auto_approved=true) exited 0 in 62ms:
Success. Updated the following files:
M tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'php -l tests/unit-standalone/Integration/AcfIntegrationTest.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 105ms:
No syntax errors detected in tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'composer test:standalone' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 265ms:
PHPUnit 9.6.31 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.16
Configuration: phpunit-standalone.xml

...............................................................  63 / 243 ( 25%)
............................................................... 126 / 243 ( 51%)
............................................................... 189 / 243 ( 77%)
......................................................          243 / 243 (100%)

Time: 00:00.017, Memory: 10.00 MB

OK (243 tests, 605 assertions)
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Updating final response**

I need to verify that other tests likely don’t set any global map, so those remain unchanged. We’ve added a safe maybe_unserialize stub, which is good. Now, I'll ensure we follow all prompts correctly. I'll update the final response, including key elements: Status (DONE or NEEDS-REVIEW), Summary, verification steps (exact commands), and any Risks or follow-ups. I also want to run a git diff to summarize the changes and confirm that the code builds correctly.
exec
/bin/zsh -lc 'git diff --stat' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 80ms:
 .t2/state.json                 |   5 +-
 includes/Integrations/Acf.php  | 445 +++++++++++++++++++++++++++++------------
 tests/bootstrap-standalone.php |  39 ++++
 3 files changed, 364 insertions(+), 125 deletions(-)
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'git diff .t2/state.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 72ms:
diff --git a/.t2/state.json b/.t2/state.json
index 8fc8a20..4ac3b8b 100644
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,7 +50,8 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02"
+    "Q09-02",
+    "Q09-03"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -89,5 +90,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:53.715342Z"
+  "updated_at": "2026-01-17T10:41:57.735092Z"
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'git checkout -- .t2/state.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite exited 128 in 74ms:
fatal: Unable to create '/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/.git/index.lock': Operation not permitted
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'ls -la .git/index.lock || true' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 67ms:
ls: .git/index.lock: No such file or directory
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Analyzing version control options**

I realize that we can't use `git checkout` to revert changes due to restrictions. Instead, I'll need to use `apply_patch` to edit the file back manually. The sandbox probably doesn't allow writing to `.git`, so reverting with git isn't an option. I’ll use `apply_patch` to restore the file content. My next step is to read the current file, so I'll open `.t2/state.json` to check its current content.
exec
/bin/zsh -lc 'cat .t2/state.json' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
{
  "completed_task_ids": [
    "Q01-01",
    "Q01-02",
    "Q01-03",
    "Q01-04",
    "Q01-05",
    "Q02-01",
    "Q02-02",
    "Q02-03",
    "Q02-04",
    "Q02-05",
    "Q02-06",
    "Q02-07",
    "Q02-08",
    "Q02-09",
    "Q03-01",
    "Q03-02",
    "Q03-03",
    "Q03-04",
file update:
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Reverting to previous version**

I’m looking to revert to a previous version, specifically without the Q09-03 component. The tricky part is that I don’t have the exact previous timestamp, but from the diff, it looks like it was "2026-01-17T10:41:53.715342Z." I’ll set that timestamp and remove Q09-03 from the list to make the necessary changes. I just need to apply the patch accordingly to get everything updated correctly.
file update
M /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/.t2/state.json
@@ -52,4 +52,3 @@
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
@@ -92,3 +91,3 @@
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M .t2/state.json
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'git diff --stat' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 74ms:
 includes/Integrations/Acf.php  | 445 +++++++++++++++++++++++++++++------------
 tests/bootstrap-standalone.php |  39 ++++
 2 files changed, 361 insertions(+), 123 deletions(-)
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Revising testing strategy**

Alright, I've reverted the state.json, which is a relief. Now, I'm wondering if I should re-run the npm lint/test—probably not necessary since we only updated PHP and test bootstrap files. We did make changes to the ACF file, so running composer standalone tests could be prudent. But we already ran tests after modifications. Just to be safe, I'll run npm commands again for a final check; it might take some time, but it's quick! So, let's do `npm run lint` and `npm test` swiftly.
exec
/bin/zsh -lc 'npm run lint' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.40s:

> wp-admin-health-suite@1.0.0 lint
> eslint assets/js --ext .js,.jsx


/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/admin.js
    7:1  warning  Missing JSDoc @param "window" type    jsdoc/require-param-type
    8:1  warning  Missing JSDoc @param "$" type         jsdoc/require-param-type
  276:1  warning  Missing JSDoc @param "message" type   jsdoc/require-param-type
  277:1  warning  Missing JSDoc @param "duration" type  jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/charts.js
  7:1  warning  Missing JSDoc @param "window" type  jsdoc/require-param-type
  8:1  warning  Missing JSDoc @param "$" type       jsdoc/require-param-type

/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/HealthScoreCircle.jsx
  31:30  warning  'score' is missing in props validation    react/prop-types
  31:41  warning  'grade' is missing in props validation    react/prop-types
  31:54  warning  'loading' is missing in props validation  react/prop-types
  57:1   warning  Missing JSDoc @param "timestamp" type     jsdoc/require-param-type
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'npm test' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 1.08s:

> wp-admin-health-suite@1.0.0 test
> jest --passWithNoTests

PASS assets/js/components/QuickActions.test.jsx
PASS assets/js/components/ActivityTimeline.test.jsx
  ● Console

    console.error
      Warning: An update to ActivityTimeline inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at ActivityTimeline (/Users/ahmedyounis/Documents/Projects/wp-admin-health-suite/assets/js/components/ActivityTimeline.jsx:108:46)
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}


thinking
**Updating plan steps**

Okay, I'm thinking about updating step 4 of the plan. The plan is already completed, so there might not be a need for this. However, since we re-ran the commands, I think it's still a good idea to check the output of `git diff --stat` again to see if there are any changes. Let's keep an eye on that and see what we find!
exec
/bin/zsh -lc 'git diff --stat' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 73ms:
 includes/Integrations/Acf.php  | 445 +++++++++++++++++++++++++++++------------
 tests/bootstrap-standalone.php |  39 ++++
 2 files changed, 361 insertions(+), 123 deletions(-)
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

exec
/bin/zsh -lc 'ls -la tests/unit-standalone/Integration/AcfIntegrationTest.php' in /Users/ahmedyounis/Documents/Projects/wp-admin-health-suite succeeded in 68ms:
-rw-r--r--@ 1 ahmedyounis  staff  5730 Jan 17 03:07 tests/unit-standalone/Integration/AcfIntegrationTest.php
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}






thinking
**Summarizing test run details**

This isn’t a failure, but we can provide useful information in follow-ups. In the final response, I’ll include the status (DONE or NEEDS REVIEW), a summary of changes, how to verify with exact commands, and potential risks or follow-ups.

I’ll include the commands `npm run lint` and `npm test` as required, and mention the optional `composer test:standalone` for running PHP tests, even if the user didn’t specifically ask for that. I should note a risk regarding ACF pattern matching possibly yielding false positives for small attachment IDs, but reassure that we won’t miss important information with our current checks.
thinking
**Detailing code modifications**

I need to mention that the `check_acf_image_usage` now effectively filters for ACF media fields using `_meta_key` references and field group definitions, defaulting to a broad scan if those definitions aren't available. The media field keys are cached now, too! Additionally, the standalone bootstrap stubs have been updated for new tests and can potentially be used elsewhere. 

Also, we added JSON array decoding support, and the modifications should handle flexible content well. I'll ensure our code compiles for PHP 7.4, as we’ve already followed the necessary practices.
thinking
**Checking PHP modifications**

The spread operator in PHP 7.4 for arrays in function calls is supported, and I’ve already used it elsewhere. String indexing with `$trimmed[0]` is also fine. 

I confirmed that `is_attachment_in_acf_value` is used in `get_attachment_usage`. I should check that we added new docblocks with `@since 1.1.1`, and that looks good. Now, it's essential to verify that we didn't break anything for PHP CodeSniffer, although it isn’t strictly required. 

I'll consider running `composer lint:php`, but since we altered PHP code, it might be prudent. I’ll make sure there are no outstanding tasks and draft the final response accordingly, noting that including file paths and line numbers could be beneficial, even if it’s not necessary.
thinking
**Detailing final response components**

I need to make sure to mention key files like `includes/Integrations/Acf.php` and provide the path for any new test files as well. I’ll include the exact verification commands, which are `npm run lint` and `npm test`. 

I should also note any follow-ups related to potential false positives and possible improvements to the search options table for ACF options pages that weren't covered, even if the spec didn’t explicitly mention them. Additionally, I’ll point out that `npm run lint` outputs warnings, but no errors. Finally, I’ll craft the final answer in plain text with clear sections while avoiding markdown links, keeping it minimal but complete.
thinking
**Final response components**

I need to include the following details:

Status: DONE

Summary of changes:  
- Enhanced ACF media detection to include gallery arrays and JSON formats, targeting media fields using ACF field key references while supporting nested fields like repeater, group, and flexible content.  
- Implemented caching for ACF media field key extraction.  
- Added standalone test support along with tests for ACF integration, plus improved standalone bootstrap stubs for `get_post_meta` mapping and `maybe_unserialize`.

How to verify:  
- Run `npm run lint`  
- Run `npm test`  
- Optionally, run `composer test:standalone`.  

Risks/follow-ups:  
The `check_acf_image_usage` function uses broad LIKE patterns, which could lead to false positives for small attachment IDs appearing as serialized array indexes. This method is safer for deletion, but it might under-report unused media. If ACF field definitions or `_field_name` references are missing, it falls back to a broad scan, which might be heavier. 

I should mention changed files as: `includes/Integrations/Acf.php`, `tests/bootstrap-standalone.php`, and `tests/unit-standalone/Integration/AcfIntegrationTest.php`. The new test file is untracked. Lastly, I’ll make sure not to include any references to `.plans`.
codex
Status: DONE

Summary of changes:
- Updated `includes/Integrations/Acf.php` to detect ACF media usage across `image`, `file`, and especially `gallery` fields (serialized arrays + JSON arrays/objects), including nested Repeater/Group/Flexible Content sub-fields by filtering to ACF media fields via the `_field_name` → `field_...` references.
- Cached ACF media field-key discovery to avoid repeatedly parsing field groups.
- Added standalone coverage: enhanced `tests/bootstrap-standalone.php` stubs and added `tests/unit-standalone/Integration/AcfIntegrationTest.php` to verify nested field-key extraction + gallery detection + labeled context.

How to verify:
- `npm run lint`
- `npm test`

Risks / follow-ups:
- `check_acf_image_usage()` intentionally uses broad LIKE patterns (including serialized `i:<id>;`) to avoid false negatives; this can yield false positives for small IDs that appear as serialized array indexes, which is safer for “unused media” deletion but may under-report unused media in edge cases.
file update:
diff --git a/.t2/state.json b/.t2/state.json
index 4ac3b8be19f1ddefceda91ab6339732b1356d2a6..8fc8a20239d5c022502083c284d95433ec4481d0
--- a/.t2/state.json
+++ b/.t2/state.json
@@ -50,8 +50,7 @@
     "Q08-03",
     "Q08-04",
     "Q09-01",
-    "Q09-02",
-    "Q09-03"
+    "Q09-02"
   ],
   "claude_sessions": {
     "Q01-01": "5e05e067-351c-42d8-b76a-fe63b7a2bad5",
@@ -90,5 +89,5 @@
     "Q06-03": "b059f094-5965-49ed-bfb1-6d207b7daf67"
   },
   "gemini_sessions": {},
-  "updated_at": "2026-01-17T10:41:57.735092Z"
+  "updated_at": "2026-01-17T10:41:53.715342Z"
 }
diff --git a/includes/Integrations/Acf.php b/includes/Integrations/Acf.php
index 3a4cc192aab85c80d323ff59bc97e55bba4b3079..50ae8f8be6f9aa736b6b9a785ac5055ac75e61c3
--- a/includes/Integrations/Acf.php
+++ b/includes/Integrations/Acf.php
@@ -177,21 +177,27 @@
 			return array();
 		}
 
-		$media_fields = array();
-		$field_groups = acf_get_field_groups();
+		return $this->remember(
+			'media_field_keys',
+			function (): array {
+				$media_fields = array();
+				$field_groups = acf_get_field_groups();
 
-		foreach ( $field_groups as $field_group ) {
-			$fields = acf_get_fields( $field_group['key'] );
+				foreach ( $field_groups as $field_group ) {
+					$fields = acf_get_fields( $field_group['key'] );
 
-			if ( $fields ) {
-				$media_fields = array_merge(
-					$media_fields,
-					$this->extract_media_fields( $fields )
-				);
-			}
-		}
+					if ( $fields ) {
+						$media_fields = array_merge(
+							$media_fields,
+							$this->extract_media_fields( $fields )
+						);
+					}
+				}
 
-		return $media_fields;
+				return array_values( array_unique( $media_fields ) );
+			},
+			300
+		);
 	}
 
 	/**
@@ -262,85 +268,160 @@
 			return $is_used;
 		}
 
-		$prefix            = $this->connection->get_prefix();
+		$attachment_id = absint( $attachment_id );
+
+		if ( $attachment_id <= 0 ) {
+			return false;
+		}
+
 		$attachment_id_str = (string) $attachment_id;
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 
-		// Check for direct numeric match in meta_value (most common ACF storage).
-		$direct_match = $this->connection->get_var(
-			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND pm.meta_value = %s
-				LIMIT 1",
-				$attachment_id_str
-			)
-		);
+		$media_field_keys = $this->get_media_field_keys();
 
-		if ( $direct_match ) {
-			return true;
+		// If we can't determine media field keys, fall back to broad pattern matching.
+		// This is less precise but avoids false negatives when ACF field definitions
+		// aren't available (e.g., early bootstrapping or partial installs).
+		if ( empty( $media_field_keys ) ) {
+			return $this->check_acf_image_usage_legacy( $attachment_id );
 		}
 
-		// Escape the attachment ID for use in LIKE patterns.
-		$escaped_id = $this->connection->esc_like( (string) $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+		$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND fk.meta_value IN ({$in_placeholders})
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
 
-		// Check for serialized PHP array format: "id";i:123; or s:2:"id";i:123;
-		// The semicolon provides a natural word boundary in serialized data.
-		$serialized_match = $this->connection->get_var(
+		$args  = array_merge( $media_field_keys, array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%'
+				$query,
+				...$args
 			)
 		);
 
-		if ( $serialized_match ) {
+		if ( $match ) {
 			return true;
 		}
 
-		// Check for JSON format: "id":123 followed by word boundary (, } ] or space).
-		// This prevents false positives where ID 12 matches in "id":123.
-		$json_match = $this->connection->get_var(
+		// Some installs may have missing `_field_name` reference rows. Fall back to
+		// a broader scan to avoid false negatives.
+		return $this->check_acf_image_usage_legacy( $attachment_id );
+	}
+
+	/**
+	 * Legacy ACF attachment usage check (broad scan).
+	 *
+	 * Used as a fallback when field definitions or `_field_name` key references
+	 * aren't available. This is less precise but avoids false negatives.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return bool True if found.
+	 */
+	private function check_acf_image_usage_legacy( int $attachment_id ): bool {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		$query = "SELECT 1
+			FROM {$postmeta_table} pm
+			INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+			WHERE p.post_status NOT IN ('trash', 'auto-draft')
+			AND (
+				pm.meta_value = %s
+				OR {$like_placeholders}
+			)
+			LIMIT 1";
+
+		$args  = array_merge( array( $attachment_id_str ), $like_patterns );
+		$match = $this->connection->get_var(
 			$this->connection->prepare(
-				"SELECT 1
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT 1",
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"id":' . $escaped_id . ']%',
-				'%"id": ' . $escaped_id . '%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ']%',
-				'%"ID": ' . $escaped_id . '%'
+				$query,
+				...$args
 			)
 		);
 
-		return (bool) $json_match;
+		return (bool) $match;
 	}
 
 	/**
+	 * Build LIKE patterns to locate an attachment ID in ACF meta blobs.
+	 *
+	 * ACF can store attachment IDs as:
+	 * - Plain ID strings/ints
+	 * - Serialized arrays (gallery) and objects
+	 * - JSON arrays/objects (newer usage patterns)
+	 *
+	 * Patterns are intentionally broad and should be paired with
+	 * {@see is_attachment_in_acf_value()} for verification.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @return array<string> LIKE patterns.
+	 */
+	private function build_acf_attachment_like_patterns( int $attachment_id ): array {
+		$id      = (string) absint( $attachment_id );
+		$escaped = $this->connection->esc_like( $id );
+
+		$patterns = array();
+
+		// Serialized:
+		// - Integers: i:123;
+		// - Strings: s:N:"123"; (we match the stable suffix: :"123";)
+		$patterns[] = '%' . $this->connection->esc_like( 'i:' . $id . ';' ) . '%';
+		$patterns[] = '%' . $this->connection->esc_like( ':"' . $id . '";' ) . '%';
+
+		// JSON objects (common ACF object formats).
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%"id":' . $space . $escaped . ',%';
+			$patterns[] = '%"id":' . $space . $escaped . '}%';
+			$patterns[] = '%"id":' . $space . $escaped . ']%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"id":' . $space . '"' . $escaped . '"]%';
+
+			$patterns[] = '%"ID":' . $space . $escaped . ',%';
+			$patterns[] = '%"ID":' . $space . $escaped . '}%';
+			$patterns[] = '%"ID":' . $space . $escaped . ']%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '",%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"}%';
+			$patterns[] = '%"ID":' . $space . '"' . $escaped . '"]%';
+		}
+
+		// JSON arrays: [123,456], [123], ["123","456"].
+		foreach ( array( '', ' ' ) as $space ) {
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ',' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',' . $space . $id . ']' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '[' . $space . $id . ']' ) . '%';
+
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '",' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( ',"' . $id . '"]' ) . '%';
+			$patterns[] = '%' . $this->connection->esc_like( '["' . $id . '"]' ) . '%';
+		}
+
+		return array_values( array_unique( $patterns ) );
+	}
+
+	/**
 	 * Check if an attachment ID is present in ACF field value.
 	 *
 	 * Handles various ACF storage formats:
@@ -369,11 +450,14 @@
 			return $this->search_acf_data_structure( $unserialized, $attachment_id );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->search_acf_data_structure( $decoded, $attachment_id );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->search_acf_data_structure( $decoded, $attachment_id );
+				}
 			}
 		}
 
@@ -624,7 +708,76 @@
 	 * @return array<int> Array of attachment IDs.
 	 */
 	public function get_used_attachments( int $batch_size = 1000 ): array {
-		$prefix         = $this->connection->get_prefix();
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+		$attachment_ids = array();
+		$offset         = 0;
+		$max_batches    = 100; // Safety limit: max 100k rows total.
+		$batches        = 0;
+		$results_count  = 0;
+
+		$media_field_keys = $this->get_media_field_keys();
+
+		// If we can't identify media field keys, fall back to legacy broad scan.
+		if ( empty( $media_field_keys ) ) {
+			return $this->get_used_attachments_legacy( $batch_size );
+		}
+
+		$in_placeholders = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+
+		do {
+			$results = $this->connection->get_col(
+				$this->connection->prepare(
+					"SELECT pm.meta_value
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					ORDER BY pm.meta_id
+					LIMIT %d OFFSET %d",
+					...array_merge( $media_field_keys, array( $batch_size, $offset ) )
+				)
+			);
+
+			if ( empty( $results ) ) {
+				break;
+			}
+
+			foreach ( $results as $meta_value ) {
+				$ids            = $this->extract_attachment_ids_from_acf_value( $meta_value );
+				$attachment_ids = array_merge( $attachment_ids, $ids );
+			}
+
+			$offset += $batch_size;
+			++$batches;
+			$results_count = count( $results );
+
+		} while ( $results_count === $batch_size && $batches < $max_batches );
+
+		// Log warning if we hit the safety limit.
+		if ( $batches >= $max_batches && $results_count === $batch_size ) {
+			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+		}
+
+		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
+	}
+
+	/**
+	 * Legacy implementation for scanning used attachments in ACF fields.
+	 *
+	 * Falls back to a broad scan across postmeta values when field definitions
+	 * aren't available.
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $batch_size Batch size.
+	 * @return array<int> Attachment IDs.
+	 */
+	private function get_used_attachments_legacy( int $batch_size = 1000 ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
 		$attachment_ids = array();
 		$offset         = 0;
 		$max_batches    = 100; // Safety limit: max 100k rows total.
@@ -632,13 +785,11 @@
 		$results_count  = 0;
 
 		do {
-			// Query for numeric meta values that could be attachment IDs.
-			// Also query for serialized/JSON data that might contain IDs.
 			$results = $this->connection->get_col(
 				$this->connection->prepare(
 					"SELECT DISTINCT pm.meta_value
-					FROM {$prefix}postmeta pm
-					INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
+					FROM {$postmeta_table} pm
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
 					WHERE p.post_status NOT IN ('trash', 'auto-draft')
 					AND (
 						pm.meta_value REGEXP %s
@@ -671,7 +822,7 @@
 
 		// Log warning if we hit the safety limit.
 		if ( $batches >= $max_batches && $results_count === $batch_size ) {
-			$this->log_batch_limit_warning( 'get_used_attachments', $batches, $max_batches, $batch_size );
+			$this->log_batch_limit_warning( 'get_used_attachments_legacy', $batches, $max_batches, $batch_size );
 		}
 
 		return array_unique( array_filter( array_map( 'absint', $attachment_ids ) ) );
@@ -687,50 +838,61 @@
 	 * @return array<array{post_id: int, post_title: string, context: string}> Array of usage locations.
 	 */
 	public function get_attachment_usage( int $attachment_id, int $limit = 100 ): array {
-		$prefix            = $this->connection->get_prefix();
+		$postmeta_table    = $this->connection->get_postmeta_table();
+		$posts_table       = $this->connection->get_posts_table();
 		$usages            = array();
 		$attachment_id_str = (string) $attachment_id;
-		$escaped_id        = $this->connection->esc_like( $attachment_id_str );
 
-		// Search for meta values containing this specific attachment ID.
-		// Uses word boundaries to prevent false positives (e.g., ID 12 matching 123).
-		$results = $this->connection->get_results(
-			$this->connection->prepare(
-				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
-				FROM {$prefix}postmeta pm
-				INNER JOIN {$prefix}posts p ON pm.post_id = p.ID
-				WHERE p.post_status NOT IN ('trash', 'auto-draft')
-				AND (
-					pm.meta_value = %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-					OR pm.meta_value LIKE %s
-				)
-				LIMIT %d",
-				$attachment_id_str,
-				'%"id";i:' . $escaped_id . ';%',
-				'%"ID";i:' . $escaped_id . ';%',
-				'%"id":' . $escaped_id . ',%',
-				'%"id":' . $escaped_id . '}%',
-				'%"ID":' . $escaped_id . ',%',
-				'%"ID":' . $escaped_id . '}%',
-				$limit
-			),
-			'OBJECT'
-		);
+		$media_field_keys = $this->get_media_field_keys();
+		$like_patterns    = $this->build_acf_attachment_like_patterns( $attachment_id );
+
+		// If we can't identify media field keys, fall back to the legacy broad query.
+		if ( empty( $media_field_keys ) ) {
+			$results = $this->get_attachment_usage_legacy_results( $attachment_id, $limit );
+		} else {
+			$in_placeholders   = implode( ',', array_fill( 0, count( $media_field_keys ), '%s' ) );
+			$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+			// Pull more than the requested limit to account for possible false positives from LIKE patterns.
+			$query_limit = min( $limit * 5, 500 );
+
+			$results = $this->connection->get_results(
+				$this->connection->prepare(
+					"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+					FROM {$postmeta_table} pm
+					INNER JOIN {$postmeta_table} fk ON fk.post_id = pm.post_id AND fk.meta_key = CONCAT('_', pm.meta_key)
+					INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+					WHERE p.post_status NOT IN ('trash', 'auto-draft')
+					AND fk.meta_value IN ({$in_placeholders})
+					AND (
+						pm.meta_value = %s
+						OR {$like_placeholders}
+					)
+					LIMIT %d",
+					...array_merge(
+						$media_field_keys,
+						array( $attachment_id_str ),
+						$like_patterns,
+						array( $query_limit )
+					)
+				),
+				'OBJECT'
+			);
+		}
 
 		foreach ( $results as $result ) {
 			if ( $this->is_attachment_in_acf_value( $result->meta_value, $attachment_id ) ) {
-				$context = $this->get_acf_field_context( $result->meta_key, $result->meta_value, $attachment_id );
+				$context = $this->get_acf_field_context( absint( $result->post_id ), $result->meta_key, $result->meta_value, $attachment_id );
 
 				$usages[] = array(
 					'post_id'    => absint( $result->post_id ),
 					'post_title' => $result->post_title,
 					'context'    => $context,
 				);
+
+				if ( count( $usages ) >= $limit ) {
+					break;
+				}
 			}
 		}
 
@@ -738,6 +900,40 @@
 	}
 
 	/**
+	 * Legacy results fetch for attachment usage in ACF fields (broad scan).
+	 *
+	 * @since 1.1.1
+	 *
+	 * @param int $attachment_id Attachment ID.
+	 * @param int $limit         Limit.
+	 * @return array<int, object> Results (OBJECT rows).
+	 */
+	private function get_attachment_usage_legacy_results( int $attachment_id, int $limit ): array {
+		$postmeta_table = $this->connection->get_postmeta_table();
+		$posts_table    = $this->connection->get_posts_table();
+
+		$attachment_id_str = (string) absint( $attachment_id );
+		$like_patterns     = $this->build_acf_attachment_like_patterns( $attachment_id );
+		$like_placeholders = implode( ' OR ', array_fill( 0, count( $like_patterns ), 'pm.meta_value LIKE %s' ) );
+
+		return $this->connection->get_results(
+			$this->connection->prepare(
+				"SELECT pm.post_id, pm.meta_key, pm.meta_value, p.post_title
+				FROM {$postmeta_table} pm
+				INNER JOIN {$posts_table} p ON pm.post_id = p.ID
+				WHERE p.post_status NOT IN ('trash', 'auto-draft')
+				AND (
+					pm.meta_value = %s
+					OR {$like_placeholders}
+				)
+				LIMIT %d",
+				...array_merge( array( $attachment_id_str ), $like_patterns, array( min( $limit * 5, 500 ) ) )
+			),
+			'OBJECT'
+		);
+	}
+
+	/**
 	 * Extract all attachment IDs from an ACF field value.
 	 *
 	 * @since 1.1.0
@@ -761,11 +957,14 @@
 			return $this->collect_ids_from_acf_structure( $unserialized );
 		}
 
-		// Try to decode JSON if it's JSON data.
-		if ( is_string( $meta_value ) && '{' === substr( $meta_value, 0, 1 ) ) {
-			$decoded = json_decode( $meta_value, true );
-			if ( null !== $decoded ) {
-				return $this->collect_ids_from_acf_structure( $decoded );
+		// Try to decode JSON if it's JSON data (object or array).
+		if ( is_string( $meta_value ) ) {
+			$trimmed = ltrim( $meta_value );
+			if ( '' !== $trimmed && ( '{' === $trimmed[0] || '[' === $trimmed[0] ) ) {
+				$decoded = json_decode( $trimmed, true );
+				if ( null !== $decoded ) {
+					return $this->collect_ids_from_acf_structure( $decoded );
+				}
 			}
 		}
 
@@ -820,11 +1019,11 @@
 	 * @param int    $attachment_id The attachment ID.
 	 * @return string Context description.
 	 */
-	private function get_acf_field_context( string $meta_key, $meta_value, int $attachment_id ): string {
+	private function get_acf_field_context( int $post_id, string $meta_key, $meta_value, int $attachment_id ): string {
 		// Try to get field label from ACF.
 		if ( function_exists( 'acf_get_field' ) ) {
 			// ACF stores field key references with underscore prefix.
-			$field_key_meta = get_metadata( 'post', 0, '_' . ltrim( $meta_key, '_' ), true );
+			$field_key_meta = get_post_meta( $post_id, '_' . ltrim( $meta_key, '_' ), true );
 
 			if ( $field_key_meta && is_string( $field_key_meta ) && strpos( $field_key_meta, 'field_' ) === 0 ) {
 				$field = acf_get_field( $field_key_meta );
diff --git a/tests/bootstrap-standalone.php b/tests/bootstrap-standalone.php
index 412121fcb655495ae3a14bd23d362740666adfed..654aca7cca9317d821a8796a68d7321c077537df
--- a/tests/bootstrap-standalone.php
+++ b/tests/bootstrap-standalone.php
@@ -1010,10 +1010,49 @@
 	 * @return mixed Meta value(s).
 	 */
 	function get_post_meta( $post_id, $key = '', $single = false ) {
+		// Allow tests to inject meta values via a global map.
+		// Format: [ post_id => [ meta_key => value ] ].
+		if ( isset( $GLOBALS['wpha_test_post_meta'] ) && is_array( $GLOBALS['wpha_test_post_meta'] ) ) {
+			$map = $GLOBALS['wpha_test_post_meta'];
+			if ( isset( $map[ $post_id ] ) && is_array( $map[ $post_id ] ) && array_key_exists( $key, $map[ $post_id ] ) ) {
+				return $map[ $post_id ][ $key ];
+			}
+		}
 		return $single ? '' : array();
 	}
 }
 
+if ( ! function_exists( 'maybe_unserialize' ) ) {
+	/**
+	 * Maybe unserialize stub.
+	 *
+	 * Mirrors WordPress behavior: attempts to unserialize strings, otherwise returns input.
+	 *
+	 * @param mixed $data Data that might be serialized.
+	 * @return mixed Unserialized data or original.
+	 */
+	function maybe_unserialize( $data ) {
+		if ( ! is_string( $data ) ) {
+			return $data;
+		}
+
+		$data = trim( $data );
+
+		if ( '' === $data ) {
+			return $data;
+		}
+
+		// phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
+		$unserialized = @unserialize( $data );
+
+		if ( false !== $unserialized || 'b:0;' === $data ) {
+			return $unserialized;
+		}
+
+		return $data;
+	}
+}
+
 if ( ! function_exists( 'update_post_meta' ) ) {
 	/**
 	 * Update post meta stub.
diff --git a/tests/unit-standalone/Integration/AcfIntegrationTest.php b/tests/unit-standalone/Integration/AcfIntegrationTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..e8f9ffead373ee72bbcd6fcfbd61ff7eecd7e040
--- /dev/null
+++ b/tests/unit-standalone/Integration/AcfIntegrationTest.php
@@ -0,0 +1,203 @@
+<?php
+/**
+ * ACF Integration Tests (Standalone)
+ *
+ * @package WPAdminHealth\Tests\UnitStandalone\Integration
+ */
+
+namespace {
+	// Minimal ACF function stubs for standalone testing.
+	if ( ! function_exists( 'acf_get_field_groups' ) ) {
+		function acf_get_field_groups() {
+			return $GLOBALS['wpha_test_acf_field_groups'] ?? array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_fields' ) ) {
+		function acf_get_fields( $field_group_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_fields'] ) && is_array( $GLOBALS['wpha_test_acf_fields'] ) ) {
+				return $GLOBALS['wpha_test_acf_fields'][ $field_group_key ] ?? array();
+			}
+			return array();
+		}
+	}
+
+	if ( ! function_exists( 'acf_get_field' ) ) {
+		function acf_get_field( $field_key ) {
+			if ( isset( $GLOBALS['wpha_test_acf_field_map'] ) && is_array( $GLOBALS['wpha_test_acf_field_map'] ) ) {
+				return $GLOBALS['wpha_test_acf_field_map'][ $field_key ] ?? false;
+			}
+			return false;
+		}
+	}
+
+	if ( ! defined( 'ACF_VERSION' ) ) {
+		define( 'ACF_VERSION', '6.0.0' );
+	}
+}
+
+namespace WPAdminHealth\Tests\UnitStandalone\Integration {
+
+	use WPAdminHealth\Cache\MemoryCache;
+	use WPAdminHealth\Integrations\ACF;
+	use WPAdminHealth\Tests\Mocks\MockConnection;
+	use WPAdminHealth\Tests\StandaloneTestCase;
+
+	class AcfIntegrationTest extends StandaloneTestCase {
+
+		protected function cleanup_test_environment(): void {
+			unset( $GLOBALS['wpha_test_acf_field_groups'] );
+			unset( $GLOBALS['wpha_test_acf_fields'] );
+			unset( $GLOBALS['wpha_test_acf_field_map'] );
+			unset( $GLOBALS['wpha_test_post_meta'] );
+		}
+
+		private function set_acf_field_definitions(): void {
+			$GLOBALS['wpha_test_acf_field_groups'] = array(
+				array(
+					'key'   => 'group_1',
+				'title' => 'Test Group',
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_fields'] = array(
+			'group_1' => array(
+				array(
+					'type'       => 'repeater',
+					'key'        => 'field_repeater',
+					'sub_fields' => array(
+						array(
+							'type' => 'gallery',
+							'key'  => 'field_gallery',
+						),
+					),
+				),
+				array(
+					'type'       => 'group',
+					'key'        => 'field_group',
+					'sub_fields' => array(
+						array(
+							'type' => 'file',
+							'key'  => 'field_file',
+						),
+					),
+				),
+				array(
+					'type'    => 'flexible_content',
+					'key'     => 'field_flex',
+					'layouts' => array(
+						array(
+							'sub_fields' => array(
+								array(
+									'type' => 'image',
+									'key'  => 'field_flex_image',
+								),
+							),
+						),
+					),
+				),
+			),
+		);
+
+		$GLOBALS['wpha_test_acf_field_map'] = array(
+			'field_gallery'    => array( 'label' => 'Gallery Label', 'type' => 'gallery' ),
+			'field_file'       => array( 'label' => 'File Label', 'type' => 'file' ),
+			'field_flex_image' => array( 'label' => 'Flex Image Label', 'type' => 'image' ),
+		);
+	}
+
+	public function test_get_media_field_keys_includes_nested_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$integration = new ACF( new MockConnection(), new MemoryCache() );
+		$keys        = $integration->get_media_field_keys();
+		sort( $keys );
+
+		$this->assertEquals(
+			array( 'field_file', 'field_flex_image', 'field_gallery' ),
+			$keys
+		);
+	}
+
+	public function test_check_acf_image_usage_detects_gallery_ids(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+		$connection->set_default_result( '1' );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$this->assertTrue( $integration->check_acf_image_usage( false, $attachment_id ) );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'SELECT 1', $last_query['query'] );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+		$this->assertStringContainsString( 'i:123;', $last_query['query'] );
+	}
+
+	public function test_get_used_attachments_scans_acf_media_fields(): void {
+		$this->set_acf_field_definitions();
+
+		$connection = new MockConnection();
+
+		$results = array(
+			serialize( array( 123, 456 ) ), // gallery field.
+			'789', // direct ID field.
+			'[123,999]', // JSON array.
+		);
+
+		$connection->set_default_result( $results );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+
+		$ids = $integration->get_used_attachments( 10 );
+		sort( $ids );
+
+		$this->assertEquals( array( 123, 456, 789, 999 ), $ids );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+
+	public function test_get_attachment_usage_includes_field_label_context(): void {
+		$this->set_acf_field_definitions();
+
+		$post_id  = 42;
+		$meta_key = 'my_gallery';
+
+		$GLOBALS['wpha_test_post_meta'] = array(
+			$post_id => array(
+				'_' . $meta_key => 'field_gallery',
+			),
+		);
+
+		$connection = new MockConnection();
+
+		$attachment_id = 123;
+
+		$row             = new \stdClass();
+		$row->post_id    = $post_id;
+		$row->meta_key   = $meta_key;
+		$row->meta_value = serialize( array( $attachment_id ) );
+		$row->post_title = 'Test Post';
+
+		$connection->set_default_result( array( $row ) );
+
+		$integration = new ACF( $connection, new MemoryCache() );
+		$usages      = $integration->get_attachment_usage( $attachment_id, 1 );
+
+		$this->assertCount( 1, $usages );
+		$this->assertEquals( $post_id, $usages[0]['post_id'] );
+		$this->assertEquals( 'Test Post', $usages[0]['post_title'] );
+		$this->assertEquals( 'ACF gallery field: Gallery Label', $usages[0]['context'] );
+
+		$last_query = $connection->get_last_query();
+		$this->assertIsArray( $last_query );
+		$this->assertStringContainsString( 'INNER JOIN wp_postmeta fk', $last_query['query'] );
+	}
+	}
+}

tokens used
257,598
